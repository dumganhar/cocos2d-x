#include "scripting/js-bindings/auto/jsb_cocos2dx_auto.hpp"
#include "scripting/js-bindings/manual/jsb_conversions.hpp"
#include "cocos2d.h"
#include "audio/include/SimpleAudioEngine.h"
#include "2d/CCProtectedNode.h"
#include "base/CCAsyncTaskPool.h"

se::Object* __jsb_cocos2d_Texture2D_proto = nullptr;
se::Class* __jsb_cocos2d_Texture2D_class = nullptr;

static bool js_cocos2dx_Texture2D_getGLProgram(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLProgram* result = cobj->getGLProgram();
        ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getGLProgram : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getGLProgram)

static bool js_cocos2dx_Texture2D_getMaxT(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getMaxT : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getMaxT();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getMaxT : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getMaxT)

static bool js_cocos2dx_Texture2D_setAlphaTexture(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setAlphaTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_setAlphaTexture : Error processing arguments");
        cobj->setAlphaTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setAlphaTexture)

static bool js_cocos2dx_Texture2D_getStringForFormat(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getStringForFormat : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const char* result = cobj->getStringForFormat();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getStringForFormat : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getStringForFormat)

static bool js_cocos2dx_Texture2D_initWithImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Texture2D_initWithImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Image* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D::PixelFormat arg1;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithImage(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithImage : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Image* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithImage(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithImage : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_initWithImage)

static bool js_cocos2dx_Texture2D_setGLProgram(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgram* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_setGLProgram : Error processing arguments");
        cobj->setGLProgram(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setGLProgram)

static bool js_cocos2dx_Texture2D_getMaxS(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getMaxS : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getMaxS();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getMaxS : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getMaxS)

static bool js_cocos2dx_Texture2D_hasPremultipliedAlpha(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_hasPremultipliedAlpha : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasPremultipliedAlpha();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_hasPremultipliedAlpha : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_hasPremultipliedAlpha)

static bool js_cocos2dx_Texture2D_getPixelsHigh(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getPixelsHigh : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getPixelsHigh();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getPixelsHigh : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getPixelsHigh)

static bool js_cocos2dx_Texture2D_initWithMipmaps(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_initWithMipmaps : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 5) {
        cocos2d::_MipmapInfo* arg0 = nullptr;
        int arg1 = 0;
        cocos2d::Texture2D::PixelFormat arg2;
        int arg3 = 0;
        int arg4 = 0;
        #pragma warning NO CONVERSION TO NATIVE FOR _MipmapInfo*
		ok = false;
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        ok &= seval_to_int32(args[4], (int32_t *)&arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithMipmaps : Error processing arguments");
        bool result = cobj->initWithMipmaps(arg0, arg1, arg2, arg3, arg4);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithMipmaps : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_initWithMipmaps)

static bool js_cocos2dx_Texture2D_getAlphaTextureName(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getAlphaTextureName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getAlphaTextureName();
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getAlphaTextureName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getAlphaTextureName)

static bool js_cocos2dx_Texture2D_getBitsPerPixelForFormat(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Texture2D_getBitsPerPixelForFormat : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Texture2D::PixelFormat arg0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            unsigned int result = cobj->getBitsPerPixelForFormat(arg0);
            ok &= uint32_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getBitsPerPixelForFormat : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            unsigned int result = cobj->getBitsPerPixelForFormat();
            ok &= uint32_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getBitsPerPixelForFormat : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getBitsPerPixelForFormat)

static bool js_cocos2dx_Texture2D_getName(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getName();
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getName)

static bool js_cocos2dx_Texture2D_initWithString(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Texture2D_initWithString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            cocos2d::FontDefinition arg1;
            ok &= seval_to_FontDefinition(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int32(args[4], (int32_t *)&arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 6) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int32(args[4], (int32_t *)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg5;
            ok &= seval_to_int32(args[5], (int32_t *)&arg5);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 7) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int32(args[4], (int32_t *)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg5;
            ok &= seval_to_int32(args[5], (int32_t *)&arg5);
            if (!ok) { ok = true; break; }
            bool arg6;
            ok &= seval_to_boolean(args[6], &arg6);
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 8) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int32(args[4], (int32_t *)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg5;
            ok &= seval_to_int32(args[5], (int32_t *)&arg5);
            if (!ok) { ok = true; break; }
            bool arg6;
            ok &= seval_to_boolean(args[6], &arg6);
            int arg7 = 0;
            ok &= seval_to_int32(args[7], (int32_t *)&arg7);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_initWithString)

static bool js_cocos2dx_Texture2D_setMaxT(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setMaxT : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_setMaxT : Error processing arguments");
        cobj->setMaxT(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setMaxT)

static bool js_cocos2dx_Texture2D_getPath(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getPath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getPath();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getPath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getPath)

static bool js_cocos2dx_Texture2D_drawInRect(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_drawInRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_drawInRect : Error processing arguments");
        cobj->drawInRect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_drawInRect)

static bool js_cocos2dx_Texture2D_getContentSize(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getContentSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Size result = cobj->getContentSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getContentSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getContentSize)

static bool js_cocos2dx_Texture2D_setAliasTexParameters(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setAliasTexParameters : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setAliasTexParameters();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setAliasTexParameters)

static bool js_cocos2dx_Texture2D_setAntiAliasTexParameters(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setAntiAliasTexParameters : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setAntiAliasTexParameters();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setAntiAliasTexParameters)

static bool js_cocos2dx_Texture2D_generateMipmap(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_generateMipmap : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->generateMipmap();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_generateMipmap)

static bool js_cocos2dx_Texture2D_getAlphaTexture(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getAlphaTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getAlphaTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getAlphaTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getAlphaTexture)

static bool js_cocos2dx_Texture2D_getDescription(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getDescription : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getDescription();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getDescription : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getDescription)

static bool js_cocos2dx_Texture2D_getPixelFormat(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getPixelFormat : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getPixelFormat();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getPixelFormat : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getPixelFormat)

static bool js_cocos2dx_Texture2D_getContentSizeInPixels(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getContentSizeInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getContentSizeInPixels();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getContentSizeInPixels : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getContentSizeInPixels)

static bool js_cocos2dx_Texture2D_releaseGLTexture(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_releaseGLTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->releaseGLTexture();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_releaseGLTexture)

static bool js_cocos2dx_Texture2D_getPixelsWide(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getPixelsWide : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getPixelsWide();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getPixelsWide : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getPixelsWide)

static bool js_cocos2dx_Texture2D_drawAtPoint(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_drawAtPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_drawAtPoint : Error processing arguments");
        cobj->drawAtPoint(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_drawAtPoint)

static bool js_cocos2dx_Texture2D_hasMipmaps(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_hasMipmaps : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasMipmaps();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_hasMipmaps : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_hasMipmaps)

static bool js_cocos2dx_Texture2D_setMaxS(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setMaxS : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_setMaxS : Error processing arguments");
        cobj->setMaxS(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setMaxS)

static bool js_cocos2dx_Texture2D_setDefaultAlphaPixelFormat(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D::PixelFormat arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_setDefaultAlphaPixelFormat : Error processing arguments");
        cocos2d::Texture2D::setDefaultAlphaPixelFormat(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setDefaultAlphaPixelFormat)

static bool js_cocos2dx_Texture2D_getDefaultAlphaPixelFormat(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cocos2d::Texture2D::getDefaultAlphaPixelFormat();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getDefaultAlphaPixelFormat : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getDefaultAlphaPixelFormat)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Texture2D_finalize)

static bool js_cocos2dx_Texture2D_constructor(se::State& s)
{
    cocos2d::Texture2D* cobj = new (std::nothrow) cocos2d::Texture2D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Texture2D_constructor, __jsb_cocos2d_Texture2D_class, js_cocos2d_Texture2D_finalize)




bool js_cocos2d_Texture2D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Texture2D)", s.nativeThisObject());
        cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Texture2D_finalize)

bool js_register_cocos2dx_Texture2D(se::Object* obj)
{
    auto cls = se::Class::create("Texture2D", obj, nullptr, _SE(js_cocos2dx_Texture2D_constructor));

    cls->defineFunction("getShaderProgram", _SE(js_cocos2dx_Texture2D_getGLProgram));
    cls->defineFunction("getMaxT", _SE(js_cocos2dx_Texture2D_getMaxT));
    cls->defineFunction("setAlphaTexture", _SE(js_cocos2dx_Texture2D_setAlphaTexture));
    cls->defineFunction("getStringForFormat", _SE(js_cocos2dx_Texture2D_getStringForFormat));
    cls->defineFunction("initWithImage", _SE(js_cocos2dx_Texture2D_initWithImage));
    cls->defineFunction("setShaderProgram", _SE(js_cocos2dx_Texture2D_setGLProgram));
    cls->defineFunction("getMaxS", _SE(js_cocos2dx_Texture2D_getMaxS));
    cls->defineFunction("hasPremultipliedAlpha", _SE(js_cocos2dx_Texture2D_hasPremultipliedAlpha));
    cls->defineFunction("getPixelsHigh", _SE(js_cocos2dx_Texture2D_getPixelsHigh));
    cls->defineFunction("initWithMipmaps", _SE(js_cocos2dx_Texture2D_initWithMipmaps));
    cls->defineFunction("getAlphaTextureName", _SE(js_cocos2dx_Texture2D_getAlphaTextureName));
    cls->defineFunction("getBitsPerPixelForFormat", _SE(js_cocos2dx_Texture2D_getBitsPerPixelForFormat));
    cls->defineFunction("getName", _SE(js_cocos2dx_Texture2D_getName));
    cls->defineFunction("initWithString", _SE(js_cocos2dx_Texture2D_initWithString));
    cls->defineFunction("setMaxT", _SE(js_cocos2dx_Texture2D_setMaxT));
    cls->defineFunction("getPath", _SE(js_cocos2dx_Texture2D_getPath));
    cls->defineFunction("drawInRect", _SE(js_cocos2dx_Texture2D_drawInRect));
    cls->defineFunction("getContentSize", _SE(js_cocos2dx_Texture2D_getContentSize));
    cls->defineFunction("setAliasTexParameters", _SE(js_cocos2dx_Texture2D_setAliasTexParameters));
    cls->defineFunction("setAntiAliasTexParameters", _SE(js_cocos2dx_Texture2D_setAntiAliasTexParameters));
    cls->defineFunction("generateMipmap", _SE(js_cocos2dx_Texture2D_generateMipmap));
    cls->defineFunction("getAlphaTexture", _SE(js_cocos2dx_Texture2D_getAlphaTexture));
    cls->defineFunction("getDescription", _SE(js_cocos2dx_Texture2D_getDescription));
    cls->defineFunction("getPixelFormat", _SE(js_cocos2dx_Texture2D_getPixelFormat));
    cls->defineFunction("getContentSizeInPixels", _SE(js_cocos2dx_Texture2D_getContentSizeInPixels));
    cls->defineFunction("releaseTexture", _SE(js_cocos2dx_Texture2D_releaseGLTexture));
    cls->defineFunction("getPixelsWide", _SE(js_cocos2dx_Texture2D_getPixelsWide));
    cls->defineFunction("drawAtPoint", _SE(js_cocos2dx_Texture2D_drawAtPoint));
    cls->defineFunction("hasMipmaps", _SE(js_cocos2dx_Texture2D_hasMipmaps));
    cls->defineFunction("setMaxS", _SE(js_cocos2dx_Texture2D_setMaxS));
    cls->defineStaticFunction("setDefaultAlphaPixelFormat", _SE(js_cocos2dx_Texture2D_setDefaultAlphaPixelFormat));
    cls->defineStaticFunction("getDefaultAlphaPixelFormat", _SE(js_cocos2dx_Texture2D_getDefaultAlphaPixelFormat));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Texture2D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Texture2D>(cls);

    __jsb_cocos2d_Texture2D_proto = cls->getProto();
    __jsb_cocos2d_Texture2D_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Touch_proto = nullptr;
se::Class* __jsb_cocos2d_Touch_class = nullptr;

static bool js_cocos2dx_Touch_getPreviousLocationInView(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getPreviousLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getPreviousLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getPreviousLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getPreviousLocationInView)

static bool js_cocos2dx_Touch_getLocation(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getLocation)

static bool js_cocos2dx_Touch_getDelta(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getDelta : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getDelta();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getDelta : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getDelta)

static bool js_cocos2dx_Touch_getStartLocationInView(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getStartLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getStartLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getStartLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getStartLocationInView)

static bool js_cocos2dx_Touch_getCurrentForce(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getCurrentForce : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getCurrentForce();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getCurrentForce : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getCurrentForce)

static bool js_cocos2dx_Touch_getStartLocation(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getStartLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getStartLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getStartLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getStartLocation)

static bool js_cocos2dx_Touch_getID(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getID();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getID : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getID)

static bool js_cocos2dx_Touch_setTouchInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Touch_setTouchInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cobj->setTouchInfo(arg0, arg1, arg2, arg3, arg4);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->setTouchInfo(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_setTouchInfo)

static bool js_cocos2dx_Touch_getMaxForce(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getMaxForce : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getMaxForce();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getMaxForce : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getMaxForce)

static bool js_cocos2dx_Touch_getLocationInView(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getLocationInView)

static bool js_cocos2dx_Touch_getPreviousLocation(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getPreviousLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getPreviousLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getPreviousLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getPreviousLocation)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Touch_finalize)

static bool js_cocos2dx_Touch_constructor(se::State& s)
{
    cocos2d::Touch* cobj = new (std::nothrow) cocos2d::Touch();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Touch_constructor, __jsb_cocos2d_Touch_class, js_cocos2d_Touch_finalize)




bool js_cocos2d_Touch_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Touch)", s.nativeThisObject());
        cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Touch_finalize)

bool js_register_cocos2dx_Touch(se::Object* obj)
{
    auto cls = se::Class::create("Touch", obj, nullptr, _SE(js_cocos2dx_Touch_constructor));

    cls->defineFunction("getPreviousLocationInView", _SE(js_cocos2dx_Touch_getPreviousLocationInView));
    cls->defineFunction("getLocation", _SE(js_cocos2dx_Touch_getLocation));
    cls->defineFunction("getDelta", _SE(js_cocos2dx_Touch_getDelta));
    cls->defineFunction("getStartLocationInView", _SE(js_cocos2dx_Touch_getStartLocationInView));
    cls->defineFunction("getCurrentForce", _SE(js_cocos2dx_Touch_getCurrentForce));
    cls->defineFunction("getStartLocation", _SE(js_cocos2dx_Touch_getStartLocation));
    cls->defineFunction("getID", _SE(js_cocos2dx_Touch_getID));
    cls->defineFunction("setTouchInfo", _SE(js_cocos2dx_Touch_setTouchInfo));
    cls->defineFunction("getMaxForce", _SE(js_cocos2dx_Touch_getMaxForce));
    cls->defineFunction("getLocationInView", _SE(js_cocos2dx_Touch_getLocationInView));
    cls->defineFunction("getPreviousLocation", _SE(js_cocos2dx_Touch_getPreviousLocation));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Touch_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Touch>(cls);

    __jsb_cocos2d_Touch_proto = cls->getProto();
    __jsb_cocos2d_Touch_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Event_proto = nullptr;
se::Class* __jsb_cocos2d_Event_class = nullptr;

static bool js_cocos2dx_Event_isStopped(se::State& s)
{
    cocos2d::Event* cobj = (cocos2d::Event*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Event_isStopped : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isStopped();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Event_isStopped : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Event_isStopped)

static bool js_cocos2dx_Event_getType(se::State& s)
{
    cocos2d::Event* cobj = (cocos2d::Event*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Event_getType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getType();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Event_getType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Event_getType)

static bool js_cocos2dx_Event_getCurrentTarget(se::State& s)
{
    cocos2d::Event* cobj = (cocos2d::Event*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Event_getCurrentTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getCurrentTarget();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Event_getCurrentTarget : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Event_getCurrentTarget)

static bool js_cocos2dx_Event_stopPropagation(se::State& s)
{
    cocos2d::Event* cobj = (cocos2d::Event*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Event_stopPropagation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stopPropagation();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Event_stopPropagation)




bool js_register_cocos2dx_Event(se::Object* obj)
{
    auto cls = se::Class::create("Event", obj, nullptr, nullptr);

    cls->defineFunction("isStopped", _SE(js_cocos2dx_Event_isStopped));
    cls->defineFunction("getType", _SE(js_cocos2dx_Event_getType));
    cls->defineFunction("getCurrentTarget", _SE(js_cocos2dx_Event_getCurrentTarget));
    cls->defineFunction("stopPropagation", _SE(js_cocos2dx_Event_stopPropagation));
    cls->install();
    JSBClassType::registerClass<cocos2d::Event>(cls);

    __jsb_cocos2d_Event_proto = cls->getProto();
    __jsb_cocos2d_Event_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventTouch_proto = nullptr;
se::Class* __jsb_cocos2d_EventTouch_class = nullptr;

static bool js_cocos2dx_EventTouch_setEventCode(se::State& s)
{
    cocos2d::EventTouch* cobj = (cocos2d::EventTouch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventTouch_setEventCode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventTouch::EventCode arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventTouch_setEventCode : Error processing arguments");
        cobj->setEventCode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventTouch_setEventCode)

static bool js_cocos2dx_EventTouch_getEventCode(se::State& s)
{
    cocos2d::EventTouch* cobj = (cocos2d::EventTouch*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventTouch_getEventCode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getEventCode();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventTouch_getEventCode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventTouch_getEventCode)


extern se::Object* __jsb_cocos2d_Event_proto;


bool js_register_cocos2dx_EventTouch(se::Object* obj)
{
    auto cls = se::Class::create("EventTouch", obj, __jsb_cocos2d_Event_proto, nullptr);

    cls->defineFunction("setEventCode", _SE(js_cocos2dx_EventTouch_setEventCode));
    cls->defineFunction("getEventCode", _SE(js_cocos2dx_EventTouch_getEventCode));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventTouch>(cls);

    __jsb_cocos2d_EventTouch_proto = cls->getProto();
    __jsb_cocos2d_EventTouch_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ComponentContainer_proto = nullptr;
se::Class* __jsb_cocos2d_ComponentContainer_class = nullptr;

static bool js_cocos2dx_ComponentContainer_visit(se::State& s)
{
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ComponentContainer_visit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_visit : Error processing arguments");
        cobj->visit(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_visit)

static bool js_cocos2dx_ComponentContainer_remove(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_ComponentContainer_remove : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Component* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->remove(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_remove : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->remove(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_remove : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_remove)

static bool js_cocos2dx_ComponentContainer_removeAll(se::State& s)
{
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ComponentContainer_removeAll : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAll();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_removeAll)

static bool js_cocos2dx_ComponentContainer_add(se::State& s)
{
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ComponentContainer_add : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Component* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_add : Error processing arguments");
        bool result = cobj->add(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_add : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_add)

static bool js_cocos2dx_ComponentContainer_isEmpty(se::State& s)
{
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ComponentContainer_isEmpty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEmpty();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_isEmpty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_isEmpty)

static bool js_cocos2dx_ComponentContainer_get(se::State& s)
{
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ComponentContainer_get : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_get : Error processing arguments");
        cocos2d::Component* result = cobj->get(arg0);
        ok &= native_ptr_to_seval<cocos2d::Component>((cocos2d::Component*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_get : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_get)




bool js_register_cocos2dx_ComponentContainer(se::Object* obj)
{
    auto cls = se::Class::create("ComponentContainer", obj, nullptr, nullptr);

    cls->defineFunction("visit", _SE(js_cocos2dx_ComponentContainer_visit));
    cls->defineFunction("remove", _SE(js_cocos2dx_ComponentContainer_remove));
    cls->defineFunction("removeAll", _SE(js_cocos2dx_ComponentContainer_removeAll));
    cls->defineFunction("add", _SE(js_cocos2dx_ComponentContainer_add));
    cls->defineFunction("isEmpty", _SE(js_cocos2dx_ComponentContainer_isEmpty));
    cls->defineFunction("getComponent", _SE(js_cocos2dx_ComponentContainer_get));
    cls->install();
    JSBClassType::registerClass<cocos2d::ComponentContainer>(cls);

    __jsb_cocos2d_ComponentContainer_proto = cls->getProto();
    __jsb_cocos2d_ComponentContainer_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Component_proto = nullptr;
se::Class* __jsb_cocos2d_Component_class = nullptr;

static bool js_cocos2dx_Component_setEnabled(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Component_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Component_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_setEnabled)

static bool js_cocos2dx_Component_setName(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Component_setName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Component_setName : Error processing arguments");
        cobj->setName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_setName)

static bool js_cocos2dx_Component_isEnabled(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Component_isEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Component_isEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_isEnabled)

static bool js_cocos2dx_Component_getOwner(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Component_getOwner : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getOwner();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Component_getOwner : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_getOwner)

static bool js_cocos2dx_Component_init(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Component_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Component_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_init)

static bool js_cocos2dx_Component_setOwner(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Component_setOwner : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Component_setOwner : Error processing arguments");
        cobj->setOwner(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_setOwner)

static bool js_cocos2dx_Component_getName(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Component_getName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Component_getName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_getName)

static bool js_cocos2dx_Component_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Component::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Component_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Component_finalize)

static bool js_cocos2dx_Component_constructor(se::State& s)
{
    cocos2d::Component* cobj = new (std::nothrow) cocos2d::Component();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Component_constructor, __jsb_cocos2d_Component_class, js_cocos2d_Component_finalize)

static bool js_cocos2dx_Component_ctor(se::State& s)
{
    cocos2d::Component* cobj = new (std::nothrow) cocos2d::Component();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Component_ctor, __jsb_cocos2d_Component_class, js_cocos2d_Component_finalize)


    


bool js_cocos2d_Component_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Component)", s.nativeThisObject());
        cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Component_finalize)

bool js_register_cocos2dx_Component(se::Object* obj)
{
    auto cls = se::Class::create("Component", obj, nullptr, _SE(js_cocos2dx_Component_constructor));

    cls->defineFunction("setEnabled", _SE(js_cocos2dx_Component_setEnabled));
    cls->defineFunction("setName", _SE(js_cocos2dx_Component_setName));
    cls->defineFunction("isEnabled", _SE(js_cocos2dx_Component_isEnabled));
    cls->defineFunction("getOwner", _SE(js_cocos2dx_Component_getOwner));
    cls->defineFunction("init", _SE(js_cocos2dx_Component_init));
    cls->defineFunction("setOwner", _SE(js_cocos2dx_Component_setOwner));
    cls->defineFunction("getName", _SE(js_cocos2dx_Component_getName));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Component_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Component_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Component_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Component>(cls);

    __jsb_cocos2d_Component_proto = cls->getProto();
    __jsb_cocos2d_Component_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Component.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Node_proto = nullptr;
se::Class* __jsb_cocos2d_Node_class = nullptr;

static bool js_cocos2dx_Node_addChild(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_addChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            cobj->addChild(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->addChild(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            cobj->addChild(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->addChild(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_addChild)

static bool js_cocos2dx_Node_removeComponent(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_removeComponent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Component* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->removeComponent(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeComponent : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->removeComponent(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeComponent : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeComponent)

static bool js_cocos2dx_Node_setPhysicsBody(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setPhysicsBody : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::PhysicsBody* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setPhysicsBody : Error processing arguments");
        cobj->setPhysicsBody(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setPhysicsBody)

static bool js_cocos2dx_Node_getGLProgram(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLProgram* result = cobj->getGLProgram();
        ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getGLProgram : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getGLProgram)

static bool js_cocos2dx_Node_getDescription(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getDescription : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getDescription();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getDescription : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getDescription)

static bool js_cocos2dx_Node_setOpacityModifyRGB(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setOpacityModifyRGB : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setOpacityModifyRGB : Error processing arguments");
        cobj->setOpacityModifyRGB(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setOpacityModifyRGB)

static bool js_cocos2dx_Node_setCascadeOpacityEnabled(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setCascadeOpacityEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setCascadeOpacityEnabled : Error processing arguments");
        cobj->setCascadeOpacityEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setCascadeOpacityEnabled)

static bool js_cocos2dx_Node_getChildren(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::Vector<cocos2d::Node *>& result = cobj->getChildren();
            ok &= Vector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildren : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::Node *>& result = cobj->getChildren();
            ok &= Vector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildren : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getChildren)

static bool js_cocos2dx_Node_setOnExitCallback(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setOnExitCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void ()> arg0;
        do {
		    if (args[0].isObject() && args[0].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[0]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=]() -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(se::EmptyValueArray, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg0 = lambda;
		    }
		    else
		    {
		        arg0 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setOnExitCallback : Error processing arguments");
        cobj->setOnExitCallback(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setOnExitCallback)

static bool js_cocos2dx_Node_setActionManager(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setActionManager : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionManager* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setActionManager : Error processing arguments");
        cobj->setActionManager(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setActionManager)

static bool js_cocos2dx_Node_convertToWorldSpaceAR(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertToWorldSpaceAR : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToWorldSpaceAR : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToWorldSpaceAR(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToWorldSpaceAR : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertToWorldSpaceAR)

static bool js_cocos2dx_Node_isIgnoreAnchorPointForPosition(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isIgnoreAnchorPointForPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isIgnoreAnchorPointForPosition();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_isIgnoreAnchorPointForPosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isIgnoreAnchorPointForPosition)

static bool js_cocos2dx_Node_getChildByName(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getChildByName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildByName : Error processing arguments");
        cocos2d::Node* result = cobj->getChildByName(arg0);
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildByName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getChildByName)

static bool js_cocos2dx_Node_updateDisplayedOpacity(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_updateDisplayedOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        uint8_t arg0;
        ok &= seval_to_uint8(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_updateDisplayedOpacity : Error processing arguments");
        cobj->updateDisplayedOpacity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_updateDisplayedOpacity)

static bool js_cocos2dx_Node_init(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_init)

static bool js_cocos2dx_Node_getCameraMask(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getCameraMask : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned short result = cobj->getCameraMask();
        ok &= int16_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getCameraMask : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getCameraMask)

static bool js_cocos2dx_Node_setRotation(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setRotation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setRotation : Error processing arguments");
        cobj->setRotation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setRotation)

static bool js_cocos2dx_Node_setScaleZ(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setScaleZ : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setScaleZ : Error processing arguments");
        cobj->setScaleZ(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setScaleZ)

static bool js_cocos2dx_Node_setScaleY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setScaleY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setScaleY : Error processing arguments");
        cobj->setScaleY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setScaleY)

static bool js_cocos2dx_Node_setScaleX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setScaleX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setScaleX : Error processing arguments");
        cobj->setScaleX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setScaleX)

static bool js_cocos2dx_Node_getColor(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color3B& result = cobj->getColor();
        ok &= Color3B_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getColor)

static bool js_cocos2dx_Node_setonEnterTransitionDidFinishCallback(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setonEnterTransitionDidFinishCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void ()> arg0;
        do {
		    if (args[0].isObject() && args[0].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[0]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=]() -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(se::EmptyValueArray, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg0 = lambda;
		    }
		    else
		    {
		        arg0 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setonEnterTransitionDidFinishCallback : Error processing arguments");
        cobj->setonEnterTransitionDidFinishCallback(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setonEnterTransitionDidFinishCallback)

static bool js_cocos2dx_Node_removeAllComponents(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_removeAllComponents : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllComponents();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeAllComponents)

static bool js_cocos2dx_Node__setLocalZOrder(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node__setLocalZOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node__setLocalZOrder : Error processing arguments");
        cobj->_setLocalZOrder(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node__setLocalZOrder)

static bool js_cocos2dx_Node_setCameraMask(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setCameraMask : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned short arg0 = 0;
        ok &= seval_to_uint16(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setCameraMask : Error processing arguments");
        cobj->setCameraMask(arg0);
        return true;
    }
    if (argc == 2) {
        unsigned short arg0 = 0;
        bool arg1;
        ok &= seval_to_uint16(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setCameraMask : Error processing arguments");
        cobj->setCameraMask(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setCameraMask)

static bool js_cocos2dx_Node_getTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getTag();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getTag)

static bool js_cocos2dx_Node_getNodeToWorldAffineTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getNodeToWorldAffineTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::AffineTransform result = cobj->getNodeToWorldAffineTransform();
        ok &= AffineTransform_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToWorldAffineTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNodeToWorldAffineTransform)

static bool js_cocos2dx_Node_getPosition3D(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getPosition3D : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec3 result = cobj->getPosition3D();
        ok &= Vec3_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getPosition3D : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getPosition3D)

static bool js_cocos2dx_Node_removeChild(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_removeChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChild : Error processing arguments");
        cobj->removeChild(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        bool arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChild : Error processing arguments");
        cobj->removeChild(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeChild)

static bool js_cocos2dx_Node_convertToWorldSpace(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertToWorldSpace : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToWorldSpace : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToWorldSpace(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToWorldSpace : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertToWorldSpace)

static bool js_cocos2dx_Node_getScene(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Scene* result = cobj->getScene();
        ok &= native_ptr_to_seval<cocos2d::Scene>((cocos2d::Scene*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScene : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScene)

static bool js_cocos2dx_Node_getEventDispatcher(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getEventDispatcher : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::EventDispatcher* result = cobj->getEventDispatcher();
        ok &= native_ptr_to_seval<cocos2d::EventDispatcher>((cocos2d::EventDispatcher*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getEventDispatcher : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getEventDispatcher)

static bool js_cocos2dx_Node_setSkewX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setSkewX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setSkewX : Error processing arguments");
        cobj->setSkewX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setSkewX)

static bool js_cocos2dx_Node_setGLProgramState(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setGLProgramState : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgramState* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setGLProgramState : Error processing arguments");
        cobj->setGLProgramState(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setGLProgramState)

static bool js_cocos2dx_Node_setOnEnterCallback(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setOnEnterCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void ()> arg0;
        do {
		    if (args[0].isObject() && args[0].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[0]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=]() -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(se::EmptyValueArray, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg0 = lambda;
		    }
		    else
		    {
		        arg0 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setOnEnterCallback : Error processing arguments");
        cobj->setOnEnterCallback(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setOnEnterCallback)

static bool js_cocos2dx_Node_stopActionsByFlags(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_stopActionsByFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_stopActionsByFlags : Error processing arguments");
        cobj->stopActionsByFlags(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_stopActionsByFlags)

static bool js_cocos2dx_Node_setNormalizedPosition(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setNormalizedPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setNormalizedPosition : Error processing arguments");
        cobj->setNormalizedPosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setNormalizedPosition)

static bool js_cocos2dx_Node_setonExitTransitionDidStartCallback(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setonExitTransitionDidStartCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void ()> arg0;
        do {
		    if (args[0].isObject() && args[0].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[0]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=]() -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(se::EmptyValueArray, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg0 = lambda;
		    }
		    else
		    {
		        arg0 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setonExitTransitionDidStartCallback : Error processing arguments");
        cobj->setonExitTransitionDidStartCallback(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setonExitTransitionDidStartCallback)

static bool js_cocos2dx_Node_convertTouchToNodeSpace(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertTouchToNodeSpace : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Touch* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertTouchToNodeSpace : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertTouchToNodeSpace(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertTouchToNodeSpace : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertTouchToNodeSpace)

static bool js_cocos2dx_Node_removeAllChildrenWithCleanup(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_removeAllChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            bool arg0;
            ok &= seval_to_boolean(args[0], &arg0);
            cobj->removeAllChildrenWithCleanup(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cobj->removeAllChildren();
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeAllChildrenWithCleanup)

static bool js_cocos2dx_Node_getRotationSkewX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getRotationSkewX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRotationSkewX();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getRotationSkewX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getRotationSkewX)

static bool js_cocos2dx_Node_getRotationSkewY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getRotationSkewY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRotationSkewY();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getRotationSkewY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getRotationSkewY)

static bool js_cocos2dx_Node_getNodeToWorldTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getNodeToWorldTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Mat4 result = cobj->getNodeToWorldTransform();
        ok &= Mat4_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToWorldTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNodeToWorldTransform)

static bool js_cocos2dx_Node_isCascadeOpacityEnabled(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isCascadeOpacityEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isCascadeOpacityEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_isCascadeOpacityEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isCascadeOpacityEnabled)

static bool js_cocos2dx_Node_setParent(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setParent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setParent : Error processing arguments");
        cobj->setParent(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setParent)

static bool js_cocos2dx_Node_getName(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getName)

static bool js_cocos2dx_Node_resume(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_resume : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resume();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_resume)

static bool js_cocos2dx_Node_getRotation3D(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getRotation3D : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec3 result = cobj->getRotation3D();
        ok &= Vec3_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getRotation3D : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getRotation3D)

static bool js_cocos2dx_Node_getNodeToParentAffineTransform(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getNodeToParentAffineTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::AffineTransform result = cobj->getNodeToParentAffineTransform(arg0);
            ok &= AffineTransform_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToParentAffineTransform : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::AffineTransform result = cobj->getNodeToParentAffineTransform();
            ok &= AffineTransform_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToParentAffineTransform : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNodeToParentAffineTransform)

static bool js_cocos2dx_Node_convertTouchToNodeSpaceAR(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertTouchToNodeSpaceAR : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Touch* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertTouchToNodeSpaceAR : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertTouchToNodeSpaceAR(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertTouchToNodeSpaceAR : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertTouchToNodeSpaceAR)

static bool js_cocos2dx_Node_setPositionNormalized(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setPositionNormalized : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setPositionNormalized : Error processing arguments");
        cobj->setPositionNormalized(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setPositionNormalized)

static bool js_cocos2dx_Node_pause(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_pause : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->pause();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_pause)

static bool js_cocos2dx_Node_isOpacityModifyRGB(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isOpacityModifyRGB : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isOpacityModifyRGB();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_isOpacityModifyRGB : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isOpacityModifyRGB)

static bool js_cocos2dx_Node_stopActionByTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_stopActionByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_stopActionByTag : Error processing arguments");
        cobj->stopActionByTag(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_stopActionByTag)

static bool js_cocos2dx_Node_reorderChild(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_reorderChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_reorderChild : Error processing arguments");
        cobj->reorderChild(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_reorderChild)

static bool js_cocos2dx_Node_setSkewY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setSkewY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setSkewY : Error processing arguments");
        cobj->setSkewY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setSkewY)

static bool js_cocos2dx_Node_setColor(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setColor : Error processing arguments");
        cobj->setColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setColor)

static bool js_cocos2dx_Node_setRotation3D(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setRotation3D : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec3 arg0;
        ok &= seval_to_Vec3(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setRotation3D : Error processing arguments");
        cobj->setRotation3D(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setRotation3D)

static bool js_cocos2dx_Node_setPositionX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setPositionX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setPositionX : Error processing arguments");
        cobj->setPositionX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setPositionX)

static bool js_cocos2dx_Node_setNodeToParentTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setNodeToParentTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Mat4 arg0;
        ok &= seval_to_Mat4(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setNodeToParentTransform : Error processing arguments");
        cobj->setNodeToParentTransform(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setNodeToParentTransform)

static bool js_cocos2dx_Node_getAnchorPoint(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getAnchorPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getAnchorPoint();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getAnchorPoint : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getAnchorPoint)

static bool js_cocos2dx_Node_getNumberOfRunningActions(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getNumberOfRunningActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getNumberOfRunningActions();
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNumberOfRunningActions : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNumberOfRunningActions)

static bool js_cocos2dx_Node_updateTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_updateTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateTransform();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_updateTransform)

static bool js_cocos2dx_Node_isVisible(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isVisible : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isVisible();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_isVisible : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isVisible)

static bool js_cocos2dx_Node_getChildrenCount(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getChildrenCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getChildrenCount();
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildrenCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getChildrenCount)

static bool js_cocos2dx_Node_getNodeToParentTransform(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getNodeToParentTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 result = cobj->getNodeToParentTransform(arg0);
            ok &= Mat4_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToParentTransform : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Mat4& result = cobj->getNodeToParentTransform();
            ok &= Mat4_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToParentTransform : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNodeToParentTransform)

static bool js_cocos2dx_Node_convertToNodeSpaceAR(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertToNodeSpaceAR : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToNodeSpaceAR : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToNodeSpaceAR(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToNodeSpaceAR : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertToNodeSpaceAR)

static bool js_cocos2dx_Node_addComponent(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_addComponent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Component* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_addComponent : Error processing arguments");
        bool result = cobj->addComponent(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_addComponent : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_addComponent)

static bool js_cocos2dx_Node_runAction(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_runAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Action* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_runAction : Error processing arguments");
        cocos2d::Action* result = cobj->runAction(arg0);
        ok &= native_ptr_to_seval<cocos2d::Action>((cocos2d::Action*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_runAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_runAction)

static bool js_cocos2dx_Node_visit(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_visit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cobj->visit();
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Renderer* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 arg1;
            ok &= seval_to_Mat4(args[1], &arg1);
            if (!ok) { ok = true; break; }
            unsigned int arg2 = 0;
            ok &= seval_to_uint32(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->visit(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_visit)

static bool js_cocos2dx_Node_setGLProgram(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgram* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setGLProgram : Error processing arguments");
        cobj->setGLProgram(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setGLProgram)

static bool js_cocos2dx_Node_getRotation(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getRotation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRotation();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getRotation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getRotation)

static bool js_cocos2dx_Node_getAnchorPointInPoints(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getAnchorPointInPoints : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getAnchorPointInPoints();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getAnchorPointInPoints : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getAnchorPointInPoints)

static bool js_cocos2dx_Node_getRotationQuat(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getRotationQuat : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Quaternion result = cobj->getRotationQuat();
        ok &= Quaternion_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getRotationQuat : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getRotationQuat)

static bool js_cocos2dx_Node_removeChildByName(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_removeChildByName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChildByName : Error processing arguments");
        cobj->removeChildByName(arg0);
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        bool arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChildByName : Error processing arguments");
        cobj->removeChildByName(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeChildByName)

static bool js_cocos2dx_Node_setPositionZ(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setPositionZ : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setPositionZ : Error processing arguments");
        cobj->setPositionZ(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setPositionZ)

static bool js_cocos2dx_Node_getGLProgramState(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getGLProgramState : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLProgramState* result = cobj->getGLProgramState();
        ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getGLProgramState : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getGLProgramState)

static bool js_cocos2dx_Node_setScheduler(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setScheduler : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Scheduler* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setScheduler : Error processing arguments");
        cobj->setScheduler(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setScheduler)

static bool js_cocos2dx_Node_stopAllActions(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_stopAllActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stopAllActions();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_stopAllActions)

static bool js_cocos2dx_Node_getSkewX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getSkewX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSkewX();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getSkewX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getSkewX)

static bool js_cocos2dx_Node_getSkewY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getSkewY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSkewY();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getSkewY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getSkewY)

static bool js_cocos2dx_Node_getDisplayedColor(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getDisplayedColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color3B& result = cobj->getDisplayedColor();
        ok &= Color3B_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getDisplayedColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getDisplayedColor)

static bool js_cocos2dx_Node_getActionByTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getActionByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getActionByTag : Error processing arguments");
        cocos2d::Action* result = cobj->getActionByTag(arg0);
        ok &= native_ptr_to_seval<cocos2d::Action>((cocos2d::Action*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getActionByTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getActionByTag)

static bool js_cocos2dx_Node_setRotationSkewX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setRotationSkewX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setRotationSkewX : Error processing arguments");
        cobj->setRotationSkewX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setRotationSkewX)

static bool js_cocos2dx_Node_setRotationSkewY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setRotationSkewY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setRotationSkewY : Error processing arguments");
        cobj->setRotationSkewY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setRotationSkewY)

static bool js_cocos2dx_Node_setName(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setName : Error processing arguments");
        cobj->setName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setName)

static bool js_cocos2dx_Node_update(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_update : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_update : Error processing arguments");
        cobj->update(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_update)

static bool js_cocos2dx_Node_getDisplayedOpacity(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getDisplayedOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        uint8_t result = cobj->getDisplayedOpacity();
        ok &= uint8_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getDisplayedOpacity : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getDisplayedOpacity)

static bool js_cocos2dx_Node_getLocalZOrder(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getLocalZOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getLocalZOrder();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getLocalZOrder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getLocalZOrder)

static bool js_cocos2dx_Node_getScheduler(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getScheduler : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::Scheduler* result = cobj->getScheduler();
            ok &= native_ptr_to_seval<cocos2d::Scheduler>((cocos2d::Scheduler*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScheduler : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::Scheduler* result = cobj->getScheduler();
            ok &= native_ptr_to_seval<cocos2d::Scheduler>((cocos2d::Scheduler*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScheduler : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScheduler)

static bool js_cocos2dx_Node_getPositionNormalized(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getPositionNormalized : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getPositionNormalized();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getPositionNormalized : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getPositionNormalized)

static bool js_cocos2dx_Node_getPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float* arg0 = 0;
            #pragma warning NO CONVERSION TO NATIVE FOR float*
			ok = false;
            if (!ok) { ok = true; break; }
            float* arg1 = 0;
            #pragma warning NO CONVERSION TO NATIVE FOR float*
			ok = false;
            if (!ok) { ok = true; break; }
            cobj->getPosition(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Vec2& result = cobj->getPosition();
            ok &= Vec2_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getPosition : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getPosition)

static bool js_cocos2dx_Node_isRunning(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isRunning : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isRunning();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_isRunning : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isRunning)

static bool js_cocos2dx_Node_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getParent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::Node* result = cobj->getParent();
            ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getParent : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::Node* result = cobj->getParent();
            ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getParent : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getParent)

static bool js_cocos2dx_Node_getWorldToNodeTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getWorldToNodeTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Mat4 result = cobj->getWorldToNodeTransform();
        ok &= Mat4_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getWorldToNodeTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getWorldToNodeTransform)

static bool js_cocos2dx_Node_getPositionY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getPositionY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getPositionY();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getPositionY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getPositionY)

static bool js_cocos2dx_Node_getPositionX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getPositionX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getPositionX();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getPositionX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getPositionX)

static bool js_cocos2dx_Node_removeChildByTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_removeChildByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChildByTag : Error processing arguments");
        cobj->removeChildByTag(arg0);
        return true;
    }
    if (argc == 2) {
        int arg0 = 0;
        bool arg1;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChildByTag : Error processing arguments");
        cobj->removeChildByTag(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeChildByTag)

static bool js_cocos2dx_Node_setPositionY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setPositionY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setPositionY : Error processing arguments");
        cobj->setPositionY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setPositionY)

static bool js_cocos2dx_Node_updateDisplayedColor(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_updateDisplayedColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_updateDisplayedColor : Error processing arguments");
        cobj->updateDisplayedColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_updateDisplayedColor)

static bool js_cocos2dx_Node_setVisible(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setVisible : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setVisible : Error processing arguments");
        cobj->setVisible(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setVisible)

static bool js_cocos2dx_Node_getParentToNodeAffineTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getParentToNodeAffineTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::AffineTransform result = cobj->getParentToNodeAffineTransform();
        ok &= AffineTransform_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getParentToNodeAffineTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getParentToNodeAffineTransform)

static bool js_cocos2dx_Node_getPositionZ(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getPositionZ : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getPositionZ();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getPositionZ : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getPositionZ)

static bool js_cocos2dx_Node_setGlobalZOrder(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setGlobalZOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setGlobalZOrder : Error processing arguments");
        cobj->setGlobalZOrder(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setGlobalZOrder)

static bool js_cocos2dx_Node_setScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_setScale : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setScale(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setScale(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setScale)

static bool js_cocos2dx_Node_getChildByTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getChildByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildByTag : Error processing arguments");
        cocos2d::Node* result = cobj->getChildByTag(arg0);
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildByTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getChildByTag)

static bool js_cocos2dx_Node_getScaleZ(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getScaleZ : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScaleZ();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScaleZ : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScaleZ)

static bool js_cocos2dx_Node_getScaleY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getScaleY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScaleY();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScaleY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScaleY)

static bool js_cocos2dx_Node_getScaleX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getScaleX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScaleX();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScaleX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScaleX)

static bool js_cocos2dx_Node_setLocalZOrder(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setLocalZOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setLocalZOrder : Error processing arguments");
        cobj->setLocalZOrder(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setLocalZOrder)

static bool js_cocos2dx_Node_setCascadeColorEnabled(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setCascadeColorEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setCascadeColorEnabled : Error processing arguments");
        cobj->setCascadeColorEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setCascadeColorEnabled)

static bool js_cocos2dx_Node_setOpacity(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        uint8_t arg0;
        ok &= seval_to_uint8(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setOpacity : Error processing arguments");
        cobj->setOpacity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setOpacity)

static bool js_cocos2dx_Node_getComponent(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getComponent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getComponent : Error processing arguments");
        cocos2d::Component* result = cobj->getComponent(arg0);
        ok &= native_ptr_to_seval<cocos2d::Component>((cocos2d::Component*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getComponent : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getComponent)

static bool js_cocos2dx_Node_getContentSize(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getContentSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getContentSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getContentSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getContentSize)

static bool js_cocos2dx_Node_stopAllActionsByTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_stopAllActionsByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_stopAllActionsByTag : Error processing arguments");
        cobj->stopAllActionsByTag(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_stopAllActionsByTag)

static bool js_cocos2dx_Node_getBoundingBox(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getBoundingBox : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->getBoundingBox();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getBoundingBox : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getBoundingBox)

static bool js_cocos2dx_Node_setIgnoreAnchorPointForPosition(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setIgnoreAnchorPointForPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setIgnoreAnchorPointForPosition : Error processing arguments");
        cobj->setIgnoreAnchorPointForPosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setIgnoreAnchorPointForPosition)

static bool js_cocos2dx_Node_setEventDispatcher(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setEventDispatcher : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventDispatcher* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setEventDispatcher : Error processing arguments");
        cobj->setEventDispatcher(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setEventDispatcher)

static bool js_cocos2dx_Node_getGlobalZOrder(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getGlobalZOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getGlobalZOrder();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getGlobalZOrder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getGlobalZOrder)

static bool js_cocos2dx_Node_draw(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_draw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cobj->draw();
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Renderer* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 arg1;
            ok &= seval_to_Mat4(args[1], &arg1);
            if (!ok) { ok = true; break; }
            unsigned int arg2 = 0;
            ok &= seval_to_uint32(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->draw(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_draw)

static bool js_cocos2dx_Node_setUserObject(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setUserObject : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Ref* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setUserObject : Error processing arguments");
        cobj->setUserObject(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setUserObject)

static bool js_cocos2dx_Node_enumerateChildren(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_enumerateChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::function<bool (cocos2d::Node *)> arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        do {
		    if (args[1].isObject() && args[1].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[1]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](cocos2d::Node* larg0) -> bool {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(1);
		            ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)larg0, &args[0]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		            bool result;
		            ok &= seval_to_boolean(rval, &result);
		            JSB_PRECONDITION2(ok, result, "lambda function : Error processing return value with type bool");
		            return result;
		        };
		        arg1 = lambda;
		    }
		    else
		    {
		        arg1 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_enumerateChildren : Error processing arguments");
        cobj->enumerateChildren(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_enumerateChildren)

static bool js_cocos2dx_Node_removeFromParentAndCleanup(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_removeFromParentAndCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            bool arg0;
            ok &= seval_to_boolean(args[0], &arg0);
            cobj->removeFromParentAndCleanup(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cobj->removeFromParent();
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeFromParentAndCleanup)

static bool js_cocos2dx_Node_setPosition3D(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setPosition3D : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec3 arg0;
        ok &= seval_to_Vec3(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setPosition3D : Error processing arguments");
        cobj->setPosition3D(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setPosition3D)

static bool js_cocos2dx_Node_getNumberOfRunningActionsByTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getNumberOfRunningActionsByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNumberOfRunningActionsByTag : Error processing arguments");
        ssize_t result = cobj->getNumberOfRunningActionsByTag(arg0);
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNumberOfRunningActionsByTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNumberOfRunningActionsByTag)

static bool js_cocos2dx_Node_sortAllChildren(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_sortAllChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->sortAllChildren();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_sortAllChildren)

static bool js_cocos2dx_Node_getWorldToNodeAffineTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getWorldToNodeAffineTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::AffineTransform result = cobj->getWorldToNodeAffineTransform();
        ok &= AffineTransform_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getWorldToNodeAffineTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getWorldToNodeAffineTransform)

static bool js_cocos2dx_Node_getScale(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getScale : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScale();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScale : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScale)

static bool js_cocos2dx_Node_getOpacity(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        uint8_t result = cobj->getOpacity();
        ok &= uint8_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getOpacity : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getOpacity)

static bool js_cocos2dx_Node_updateOrderOfArrival(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_updateOrderOfArrival : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateOrderOfArrival();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_updateOrderOfArrival)

static bool js_cocos2dx_Node_getNormalizedPosition(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getNormalizedPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getNormalizedPosition();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNormalizedPosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNormalizedPosition)

static bool js_cocos2dx_Node_getParentToNodeTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getParentToNodeTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Mat4& result = cobj->getParentToNodeTransform();
        ok &= Mat4_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getParentToNodeTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getParentToNodeTransform)

static bool js_cocos2dx_Node_convertToNodeSpace(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertToNodeSpace : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToNodeSpace : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToNodeSpace(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToNodeSpace : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertToNodeSpace)

static bool js_cocos2dx_Node_setTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setTag : Error processing arguments");
        cobj->setTag(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setTag)

static bool js_cocos2dx_Node_isCascadeColorEnabled(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isCascadeColorEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isCascadeColorEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_isCascadeColorEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isCascadeColorEnabled)

static bool js_cocos2dx_Node_setRotationQuat(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setRotationQuat : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Quaternion arg0;
        ok &= seval_to_Quaternion(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_setRotationQuat : Error processing arguments");
        cobj->setRotationQuat(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setRotationQuat)

static bool js_cocos2dx_Node_stopAction(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Node_stopAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Action* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_stopAction : Error processing arguments");
        cobj->stopAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_stopAction)

static bool js_cocos2dx_Node_getActionManager(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getActionManager : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::ActionManager* result = cobj->getActionManager();
            ok &= native_ptr_to_seval<cocos2d::ActionManager>((cocos2d::ActionManager*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getActionManager : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::ActionManager* result = cobj->getActionManager();
            ok &= native_ptr_to_seval<cocos2d::ActionManager>((cocos2d::ActionManager*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Node_getActionManager : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getActionManager)

static bool js_cocos2dx_Node_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Node::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Node_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Node_finalize)

static bool js_cocos2dx_Node_constructor(se::State& s)
{
    cocos2d::Node* cobj = new (std::nothrow) cocos2d::Node();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Node_constructor, __jsb_cocos2d_Node_class, js_cocos2d_Node_finalize)

static bool js_cocos2dx_Node_ctor(se::State& s)
{
    cocos2d::Node* cobj = new (std::nothrow) cocos2d::Node();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Node_ctor, __jsb_cocos2d_Node_class, js_cocos2d_Node_finalize)


    


bool js_cocos2d_Node_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Node)", s.nativeThisObject());
        cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Node_finalize)

bool js_register_cocos2dx_Node(se::Object* obj)
{
    auto cls = se::Class::create("Node", obj, nullptr, _SE(js_cocos2dx_Node_constructor));

    cls->defineFunction("addChild", _SE(js_cocos2dx_Node_addChild));
    cls->defineFunction("removeComponent", _SE(js_cocos2dx_Node_removeComponent));
    cls->defineFunction("setPhysicsBody", _SE(js_cocos2dx_Node_setPhysicsBody));
    cls->defineFunction("getShaderProgram", _SE(js_cocos2dx_Node_getGLProgram));
    cls->defineFunction("getDescription", _SE(js_cocos2dx_Node_getDescription));
    cls->defineFunction("setOpacityModifyRGB", _SE(js_cocos2dx_Node_setOpacityModifyRGB));
    cls->defineFunction("setCascadeOpacityEnabled", _SE(js_cocos2dx_Node_setCascadeOpacityEnabled));
    cls->defineFunction("getChildren", _SE(js_cocos2dx_Node_getChildren));
    cls->defineFunction("setOnExitCallback", _SE(js_cocos2dx_Node_setOnExitCallback));
    cls->defineFunction("setActionManager", _SE(js_cocos2dx_Node_setActionManager));
    cls->defineFunction("convertToWorldSpaceAR", _SE(js_cocos2dx_Node_convertToWorldSpaceAR));
    cls->defineFunction("isIgnoreAnchorPointForPosition", _SE(js_cocos2dx_Node_isIgnoreAnchorPointForPosition));
    cls->defineFunction("getChildByName", _SE(js_cocos2dx_Node_getChildByName));
    cls->defineFunction("updateDisplayedOpacity", _SE(js_cocos2dx_Node_updateDisplayedOpacity));
    cls->defineFunction("init", _SE(js_cocos2dx_Node_init));
    cls->defineFunction("getCameraMask", _SE(js_cocos2dx_Node_getCameraMask));
    cls->defineFunction("setRotation", _SE(js_cocos2dx_Node_setRotation));
    cls->defineFunction("setScaleZ", _SE(js_cocos2dx_Node_setScaleZ));
    cls->defineFunction("setScaleY", _SE(js_cocos2dx_Node_setScaleY));
    cls->defineFunction("setScaleX", _SE(js_cocos2dx_Node_setScaleX));
    cls->defineFunction("getColor", _SE(js_cocos2dx_Node_getColor));
    cls->defineFunction("setonEnterTransitionDidFinishCallback", _SE(js_cocos2dx_Node_setonEnterTransitionDidFinishCallback));
    cls->defineFunction("removeAllComponents", _SE(js_cocos2dx_Node_removeAllComponents));
    cls->defineFunction("_setLocalZOrder", _SE(js_cocos2dx_Node__setLocalZOrder));
    cls->defineFunction("setCameraMask", _SE(js_cocos2dx_Node_setCameraMask));
    cls->defineFunction("getTag", _SE(js_cocos2dx_Node_getTag));
    cls->defineFunction("getNodeToWorldTransform", _SE(js_cocos2dx_Node_getNodeToWorldAffineTransform));
    cls->defineFunction("getPosition3D", _SE(js_cocos2dx_Node_getPosition3D));
    cls->defineFunction("removeChild", _SE(js_cocos2dx_Node_removeChild));
    cls->defineFunction("convertToWorldSpace", _SE(js_cocos2dx_Node_convertToWorldSpace));
    cls->defineFunction("getScene", _SE(js_cocos2dx_Node_getScene));
    cls->defineFunction("getEventDispatcher", _SE(js_cocos2dx_Node_getEventDispatcher));
    cls->defineFunction("setSkewX", _SE(js_cocos2dx_Node_setSkewX));
    cls->defineFunction("setGLProgramState", _SE(js_cocos2dx_Node_setGLProgramState));
    cls->defineFunction("setOnEnterCallback", _SE(js_cocos2dx_Node_setOnEnterCallback));
    cls->defineFunction("stopActionsByFlags", _SE(js_cocos2dx_Node_stopActionsByFlags));
    cls->defineFunction("setNormalizedPosition", _SE(js_cocos2dx_Node_setNormalizedPosition));
    cls->defineFunction("setonExitTransitionDidStartCallback", _SE(js_cocos2dx_Node_setonExitTransitionDidStartCallback));
    cls->defineFunction("convertTouchToNodeSpace", _SE(js_cocos2dx_Node_convertTouchToNodeSpace));
    cls->defineFunction("removeAllChildren", _SE(js_cocos2dx_Node_removeAllChildrenWithCleanup));
    cls->defineFunction("getRotationX", _SE(js_cocos2dx_Node_getRotationSkewX));
    cls->defineFunction("getRotationY", _SE(js_cocos2dx_Node_getRotationSkewY));
    cls->defineFunction("getNodeToWorldTransform3D", _SE(js_cocos2dx_Node_getNodeToWorldTransform));
    cls->defineFunction("isCascadeOpacityEnabled", _SE(js_cocos2dx_Node_isCascadeOpacityEnabled));
    cls->defineFunction("setParent", _SE(js_cocos2dx_Node_setParent));
    cls->defineFunction("getName", _SE(js_cocos2dx_Node_getName));
    cls->defineFunction("resume", _SE(js_cocos2dx_Node_resume));
    cls->defineFunction("getRotation3D", _SE(js_cocos2dx_Node_getRotation3D));
    cls->defineFunction("getNodeToParentTransform", _SE(js_cocos2dx_Node_getNodeToParentAffineTransform));
    cls->defineFunction("convertTouchToNodeSpaceAR", _SE(js_cocos2dx_Node_convertTouchToNodeSpaceAR));
    cls->defineFunction("setPositionNormalized", _SE(js_cocos2dx_Node_setPositionNormalized));
    cls->defineFunction("pause", _SE(js_cocos2dx_Node_pause));
    cls->defineFunction("isOpacityModifyRGB", _SE(js_cocos2dx_Node_isOpacityModifyRGB));
    cls->defineFunction("stopActionByTag", _SE(js_cocos2dx_Node_stopActionByTag));
    cls->defineFunction("reorderChild", _SE(js_cocos2dx_Node_reorderChild));
    cls->defineFunction("setSkewY", _SE(js_cocos2dx_Node_setSkewY));
    cls->defineFunction("setColor", _SE(js_cocos2dx_Node_setColor));
    cls->defineFunction("setRotation3D", _SE(js_cocos2dx_Node_setRotation3D));
    cls->defineFunction("setPositionX", _SE(js_cocos2dx_Node_setPositionX));
    cls->defineFunction("setNodeToParentTransform", _SE(js_cocos2dx_Node_setNodeToParentTransform));
    cls->defineFunction("getAnchorPoint", _SE(js_cocos2dx_Node_getAnchorPoint));
    cls->defineFunction("getNumberOfRunningActions", _SE(js_cocos2dx_Node_getNumberOfRunningActions));
    cls->defineFunction("updateTransform", _SE(js_cocos2dx_Node_updateTransform));
    cls->defineFunction("isVisible", _SE(js_cocos2dx_Node_isVisible));
    cls->defineFunction("getChildrenCount", _SE(js_cocos2dx_Node_getChildrenCount));
    cls->defineFunction("getNodeToParentTransform3D", _SE(js_cocos2dx_Node_getNodeToParentTransform));
    cls->defineFunction("convertToNodeSpaceAR", _SE(js_cocos2dx_Node_convertToNodeSpaceAR));
    cls->defineFunction("addComponent", _SE(js_cocos2dx_Node_addComponent));
    cls->defineFunction("runAction", _SE(js_cocos2dx_Node_runAction));
    cls->defineFunction("visit", _SE(js_cocos2dx_Node_visit));
    cls->defineFunction("setShaderProgram", _SE(js_cocos2dx_Node_setGLProgram));
    cls->defineFunction("getRotation", _SE(js_cocos2dx_Node_getRotation));
    cls->defineFunction("getAnchorPointInPoints", _SE(js_cocos2dx_Node_getAnchorPointInPoints));
    cls->defineFunction("getRotationQuat", _SE(js_cocos2dx_Node_getRotationQuat));
    cls->defineFunction("removeChildByName", _SE(js_cocos2dx_Node_removeChildByName));
    cls->defineFunction("setVertexZ", _SE(js_cocos2dx_Node_setPositionZ));
    cls->defineFunction("getGLProgramState", _SE(js_cocos2dx_Node_getGLProgramState));
    cls->defineFunction("setScheduler", _SE(js_cocos2dx_Node_setScheduler));
    cls->defineFunction("stopAllActions", _SE(js_cocos2dx_Node_stopAllActions));
    cls->defineFunction("getSkewX", _SE(js_cocos2dx_Node_getSkewX));
    cls->defineFunction("getSkewY", _SE(js_cocos2dx_Node_getSkewY));
    cls->defineFunction("getDisplayedColor", _SE(js_cocos2dx_Node_getDisplayedColor));
    cls->defineFunction("getActionByTag", _SE(js_cocos2dx_Node_getActionByTag));
    cls->defineFunction("setRotationX", _SE(js_cocos2dx_Node_setRotationSkewX));
    cls->defineFunction("setRotationY", _SE(js_cocos2dx_Node_setRotationSkewY));
    cls->defineFunction("setName", _SE(js_cocos2dx_Node_setName));
    cls->defineFunction("update", _SE(js_cocos2dx_Node_update));
    cls->defineFunction("getDisplayedOpacity", _SE(js_cocos2dx_Node_getDisplayedOpacity));
    cls->defineFunction("getLocalZOrder", _SE(js_cocos2dx_Node_getLocalZOrder));
    cls->defineFunction("getScheduler", _SE(js_cocos2dx_Node_getScheduler));
    cls->defineFunction("getPositionNormalized", _SE(js_cocos2dx_Node_getPositionNormalized));
    cls->defineFunction("getPosition", _SE(js_cocos2dx_Node_getPosition));
    cls->defineFunction("isRunning", _SE(js_cocos2dx_Node_isRunning));
    cls->defineFunction("getParent", _SE(js_cocos2dx_Node_getParent));
    cls->defineFunction("getWorldToNodeTransform3D", _SE(js_cocos2dx_Node_getWorldToNodeTransform));
    cls->defineFunction("getPositionY", _SE(js_cocos2dx_Node_getPositionY));
    cls->defineFunction("getPositionX", _SE(js_cocos2dx_Node_getPositionX));
    cls->defineFunction("removeChildByTag", _SE(js_cocos2dx_Node_removeChildByTag));
    cls->defineFunction("setPositionY", _SE(js_cocos2dx_Node_setPositionY));
    cls->defineFunction("updateDisplayedColor", _SE(js_cocos2dx_Node_updateDisplayedColor));
    cls->defineFunction("setVisible", _SE(js_cocos2dx_Node_setVisible));
    cls->defineFunction("getParentToNodeTransform", _SE(js_cocos2dx_Node_getParentToNodeAffineTransform));
    cls->defineFunction("getVertexZ", _SE(js_cocos2dx_Node_getPositionZ));
    cls->defineFunction("setGlobalZOrder", _SE(js_cocos2dx_Node_setGlobalZOrder));
    cls->defineFunction("setScale", _SE(js_cocos2dx_Node_setScale));
    cls->defineFunction("getChildByTag", _SE(js_cocos2dx_Node_getChildByTag));
    cls->defineFunction("getScaleZ", _SE(js_cocos2dx_Node_getScaleZ));
    cls->defineFunction("getScaleY", _SE(js_cocos2dx_Node_getScaleY));
    cls->defineFunction("getScaleX", _SE(js_cocos2dx_Node_getScaleX));
    cls->defineFunction("setLocalZOrder", _SE(js_cocos2dx_Node_setLocalZOrder));
    cls->defineFunction("setCascadeColorEnabled", _SE(js_cocos2dx_Node_setCascadeColorEnabled));
    cls->defineFunction("setOpacity", _SE(js_cocos2dx_Node_setOpacity));
    cls->defineFunction("getComponent", _SE(js_cocos2dx_Node_getComponent));
    cls->defineFunction("getContentSize", _SE(js_cocos2dx_Node_getContentSize));
    cls->defineFunction("stopAllActionsByTag", _SE(js_cocos2dx_Node_stopAllActionsByTag));
    cls->defineFunction("getBoundingBox", _SE(js_cocos2dx_Node_getBoundingBox));
    cls->defineFunction("setIgnoreAnchorPointForPosition", _SE(js_cocos2dx_Node_setIgnoreAnchorPointForPosition));
    cls->defineFunction("setEventDispatcher", _SE(js_cocos2dx_Node_setEventDispatcher));
    cls->defineFunction("getGlobalZOrder", _SE(js_cocos2dx_Node_getGlobalZOrder));
    cls->defineFunction("draw", _SE(js_cocos2dx_Node_draw));
    cls->defineFunction("setUserObject", _SE(js_cocos2dx_Node_setUserObject));
    cls->defineFunction("enumerateChildren", _SE(js_cocos2dx_Node_enumerateChildren));
    cls->defineFunction("removeFromParent", _SE(js_cocos2dx_Node_removeFromParentAndCleanup));
    cls->defineFunction("setPosition3D", _SE(js_cocos2dx_Node_setPosition3D));
    cls->defineFunction("getNumberOfRunningActionsByTag", _SE(js_cocos2dx_Node_getNumberOfRunningActionsByTag));
    cls->defineFunction("sortAllChildren", _SE(js_cocos2dx_Node_sortAllChildren));
    cls->defineFunction("getWorldToNodeTransform", _SE(js_cocos2dx_Node_getWorldToNodeAffineTransform));
    cls->defineFunction("getScale", _SE(js_cocos2dx_Node_getScale));
    cls->defineFunction("getOpacity", _SE(js_cocos2dx_Node_getOpacity));
    cls->defineFunction("updateOrderOfArrival", _SE(js_cocos2dx_Node_updateOrderOfArrival));
    cls->defineFunction("getNormalizedPosition", _SE(js_cocos2dx_Node_getNormalizedPosition));
    cls->defineFunction("getParentToNodeTransform3D", _SE(js_cocos2dx_Node_getParentToNodeTransform));
    cls->defineFunction("convertToNodeSpace", _SE(js_cocos2dx_Node_convertToNodeSpace));
    cls->defineFunction("setTag", _SE(js_cocos2dx_Node_setTag));
    cls->defineFunction("isCascadeColorEnabled", _SE(js_cocos2dx_Node_isCascadeColorEnabled));
    cls->defineFunction("setRotationQuat", _SE(js_cocos2dx_Node_setRotationQuat));
    cls->defineFunction("stopAction", _SE(js_cocos2dx_Node_stopAction));
    cls->defineFunction("getActionManager", _SE(js_cocos2dx_Node_getActionManager));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Node_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Node_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Node_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Node>(cls);

    __jsb_cocos2d_Node_proto = cls->getProto();
    __jsb_cocos2d_Node_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Node.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d___NodeRGBA_proto = nullptr;
se::Class* __jsb_cocos2d___NodeRGBA_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d___NodeRGBA_finalize)

static bool js_cocos2dx___NodeRGBA_constructor(se::State& s)
{
    cocos2d::__NodeRGBA* cobj = new (std::nothrow) cocos2d::__NodeRGBA();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx___NodeRGBA_constructor, __jsb_cocos2d___NodeRGBA_class, js_cocos2d___NodeRGBA_finalize)



extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d___NodeRGBA_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::__NodeRGBA)", s.nativeThisObject());
        cocos2d::__NodeRGBA* cobj = (cocos2d::__NodeRGBA*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d___NodeRGBA_finalize)

bool js_register_cocos2dx___NodeRGBA(se::Object* obj)
{
    auto cls = se::Class::create("__NodeRGBA", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx___NodeRGBA_constructor));

    cls->defineFinalizedFunction(_SE(js_cocos2d___NodeRGBA_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::__NodeRGBA>(cls);

    __jsb_cocos2d___NodeRGBA_proto = cls->getProto();
    __jsb_cocos2d___NodeRGBA_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Scene_proto = nullptr;
se::Class* __jsb_cocos2d_Scene_class = nullptr;

static bool js_cocos2dx_Scene_setCameraOrderDirty(se::State& s)
{
    cocos2d::Scene* cobj = (cocos2d::Scene*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scene_setCameraOrderDirty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setCameraOrderDirty();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_setCameraOrderDirty)

static bool js_cocos2dx_Scene_render(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Scene* cobj = (cocos2d::Scene*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Scene_render : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 4) {
            cocos2d::Renderer* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            const cocos2d::Mat4* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const cocos2d::Mat4* arg2 = nullptr;
            ok &= seval_to_native_ptr(args[2], &arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cobj->render(arg0, arg1, arg2, arg3);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            cocos2d::Renderer* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 arg1;
            ok &= seval_to_Mat4(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->render(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Renderer* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 arg1;
            ok &= seval_to_Mat4(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const cocos2d::Mat4* arg2 = nullptr;
            ok &= seval_to_native_ptr(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->render(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_render)

static bool js_cocos2dx_Scene_stepPhysicsAndNavigation(se::State& s)
{
    cocos2d::Scene* cobj = (cocos2d::Scene*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scene_stepPhysicsAndNavigation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scene_stepPhysicsAndNavigation : Error processing arguments");
        cobj->stepPhysicsAndNavigation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_stepPhysicsAndNavigation)

static bool js_cocos2dx_Scene_onProjectionChanged(se::State& s)
{
    cocos2d::Scene* cobj = (cocos2d::Scene*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scene_onProjectionChanged : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventCustom* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scene_onProjectionChanged : Error processing arguments");
        cobj->onProjectionChanged(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_onProjectionChanged)

static bool js_cocos2dx_Scene_initWithSize(se::State& s)
{
    cocos2d::Scene* cobj = (cocos2d::Scene*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scene_initWithSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scene_initWithSize : Error processing arguments");
        bool result = cobj->initWithSize(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scene_initWithSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_initWithSize)

static bool js_cocos2dx_Scene_getDefaultCamera(se::State& s)
{
    cocos2d::Scene* cobj = (cocos2d::Scene*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scene_getDefaultCamera : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Camera* result = cobj->getDefaultCamera();
        ok &= native_ptr_to_seval<cocos2d::Camera>((cocos2d::Camera*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scene_getDefaultCamera : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_getDefaultCamera)

static bool js_cocos2dx_Scene_createWithSize(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scene_createWithSize : Error processing arguments");
        auto result = cocos2d::Scene::createWithSize(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Scene_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_createWithSize)

static bool js_cocos2dx_Scene_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Scene::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Scene_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Scene_finalize)

static bool js_cocos2dx_Scene_constructor(se::State& s)
{
    cocos2d::Scene* cobj = new (std::nothrow) cocos2d::Scene();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Scene_constructor, __jsb_cocos2d_Scene_class, js_cocos2d_Scene_finalize)

static bool js_cocos2dx_Scene_ctor(se::State& s)
{
    cocos2d::Scene* cobj = new (std::nothrow) cocos2d::Scene();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Scene_ctor, __jsb_cocos2d_Scene_class, js_cocos2d_Scene_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_Scene_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Scene)", s.nativeThisObject());
        cocos2d::Scene* cobj = (cocos2d::Scene*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Scene_finalize)

bool js_register_cocos2dx_Scene(se::Object* obj)
{
    auto cls = se::Class::create("Scene", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_Scene_constructor));

    cls->defineFunction("setCameraOrderDirty", _SE(js_cocos2dx_Scene_setCameraOrderDirty));
    cls->defineFunction("render", _SE(js_cocos2dx_Scene_render));
    cls->defineFunction("stepPhysicsAndNavigation", _SE(js_cocos2dx_Scene_stepPhysicsAndNavigation));
    cls->defineFunction("onProjectionChanged", _SE(js_cocos2dx_Scene_onProjectionChanged));
    cls->defineFunction("initWithSize", _SE(js_cocos2dx_Scene_initWithSize));
    cls->defineFunction("getDefaultCamera", _SE(js_cocos2dx_Scene_getDefaultCamera));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Scene_ctor));
    cls->defineStaticFunction("createWithSize", _SE(js_cocos2dx_Scene_createWithSize));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Scene_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Scene_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Scene>(cls);

    __jsb_cocos2d_Scene_proto = cls->getProto();
    __jsb_cocos2d_Scene_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Scene.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_GLView_proto = nullptr;
se::Class* __jsb_cocos2d_GLView_class = nullptr;

static bool js_cocos2dx_GLView_setFrameSize(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setFrameSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setFrameSize : Error processing arguments");
        cobj->setFrameSize(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setFrameSize)

static bool js_cocos2dx_GLView_getViewPortRect(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getViewPortRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Rect& result = cobj->getViewPortRect();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getViewPortRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getViewPortRect)

static bool js_cocos2dx_GLView_setContentScaleFactor(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setContentScaleFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setContentScaleFactor : Error processing arguments");
        bool result = cobj->setContentScaleFactor(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setContentScaleFactor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setContentScaleFactor)

static bool js_cocos2dx_GLView_getContentScaleFactor(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getContentScaleFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getContentScaleFactor();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getContentScaleFactor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getContentScaleFactor)

static bool js_cocos2dx_GLView_setIMEKeyboardState(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setIMEKeyboardState : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setIMEKeyboardState : Error processing arguments");
        cobj->setIMEKeyboardState(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setIMEKeyboardState)

static bool js_cocos2dx_GLView_setScissorInPoints(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setScissorInPoints : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setScissorInPoints : Error processing arguments");
        cobj->setScissorInPoints(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setScissorInPoints)

static bool js_cocos2dx_GLView_getViewName(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getViewName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getViewName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getViewName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getViewName)

static bool js_cocos2dx_GLView_isOpenGLReady(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_isOpenGLReady : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isOpenGLReady();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_isOpenGLReady : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_isOpenGLReady)

static bool js_cocos2dx_GLView_setCursorVisible(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setCursorVisible : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setCursorVisible : Error processing arguments");
        cobj->setCursorVisible(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setCursorVisible)

static bool js_cocos2dx_GLView_getScaleY(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getScaleY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScaleY();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getScaleY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getScaleY)

static bool js_cocos2dx_GLView_getScaleX(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getScaleX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScaleX();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getScaleX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getScaleX)

static bool js_cocos2dx_GLView_getVisibleOrigin(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getVisibleOrigin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getVisibleOrigin();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getVisibleOrigin : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getVisibleOrigin)

static bool js_cocos2dx_GLView_getFrameSize(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getFrameSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getFrameSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getFrameSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getFrameSize)

static bool js_cocos2dx_GLView_setFrameZoomFactor(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setFrameZoomFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setFrameZoomFactor : Error processing arguments");
        cobj->setFrameZoomFactor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setFrameZoomFactor)

static bool js_cocos2dx_GLView_getFrameZoomFactor(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getFrameZoomFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getFrameZoomFactor();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getFrameZoomFactor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getFrameZoomFactor)

static bool js_cocos2dx_GLView_getDesignResolutionSize(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getDesignResolutionSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getDesignResolutionSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getDesignResolutionSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getDesignResolutionSize)

static bool js_cocos2dx_GLView_windowShouldClose(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_windowShouldClose : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->windowShouldClose();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_windowShouldClose : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_windowShouldClose)

static bool js_cocos2dx_GLView_setDesignResolutionSize(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setDesignResolutionSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        ResolutionPolicy arg2;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setDesignResolutionSize : Error processing arguments");
        cobj->setDesignResolutionSize(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setDesignResolutionSize)

static bool js_cocos2dx_GLView_getResolutionPolicy(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getResolutionPolicy : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getResolutionPolicy();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getResolutionPolicy : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getResolutionPolicy)

static bool js_cocos2dx_GLView_isRetinaDisplay(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_isRetinaDisplay : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isRetinaDisplay();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_isRetinaDisplay : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_isRetinaDisplay)

static bool js_cocos2dx_GLView_renderScene(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_renderScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Scene* arg0 = nullptr;
        cocos2d::Renderer* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_renderScene : Error processing arguments");
        cobj->renderScene(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_renderScene)

static bool js_cocos2dx_GLView_setVR(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setVR : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::VRIRenderer* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setVR : Error processing arguments");
        cobj->setVR(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setVR)

static bool js_cocos2dx_GLView_setViewPortInPoints(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setViewPortInPoints : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setViewPortInPoints : Error processing arguments");
        cobj->setViewPortInPoints(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setViewPortInPoints)

static bool js_cocos2dx_GLView_getScissorRect(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getScissorRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->getScissorRect();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getScissorRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getScissorRect)

static bool js_cocos2dx_GLView_getRetinaFactor(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getRetinaFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getRetinaFactor();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getRetinaFactor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getRetinaFactor)

static bool js_cocos2dx_GLView_setViewName(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setViewName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setViewName : Error processing arguments");
        cobj->setViewName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setViewName)

static bool js_cocos2dx_GLView_getVisibleRect(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getVisibleRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->getVisibleRect();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getVisibleRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getVisibleRect)

static bool js_cocos2dx_GLView_getVisibleSize(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getVisibleSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Size result = cobj->getVisibleSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getVisibleSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getVisibleSize)

static bool js_cocos2dx_GLView_isScissorEnabled(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_isScissorEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isScissorEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLView_isScissorEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_isScissorEnabled)

static bool js_cocos2dx_GLView_pollEvents(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_pollEvents : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->pollEvents();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_pollEvents)




bool js_register_cocos2dx_GLView(se::Object* obj)
{
    auto cls = se::Class::create("GLView", obj, nullptr, nullptr);

    cls->defineFunction("setFrameSize", _SE(js_cocos2dx_GLView_setFrameSize));
    cls->defineFunction("getViewPortRect", _SE(js_cocos2dx_GLView_getViewPortRect));
    cls->defineFunction("setContentScaleFactor", _SE(js_cocos2dx_GLView_setContentScaleFactor));
    cls->defineFunction("getContentScaleFactor", _SE(js_cocos2dx_GLView_getContentScaleFactor));
    cls->defineFunction("setIMEKeyboardState", _SE(js_cocos2dx_GLView_setIMEKeyboardState));
    cls->defineFunction("setScissorInPoints", _SE(js_cocos2dx_GLView_setScissorInPoints));
    cls->defineFunction("getViewName", _SE(js_cocos2dx_GLView_getViewName));
    cls->defineFunction("isOpenGLReady", _SE(js_cocos2dx_GLView_isOpenGLReady));
    cls->defineFunction("setCursorVisible", _SE(js_cocos2dx_GLView_setCursorVisible));
    cls->defineFunction("getScaleY", _SE(js_cocos2dx_GLView_getScaleY));
    cls->defineFunction("getScaleX", _SE(js_cocos2dx_GLView_getScaleX));
    cls->defineFunction("getVisibleOrigin", _SE(js_cocos2dx_GLView_getVisibleOrigin));
    cls->defineFunction("getFrameSize", _SE(js_cocos2dx_GLView_getFrameSize));
    cls->defineFunction("setFrameZoomFactor", _SE(js_cocos2dx_GLView_setFrameZoomFactor));
    cls->defineFunction("getFrameZoomFactor", _SE(js_cocos2dx_GLView_getFrameZoomFactor));
    cls->defineFunction("getDesignResolutionSize", _SE(js_cocos2dx_GLView_getDesignResolutionSize));
    cls->defineFunction("windowShouldClose", _SE(js_cocos2dx_GLView_windowShouldClose));
    cls->defineFunction("setDesignResolutionSize", _SE(js_cocos2dx_GLView_setDesignResolutionSize));
    cls->defineFunction("getResolutionPolicy", _SE(js_cocos2dx_GLView_getResolutionPolicy));
    cls->defineFunction("isRetinaDisplay", _SE(js_cocos2dx_GLView_isRetinaDisplay));
    cls->defineFunction("renderScene", _SE(js_cocos2dx_GLView_renderScene));
    cls->defineFunction("setVR", _SE(js_cocos2dx_GLView_setVR));
    cls->defineFunction("setViewPortInPoints", _SE(js_cocos2dx_GLView_setViewPortInPoints));
    cls->defineFunction("getScissorRect", _SE(js_cocos2dx_GLView_getScissorRect));
    cls->defineFunction("getRetinaFactor", _SE(js_cocos2dx_GLView_getRetinaFactor));
    cls->defineFunction("setViewName", _SE(js_cocos2dx_GLView_setViewName));
    cls->defineFunction("getVisibleRect", _SE(js_cocos2dx_GLView_getVisibleRect));
    cls->defineFunction("getVisibleSize", _SE(js_cocos2dx_GLView_getVisibleSize));
    cls->defineFunction("isScissorEnabled", _SE(js_cocos2dx_GLView_isScissorEnabled));
    cls->defineFunction("pollEvents", _SE(js_cocos2dx_GLView_pollEvents));
    cls->install();
    JSBClassType::registerClass<cocos2d::GLView>(cls);

    __jsb_cocos2d_GLView_proto = cls->getProto();
    __jsb_cocos2d_GLView_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Director_proto = nullptr;
se::Class* __jsb_cocos2d_Director_class = nullptr;

static bool js_cocos2dx_Director_pause(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_pause : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->pause();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_pause)

static bool js_cocos2dx_Director_pushProjectionMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_pushProjectionMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned long arg0 = 0;
        ok &= seval_to_ulong(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_pushProjectionMatrix : Error processing arguments");
        cobj->pushProjectionMatrix(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_pushProjectionMatrix)

static bool js_cocos2dx_Director_popProjectionMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_popProjectionMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned long arg0 = 0;
        ok &= seval_to_ulong(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_popProjectionMatrix : Error processing arguments");
        cobj->popProjectionMatrix(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_popProjectionMatrix)

static bool js_cocos2dx_Director_setEventDispatcher(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setEventDispatcher : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventDispatcher* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setEventDispatcher : Error processing arguments");
        cobj->setEventDispatcher(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setEventDispatcher)

static bool js_cocos2dx_Director_loadProjectionIdentityMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_loadProjectionIdentityMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned long arg0 = 0;
        ok &= seval_to_ulong(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_loadProjectionIdentityMatrix : Error processing arguments");
        cobj->loadProjectionIdentityMatrix(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_loadProjectionIdentityMatrix)

static bool js_cocos2dx_Director_setContentScaleFactor(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setContentScaleFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setContentScaleFactor : Error processing arguments");
        cobj->setContentScaleFactor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setContentScaleFactor)

static bool js_cocos2dx_Director_getContentScaleFactor(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getContentScaleFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getContentScaleFactor();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getContentScaleFactor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getContentScaleFactor)

static bool js_cocos2dx_Director_getWinSizeInPixels(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getWinSizeInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Size result = cobj->getWinSizeInPixels();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getWinSizeInPixels : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getWinSizeInPixels)

static bool js_cocos2dx_Director_getDeltaTime(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getDeltaTime : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getDeltaTime();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getDeltaTime : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getDeltaTime)

static bool js_cocos2dx_Director_setGLDefaultValues(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setGLDefaultValues : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setGLDefaultValues();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setGLDefaultValues)

static bool js_cocos2dx_Director_setActionManager(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setActionManager : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionManager* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setActionManager : Error processing arguments");
        cobj->setActionManager(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setActionManager)

static bool js_cocos2dx_Director_setAlphaBlending(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setAlphaBlending : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setAlphaBlending : Error processing arguments");
        cobj->setAlphaBlending(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setAlphaBlending)

static bool js_cocos2dx_Director_popToRootScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_popToRootScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->popToRootScene();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_popToRootScene)

static bool js_cocos2dx_Director_loadMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_loadMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::MATRIX_STACK_TYPE arg0;
        cocos2d::Mat4 arg1;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_Mat4(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_loadMatrix : Error processing arguments");
        cobj->loadMatrix(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_loadMatrix)

static bool js_cocos2dx_Director_getNotificationNode(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getNotificationNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getNotificationNode();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getNotificationNode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getNotificationNode)

static bool js_cocos2dx_Director_getWinSize(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getWinSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getWinSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getWinSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getWinSize)

static bool js_cocos2dx_Director_end(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_end : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->end();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_end)

static bool js_cocos2dx_Director_getTextureCache(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getTextureCache : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::TextureCache* result = cobj->getTextureCache();
        ok &= native_ptr_to_seval<cocos2d::TextureCache>((cocos2d::TextureCache*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getTextureCache : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getTextureCache)

static bool js_cocos2dx_Director_isSendCleanupToScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isSendCleanupToScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isSendCleanupToScene();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_isSendCleanupToScene : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isSendCleanupToScene)

static bool js_cocos2dx_Director_getVisibleOrigin(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getVisibleOrigin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getVisibleOrigin();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getVisibleOrigin : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getVisibleOrigin)

static bool js_cocos2dx_Director_mainLoop(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_mainLoop : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->mainLoop();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_mainLoop)

static bool js_cocos2dx_Director_setDepthTest(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setDepthTest : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setDepthTest : Error processing arguments");
        cobj->setDepthTest(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setDepthTest)

static bool js_cocos2dx_Director_getFrameRate(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getFrameRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getFrameRate();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getFrameRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getFrameRate)

static bool js_cocos2dx_Director_getSecondsPerFrame(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getSecondsPerFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSecondsPerFrame();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getSecondsPerFrame : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getSecondsPerFrame)

static bool js_cocos2dx_Director_resetMatrixStack(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_resetMatrixStack : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resetMatrixStack();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_resetMatrixStack)

static bool js_cocos2dx_Director_convertToUI(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_convertToUI : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_convertToUI : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToUI(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_convertToUI : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_convertToUI)

static bool js_cocos2dx_Director_pushMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_pushMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::MATRIX_STACK_TYPE arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_pushMatrix : Error processing arguments");
        cobj->pushMatrix(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_pushMatrix)

static bool js_cocos2dx_Director_setDefaultValues(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setDefaultValues : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setDefaultValues();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setDefaultValues)

static bool js_cocos2dx_Director_init(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_init)

static bool js_cocos2dx_Director_setScheduler(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setScheduler : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Scheduler* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setScheduler : Error processing arguments");
        cobj->setScheduler(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setScheduler)

static bool js_cocos2dx_Director_multiplyProjectionMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_multiplyProjectionMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Mat4 arg0;
        unsigned long arg1 = 0;
        ok &= seval_to_Mat4(args[0], &arg0);
        ok &= seval_to_ulong(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_multiplyProjectionMatrix : Error processing arguments");
        cobj->multiplyProjectionMatrix(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_multiplyProjectionMatrix)

static bool js_cocos2dx_Director_getMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::MATRIX_STACK_TYPE arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getMatrix : Error processing arguments");
        const cocos2d::Mat4& result = cobj->getMatrix(arg0);
        ok &= Mat4_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getMatrix : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getMatrix)

static bool js_cocos2dx_Director_isValid(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isValid : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isValid();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_isValid : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isValid)

static bool js_cocos2dx_Director_startAnimation(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_startAnimation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->startAnimation();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_startAnimation)

static bool js_cocos2dx_Director_getOpenGLView(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getOpenGLView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLView* result = cobj->getOpenGLView();
        ok &= native_ptr_to_seval<cocos2d::GLView>((cocos2d::GLView*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getOpenGLView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getOpenGLView)

static bool js_cocos2dx_Director_getRunningScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getRunningScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Scene* result = cobj->getRunningScene();
        ok &= native_ptr_to_seval<cocos2d::Scene>((cocos2d::Scene*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getRunningScene : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getRunningScene)

static bool js_cocos2dx_Director_setViewport(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setViewport : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setViewport();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setViewport)

static bool js_cocos2dx_Director_stopAnimation(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_stopAnimation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stopAnimation();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_stopAnimation)

static bool js_cocos2dx_Director_popToSceneStackLevel(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_popToSceneStackLevel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_popToSceneStackLevel : Error processing arguments");
        cobj->popToSceneStackLevel(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_popToSceneStackLevel)

static bool js_cocos2dx_Director_resume(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_resume : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resume();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_resume)

static bool js_cocos2dx_Director_isNextDeltaTimeZero(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isNextDeltaTimeZero : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isNextDeltaTimeZero();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_isNextDeltaTimeZero : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isNextDeltaTimeZero)

static bool js_cocos2dx_Director_setClearColor(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setClearColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setClearColor : Error processing arguments");
        cobj->setClearColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setClearColor)

static bool js_cocos2dx_Director_setOpenGLView(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setOpenGLView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLView* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setOpenGLView : Error processing arguments");
        cobj->setOpenGLView(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setOpenGLView)

static bool js_cocos2dx_Director_convertToGL(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_convertToGL : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_convertToGL : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToGL(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_convertToGL : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_convertToGL)

static bool js_cocos2dx_Director_purgeCachedData(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_purgeCachedData : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->purgeCachedData();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_purgeCachedData)

static bool js_cocos2dx_Director_getTotalFrames(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getTotalFrames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getTotalFrames();
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getTotalFrames : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getTotalFrames)

static bool js_cocos2dx_Director_runWithScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_runWithScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Scene* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_runWithScene : Error processing arguments");
        cobj->runWithScene(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_runWithScene)

static bool js_cocos2dx_Director_setNotificationNode(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setNotificationNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setNotificationNode : Error processing arguments");
        cobj->setNotificationNode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setNotificationNode)

static bool js_cocos2dx_Director_drawScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_drawScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->drawScene();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_drawScene)

static bool js_cocos2dx_Director_restart(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_restart : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->restart();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_restart)

static bool js_cocos2dx_Director_popScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_popScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->popScene();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_popScene)

static bool js_cocos2dx_Director_loadIdentityMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_loadIdentityMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::MATRIX_STACK_TYPE arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_loadIdentityMatrix : Error processing arguments");
        cobj->loadIdentityMatrix(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_loadIdentityMatrix)

static bool js_cocos2dx_Director_isDisplayStats(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isDisplayStats : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isDisplayStats();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_isDisplayStats : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isDisplayStats)

static bool js_cocos2dx_Director_setProjection(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setProjection : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Director::Projection arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setProjection : Error processing arguments");
        cobj->setProjection(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setProjection)

static bool js_cocos2dx_Director_multiplyMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_multiplyMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::MATRIX_STACK_TYPE arg0;
        cocos2d::Mat4 arg1;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_Mat4(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_multiplyMatrix : Error processing arguments");
        cobj->multiplyMatrix(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_multiplyMatrix)

static bool js_cocos2dx_Director_getZEye(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getZEye : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getZEye();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getZEye : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getZEye)

static bool js_cocos2dx_Director_setNextDeltaTimeZero(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setNextDeltaTimeZero : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setNextDeltaTimeZero : Error processing arguments");
        cobj->setNextDeltaTimeZero(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setNextDeltaTimeZero)

static bool js_cocos2dx_Director_popMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_popMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::MATRIX_STACK_TYPE arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_popMatrix : Error processing arguments");
        cobj->popMatrix(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_popMatrix)

static bool js_cocos2dx_Director_getVisibleSize(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getVisibleSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Size result = cobj->getVisibleSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getVisibleSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getVisibleSize)

static bool js_cocos2dx_Director_loadProjectionMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_loadProjectionMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Mat4 arg0;
        unsigned long arg1 = 0;
        ok &= seval_to_Mat4(args[0], &arg0);
        ok &= seval_to_ulong(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_loadProjectionMatrix : Error processing arguments");
        cobj->loadProjectionMatrix(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_loadProjectionMatrix)

static bool js_cocos2dx_Director_initProjectionMatrixStack(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_initProjectionMatrixStack : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned long arg0 = 0;
        ok &= seval_to_ulong(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_initProjectionMatrixStack : Error processing arguments");
        cobj->initProjectionMatrixStack(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_initProjectionMatrixStack)

static bool js_cocos2dx_Director_getScheduler(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getScheduler : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Scheduler* result = cobj->getScheduler();
        ok &= native_ptr_to_seval<cocos2d::Scheduler>((cocos2d::Scheduler*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getScheduler : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getScheduler)

static bool js_cocos2dx_Director_pushScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_pushScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Scene* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_pushScene : Error processing arguments");
        cobj->pushScene(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_pushScene)

static bool js_cocos2dx_Director_getAnimationInterval(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getAnimationInterval : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAnimationInterval();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getAnimationInterval : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getAnimationInterval)

static bool js_cocos2dx_Director_isPaused(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isPaused : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isPaused();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_isPaused : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isPaused)

static bool js_cocos2dx_Director_setDisplayStats(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setDisplayStats : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setDisplayStats : Error processing arguments");
        cobj->setDisplayStats(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setDisplayStats)

static bool js_cocos2dx_Director_getEventDispatcher(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getEventDispatcher : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::EventDispatcher* result = cobj->getEventDispatcher();
        ok &= native_ptr_to_seval<cocos2d::EventDispatcher>((cocos2d::EventDispatcher*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getEventDispatcher : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getEventDispatcher)

static bool js_cocos2dx_Director_replaceScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_replaceScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Scene* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_replaceScene : Error processing arguments");
        cobj->replaceScene(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_replaceScene)

static bool js_cocos2dx_Director_setAnimationInterval(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setAnimationInterval : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_setAnimationInterval : Error processing arguments");
        cobj->setAnimationInterval(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setAnimationInterval)

static bool js_cocos2dx_Director_getActionManager(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getActionManager : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ActionManager* result = cobj->getActionManager();
        ok &= native_ptr_to_seval<cocos2d::ActionManager>((cocos2d::ActionManager*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Director_getActionManager : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getActionManager)

static bool js_cocos2dx_Director_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Director::getInstance();
        se::Object* obj = nullptr;
        if (result->_scriptObject == nullptr)
        {
            obj = se::Object::createObjectWithClass(__jsb_cocos2d_Director_class, true);
            obj->setPrivateData(result);
            result->_scriptObject = obj;
        }
        else
        {
            obj = se::Object::getObjectWithPtr(result);
        }
        assert(obj);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getInstance)




bool js_register_cocos2dx_Director(se::Object* obj)
{
    auto cls = se::Class::create("Director", obj, nullptr, nullptr);

    cls->defineFunction("pause", _SE(js_cocos2dx_Director_pause));
    cls->defineFunction("pushProjectionMatrix", _SE(js_cocos2dx_Director_pushProjectionMatrix));
    cls->defineFunction("popProjectionMatrix", _SE(js_cocos2dx_Director_popProjectionMatrix));
    cls->defineFunction("setEventDispatcher", _SE(js_cocos2dx_Director_setEventDispatcher));
    cls->defineFunction("loadProjectionIdentityMatrix", _SE(js_cocos2dx_Director_loadProjectionIdentityMatrix));
    cls->defineFunction("setContentScaleFactor", _SE(js_cocos2dx_Director_setContentScaleFactor));
    cls->defineFunction("getContentScaleFactor", _SE(js_cocos2dx_Director_getContentScaleFactor));
    cls->defineFunction("getWinSizeInPixels", _SE(js_cocos2dx_Director_getWinSizeInPixels));
    cls->defineFunction("getDeltaTime", _SE(js_cocos2dx_Director_getDeltaTime));
    cls->defineFunction("setGLDefaultValues", _SE(js_cocos2dx_Director_setGLDefaultValues));
    cls->defineFunction("setActionManager", _SE(js_cocos2dx_Director_setActionManager));
    cls->defineFunction("setAlphaBlending", _SE(js_cocos2dx_Director_setAlphaBlending));
    cls->defineFunction("popToRootScene", _SE(js_cocos2dx_Director_popToRootScene));
    cls->defineFunction("loadMatrix", _SE(js_cocos2dx_Director_loadMatrix));
    cls->defineFunction("getNotificationNode", _SE(js_cocos2dx_Director_getNotificationNode));
    cls->defineFunction("getWinSize", _SE(js_cocos2dx_Director_getWinSize));
    cls->defineFunction("end", _SE(js_cocos2dx_Director_end));
    cls->defineFunction("getTextureCache", _SE(js_cocos2dx_Director_getTextureCache));
    cls->defineFunction("isSendCleanupToScene", _SE(js_cocos2dx_Director_isSendCleanupToScene));
    cls->defineFunction("getVisibleOrigin", _SE(js_cocos2dx_Director_getVisibleOrigin));
    cls->defineFunction("mainLoop", _SE(js_cocos2dx_Director_mainLoop));
    cls->defineFunction("setDepthTest", _SE(js_cocos2dx_Director_setDepthTest));
    cls->defineFunction("getFrameRate", _SE(js_cocos2dx_Director_getFrameRate));
    cls->defineFunction("getSecondsPerFrame", _SE(js_cocos2dx_Director_getSecondsPerFrame));
    cls->defineFunction("resetMatrixStack", _SE(js_cocos2dx_Director_resetMatrixStack));
    cls->defineFunction("convertToUI", _SE(js_cocos2dx_Director_convertToUI));
    cls->defineFunction("pushMatrix", _SE(js_cocos2dx_Director_pushMatrix));
    cls->defineFunction("setDefaultValues", _SE(js_cocos2dx_Director_setDefaultValues));
    cls->defineFunction("init", _SE(js_cocos2dx_Director_init));
    cls->defineFunction("setScheduler", _SE(js_cocos2dx_Director_setScheduler));
    cls->defineFunction("multiplyProjectionMatrix", _SE(js_cocos2dx_Director_multiplyProjectionMatrix));
    cls->defineFunction("getMatrix", _SE(js_cocos2dx_Director_getMatrix));
    cls->defineFunction("isValid", _SE(js_cocos2dx_Director_isValid));
    cls->defineFunction("startAnimation", _SE(js_cocos2dx_Director_startAnimation));
    cls->defineFunction("getOpenGLView", _SE(js_cocos2dx_Director_getOpenGLView));
    cls->defineFunction("getRunningScene", _SE(js_cocos2dx_Director_getRunningScene));
    cls->defineFunction("setViewport", _SE(js_cocos2dx_Director_setViewport));
    cls->defineFunction("stopAnimation", _SE(js_cocos2dx_Director_stopAnimation));
    cls->defineFunction("popToSceneStackLevel", _SE(js_cocos2dx_Director_popToSceneStackLevel));
    cls->defineFunction("resume", _SE(js_cocos2dx_Director_resume));
    cls->defineFunction("isNextDeltaTimeZero", _SE(js_cocos2dx_Director_isNextDeltaTimeZero));
    cls->defineFunction("setClearColor", _SE(js_cocos2dx_Director_setClearColor));
    cls->defineFunction("setOpenGLView", _SE(js_cocos2dx_Director_setOpenGLView));
    cls->defineFunction("convertToGL", _SE(js_cocos2dx_Director_convertToGL));
    cls->defineFunction("purgeCachedData", _SE(js_cocos2dx_Director_purgeCachedData));
    cls->defineFunction("getTotalFrames", _SE(js_cocos2dx_Director_getTotalFrames));
    cls->defineFunction("runWithScene", _SE(js_cocos2dx_Director_runWithScene));
    cls->defineFunction("setNotificationNode", _SE(js_cocos2dx_Director_setNotificationNode));
    cls->defineFunction("drawScene", _SE(js_cocos2dx_Director_drawScene));
    cls->defineFunction("restart", _SE(js_cocos2dx_Director_restart));
    cls->defineFunction("popScene", _SE(js_cocos2dx_Director_popScene));
    cls->defineFunction("loadIdentityMatrix", _SE(js_cocos2dx_Director_loadIdentityMatrix));
    cls->defineFunction("isDisplayStats", _SE(js_cocos2dx_Director_isDisplayStats));
    cls->defineFunction("setProjection", _SE(js_cocos2dx_Director_setProjection));
    cls->defineFunction("multiplyMatrix", _SE(js_cocos2dx_Director_multiplyMatrix));
    cls->defineFunction("getZEye", _SE(js_cocos2dx_Director_getZEye));
    cls->defineFunction("setNextDeltaTimeZero", _SE(js_cocos2dx_Director_setNextDeltaTimeZero));
    cls->defineFunction("popMatrix", _SE(js_cocos2dx_Director_popMatrix));
    cls->defineFunction("getVisibleSize", _SE(js_cocos2dx_Director_getVisibleSize));
    cls->defineFunction("loadProjectionMatrix", _SE(js_cocos2dx_Director_loadProjectionMatrix));
    cls->defineFunction("initProjectionMatrixStack", _SE(js_cocos2dx_Director_initProjectionMatrixStack));
    cls->defineFunction("getScheduler", _SE(js_cocos2dx_Director_getScheduler));
    cls->defineFunction("pushScene", _SE(js_cocos2dx_Director_pushScene));
    cls->defineFunction("getAnimationInterval", _SE(js_cocos2dx_Director_getAnimationInterval));
    cls->defineFunction("isPaused", _SE(js_cocos2dx_Director_isPaused));
    cls->defineFunction("setDisplayStats", _SE(js_cocos2dx_Director_setDisplayStats));
    cls->defineFunction("getEventDispatcher", _SE(js_cocos2dx_Director_getEventDispatcher));
    cls->defineFunction("replaceScene", _SE(js_cocos2dx_Director_replaceScene));
    cls->defineFunction("setAnimationInterval", _SE(js_cocos2dx_Director_setAnimationInterval));
    cls->defineFunction("getActionManager", _SE(js_cocos2dx_Director_getActionManager));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_Director_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::Director>(cls);

    __jsb_cocos2d_Director_proto = cls->getProto();
    __jsb_cocos2d_Director_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Scheduler_proto = nullptr;
se::Class* __jsb_cocos2d_Scheduler_class = nullptr;

static bool js_cocos2dx_Scheduler_setTimeScale(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_setTimeScale : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_setTimeScale : Error processing arguments");
        cobj->setTimeScale(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_setTimeScale)

static bool js_cocos2dx_Scheduler_update(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_update : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_update : Error processing arguments");
        cobj->update(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_update)

static bool js_cocos2dx_Scheduler_unscheduleScriptEntry(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_unscheduleScriptEntry : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_unscheduleScriptEntry : Error processing arguments");
        cobj->unscheduleScriptEntry(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_unscheduleScriptEntry)

static bool js_cocos2dx_Scheduler_unscheduleAll(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_unscheduleAll : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->unscheduleAll();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_unscheduleAll)

static bool js_cocos2dx_Scheduler_getTimeScale(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_getTimeScale : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getTimeScale();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_getTimeScale : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_getTimeScale)

static bool js_cocos2dx_Scheduler_unscheduleAllWithMinPriority(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_unscheduleAllWithMinPriority : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_unscheduleAllWithMinPriority : Error processing arguments");
        cobj->unscheduleAllWithMinPriority(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_unscheduleAllWithMinPriority)

static bool js_cocos2dx_Scheduler_performFunctionInCocosThread(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_performFunctionInCocosThread : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void ()> arg0;
        do {
		    if (args[0].isObject() && args[0].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[0]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=]() -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(se::EmptyValueArray, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg0 = lambda;
		    }
		    else
		    {
		        arg0 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_performFunctionInCocosThread : Error processing arguments");
        cobj->performFunctionInCocosThread(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_performFunctionInCocosThread)

static bool js_cocos2dx_Scheduler_removeAllFunctionsToBePerformedInCocosThread(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_removeAllFunctionsToBePerformedInCocosThread : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllFunctionsToBePerformedInCocosThread();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_removeAllFunctionsToBePerformedInCocosThread)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Scheduler_finalize)

static bool js_cocos2dx_Scheduler_constructor(se::State& s)
{
    cocos2d::Scheduler* cobj = new (std::nothrow) cocos2d::Scheduler();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Scheduler_constructor, __jsb_cocos2d_Scheduler_class, js_cocos2d_Scheduler_finalize)




bool js_cocos2d_Scheduler_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Scheduler)", s.nativeThisObject());
        cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Scheduler_finalize)

bool js_register_cocos2dx_Scheduler(se::Object* obj)
{
    auto cls = se::Class::create("Scheduler", obj, nullptr, _SE(js_cocos2dx_Scheduler_constructor));

    cls->defineFunction("setTimeScale", _SE(js_cocos2dx_Scheduler_setTimeScale));
    cls->defineFunction("update", _SE(js_cocos2dx_Scheduler_update));
    cls->defineFunction("unscheduleScriptEntry", _SE(js_cocos2dx_Scheduler_unscheduleScriptEntry));
    cls->defineFunction("unscheduleAll", _SE(js_cocos2dx_Scheduler_unscheduleAll));
    cls->defineFunction("getTimeScale", _SE(js_cocos2dx_Scheduler_getTimeScale));
    cls->defineFunction("unscheduleAllWithMinPriority", _SE(js_cocos2dx_Scheduler_unscheduleAllWithMinPriority));
    cls->defineFunction("performFunctionInCocosThread", _SE(js_cocos2dx_Scheduler_performFunctionInCocosThread));
    cls->defineFunction("removeAllFunctionsToBePerformedInCocosThread", _SE(js_cocos2dx_Scheduler_removeAllFunctionsToBePerformedInCocosThread));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Scheduler_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Scheduler>(cls);

    __jsb_cocos2d_Scheduler_proto = cls->getProto();
    __jsb_cocos2d_Scheduler_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_AsyncTaskPool_proto = nullptr;
se::Class* __jsb_cocos2d_AsyncTaskPool_class = nullptr;

static bool js_cocos2dx_AsyncTaskPool_stopTasks(se::State& s)
{
    cocos2d::AsyncTaskPool* cobj = (cocos2d::AsyncTaskPool*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AsyncTaskPool_stopTasks : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::AsyncTaskPool::TaskType arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AsyncTaskPool_stopTasks : Error processing arguments");
        cobj->stopTasks(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AsyncTaskPool_stopTasks)

static bool js_cocos2dx_AsyncTaskPool_destroyInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::AsyncTaskPool::destroyInstance();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AsyncTaskPool_destroyInstance)

static bool js_cocos2dx_AsyncTaskPool_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::AsyncTaskPool* result = cocos2d::AsyncTaskPool::getInstance();
        ok &= native_ptr_to_seval<cocos2d::AsyncTaskPool>((cocos2d::AsyncTaskPool*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AsyncTaskPool_getInstance : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AsyncTaskPool_getInstance)




bool js_register_cocos2dx_AsyncTaskPool(se::Object* obj)
{
    auto cls = se::Class::create("AsyncTaskPool", obj, nullptr, nullptr);

    cls->defineFunction("stopTasks", _SE(js_cocos2dx_AsyncTaskPool_stopTasks));
    cls->defineStaticFunction("destroyInstance", _SE(js_cocos2dx_AsyncTaskPool_destroyInstance));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_AsyncTaskPool_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::AsyncTaskPool>(cls);

    __jsb_cocos2d_AsyncTaskPool_proto = cls->getProto();
    __jsb_cocos2d_AsyncTaskPool_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Action_proto = nullptr;
se::Class* __jsb_cocos2d_Action_class = nullptr;

static bool js_cocos2dx_Action_startWithTarget(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_startWithTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_startWithTarget : Error processing arguments");
        cobj->startWithTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_startWithTarget)

static bool js_cocos2dx_Action_setOriginalTarget(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_setOriginalTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_setOriginalTarget : Error processing arguments");
        cobj->setOriginalTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_setOriginalTarget)

static bool js_cocos2dx_Action_clone(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Action* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::Action>((cocos2d::Action*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_clone)

static bool js_cocos2dx_Action_getOriginalTarget(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_getOriginalTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getOriginalTarget();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_getOriginalTarget : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_getOriginalTarget)

static bool js_cocos2dx_Action_stop(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_stop : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stop();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_stop)

static bool js_cocos2dx_Action_update(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_update : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_update : Error processing arguments");
        cobj->update(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_update)

static bool js_cocos2dx_Action_getTarget(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_getTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getTarget();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_getTarget : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_getTarget)

static bool js_cocos2dx_Action_getFlags(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_getFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getFlags();
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_getFlags : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_getFlags)

static bool js_cocos2dx_Action_step(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_step : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_step : Error processing arguments");
        cobj->step(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_step)

static bool js_cocos2dx_Action_setTag(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_setTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_setTag : Error processing arguments");
        cobj->setTag(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_setTag)

static bool js_cocos2dx_Action_setFlags(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_setFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_setFlags : Error processing arguments");
        cobj->setFlags(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_setFlags)

static bool js_cocos2dx_Action_getTag(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_getTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getTag();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_getTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_getTag)

static bool js_cocos2dx_Action_setTarget(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_setTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_setTarget : Error processing arguments");
        cobj->setTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_setTarget)

static bool js_cocos2dx_Action_isDone(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_isDone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isDone();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_isDone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_isDone)

static bool js_cocos2dx_Action_reverse(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Action_reverse : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Action* result = cobj->reverse();
        ok &= native_ptr_to_seval<cocos2d::Action>((cocos2d::Action*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Action_reverse : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_reverse)




bool js_register_cocos2dx_Action(se::Object* obj)
{
    auto cls = se::Class::create("Action", obj, nullptr, nullptr);

    cls->defineFunction("startWithTarget", _SE(js_cocos2dx_Action_startWithTarget));
    cls->defineFunction("setOriginalTarget", _SE(js_cocos2dx_Action_setOriginalTarget));
    cls->defineFunction("clone", _SE(js_cocos2dx_Action_clone));
    cls->defineFunction("getOriginalTarget", _SE(js_cocos2dx_Action_getOriginalTarget));
    cls->defineFunction("stop", _SE(js_cocos2dx_Action_stop));
    cls->defineFunction("update", _SE(js_cocos2dx_Action_update));
    cls->defineFunction("getTarget", _SE(js_cocos2dx_Action_getTarget));
    cls->defineFunction("getFlags", _SE(js_cocos2dx_Action_getFlags));
    cls->defineFunction("step", _SE(js_cocos2dx_Action_step));
    cls->defineFunction("setTag", _SE(js_cocos2dx_Action_setTag));
    cls->defineFunction("setFlags", _SE(js_cocos2dx_Action_setFlags));
    cls->defineFunction("getTag", _SE(js_cocos2dx_Action_getTag));
    cls->defineFunction("setTarget", _SE(js_cocos2dx_Action_setTarget));
    cls->defineFunction("isDone", _SE(js_cocos2dx_Action_isDone));
    cls->defineFunction("reverse", _SE(js_cocos2dx_Action_reverse));
    cls->install();
    JSBClassType::registerClass<cocos2d::Action>(cls);

    __jsb_cocos2d_Action_proto = cls->getProto();
    __jsb_cocos2d_Action_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_FiniteTimeAction_proto = nullptr;
se::Class* __jsb_cocos2d_FiniteTimeAction_class = nullptr;

static bool js_cocos2dx_FiniteTimeAction_setDuration(se::State& s)
{
    cocos2d::FiniteTimeAction* cobj = (cocos2d::FiniteTimeAction*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FiniteTimeAction_setDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FiniteTimeAction_setDuration : Error processing arguments");
        cobj->setDuration(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FiniteTimeAction_setDuration)

static bool js_cocos2dx_FiniteTimeAction_getDuration(se::State& s)
{
    cocos2d::FiniteTimeAction* cobj = (cocos2d::FiniteTimeAction*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FiniteTimeAction_getDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getDuration();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FiniteTimeAction_getDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FiniteTimeAction_getDuration)


extern se::Object* __jsb_cocos2d_Action_proto;


bool js_register_cocos2dx_FiniteTimeAction(se::Object* obj)
{
    auto cls = se::Class::create("FiniteTimeAction", obj, __jsb_cocos2d_Action_proto, nullptr);

    cls->defineFunction("setDuration", _SE(js_cocos2dx_FiniteTimeAction_setDuration));
    cls->defineFunction("getDuration", _SE(js_cocos2dx_FiniteTimeAction_getDuration));
    cls->install();
    JSBClassType::registerClass<cocos2d::FiniteTimeAction>(cls);

    __jsb_cocos2d_FiniteTimeAction_proto = cls->getProto();
    __jsb_cocos2d_FiniteTimeAction_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Speed_proto = nullptr;
se::Class* __jsb_cocos2d_Speed_class = nullptr;

static bool js_cocos2dx_Speed_setInnerAction(se::State& s)
{
    cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Speed_setInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Speed_setInnerAction : Error processing arguments");
        cobj->setInnerAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Speed_setInnerAction)

static bool js_cocos2dx_Speed_getSpeed(se::State& s)
{
    cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Speed_getSpeed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSpeed();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Speed_getSpeed : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Speed_getSpeed)

static bool js_cocos2dx_Speed_setSpeed(se::State& s)
{
    cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Speed_setSpeed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Speed_setSpeed : Error processing arguments");
        cobj->setSpeed(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Speed_setSpeed)

static bool js_cocos2dx_Speed_initWithAction(se::State& s)
{
    cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Speed_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Speed_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Speed_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Speed_initWithAction)

static bool js_cocos2dx_Speed_getInnerAction(se::State& s)
{
    cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Speed_getInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ActionInterval* result = cobj->getInnerAction();
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Speed_getInnerAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Speed_getInnerAction)

static bool js_cocos2dx_Speed_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Speed_create : Error processing arguments");
        auto result = cocos2d::Speed::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Speed_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Speed_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Speed_finalize)

static bool js_cocos2dx_Speed_constructor(se::State& s)
{
    cocos2d::Speed* cobj = new (std::nothrow) cocos2d::Speed();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Speed_constructor, __jsb_cocos2d_Speed_class, js_cocos2d_Speed_finalize)



extern se::Object* __jsb_cocos2d_Action_proto;

bool js_cocos2d_Speed_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Speed)", s.nativeThisObject());
        cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Speed_finalize)

bool js_register_cocos2dx_Speed(se::Object* obj)
{
    auto cls = se::Class::create("Speed", obj, __jsb_cocos2d_Action_proto, _SE(js_cocos2dx_Speed_constructor));

    cls->defineFunction("setInnerAction", _SE(js_cocos2dx_Speed_setInnerAction));
    cls->defineFunction("_getSpeed", _SE(js_cocos2dx_Speed_getSpeed));
    cls->defineFunction("_setSpeed", _SE(js_cocos2dx_Speed_setSpeed));
    cls->defineFunction("initWithAction", _SE(js_cocos2dx_Speed_initWithAction));
    cls->defineFunction("getInnerAction", _SE(js_cocos2dx_Speed_getInnerAction));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Speed_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Speed_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Speed>(cls);

    __jsb_cocos2d_Speed_proto = cls->getProto();
    __jsb_cocos2d_Speed_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Follow_proto = nullptr;
se::Class* __jsb_cocos2d_Follow_class = nullptr;

static bool js_cocos2dx_Follow_setBoundarySet(se::State& s)
{
    cocos2d::Follow* cobj = (cocos2d::Follow*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Follow_setBoundarySet : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_setBoundarySet : Error processing arguments");
        cobj->setBoundarySet(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Follow_setBoundarySet)

static bool js_cocos2dx_Follow_initWithTarget(se::State& s)
{
    cocos2d::Follow* cobj = (cocos2d::Follow*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Follow_initWithTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_initWithTarget : Error processing arguments");
        bool result = cobj->initWithTarget(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_initWithTarget : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        cocos2d::Rect arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_Rect(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_initWithTarget : Error processing arguments");
        bool result = cobj->initWithTarget(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_initWithTarget : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Follow_initWithTarget)

static bool js_cocos2dx_Follow_initWithTargetAndOffset(se::State& s)
{
    cocos2d::Follow* cobj = (cocos2d::Follow*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Follow_initWithTargetAndOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Node* arg0 = nullptr;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_initWithTargetAndOffset : Error processing arguments");
        bool result = cobj->initWithTargetAndOffset(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_initWithTargetAndOffset : Error processing arguments");
        return true;
    }
    if (argc == 4) {
        cocos2d::Node* arg0 = nullptr;
        float arg1 = 0;
        float arg2 = 0;
        cocos2d::Rect arg3;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Rect(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_initWithTargetAndOffset : Error processing arguments");
        bool result = cobj->initWithTargetAndOffset(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_initWithTargetAndOffset : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Follow_initWithTargetAndOffset)

static bool js_cocos2dx_Follow_isBoundarySet(se::State& s)
{
    cocos2d::Follow* cobj = (cocos2d::Follow*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Follow_isBoundarySet : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isBoundarySet();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_isBoundarySet : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Follow_isBoundarySet)

static bool js_cocos2dx_Follow_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_create : Error processing arguments");
        auto result = cocos2d::Follow::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Follow_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        cocos2d::Rect arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_Rect(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_create : Error processing arguments");
        auto result = cocos2d::Follow::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Follow_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Follow_create)

static bool js_cocos2dx_Follow_createWithOffset(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Node* arg0 = nullptr;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_createWithOffset : Error processing arguments");
        auto result = cocos2d::Follow::createWithOffset(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Follow_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 4) {
        cocos2d::Node* arg0 = nullptr;
        float arg1 = 0;
        float arg2 = 0;
        cocos2d::Rect arg3;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Rect(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Follow_createWithOffset : Error processing arguments");
        auto result = cocos2d::Follow::createWithOffset(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Follow_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Follow_createWithOffset)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Follow_finalize)

static bool js_cocos2dx_Follow_constructor(se::State& s)
{
    cocos2d::Follow* cobj = new (std::nothrow) cocos2d::Follow();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Follow_constructor, __jsb_cocos2d_Follow_class, js_cocos2d_Follow_finalize)

static bool js_cocos2dx_Follow_ctor(se::State& s)
{
    cocos2d::Follow* cobj = new (std::nothrow) cocos2d::Follow();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Follow_ctor, __jsb_cocos2d_Follow_class, js_cocos2d_Follow_finalize)


    

extern se::Object* __jsb_cocos2d_Action_proto;

bool js_cocos2d_Follow_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Follow)", s.nativeThisObject());
        cocos2d::Follow* cobj = (cocos2d::Follow*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Follow_finalize)

bool js_register_cocos2dx_Follow(se::Object* obj)
{
    auto cls = se::Class::create("Follow", obj, __jsb_cocos2d_Action_proto, _SE(js_cocos2dx_Follow_constructor));

    cls->defineFunction("setBoundarySet", _SE(js_cocos2dx_Follow_setBoundarySet));
    cls->defineFunction("initWithTarget", _SE(js_cocos2dx_Follow_initWithTarget));
    cls->defineFunction("initWithTargetAndOffset", _SE(js_cocos2dx_Follow_initWithTargetAndOffset));
    cls->defineFunction("isBoundarySet", _SE(js_cocos2dx_Follow_isBoundarySet));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Follow_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Follow_create));
    cls->defineStaticFunction("createWithOffset", _SE(js_cocos2dx_Follow_createWithOffset));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Follow_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Follow>(cls);

    __jsb_cocos2d_Follow_proto = cls->getProto();
    __jsb_cocos2d_Follow_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Follow.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Image_proto = nullptr;
se::Class* __jsb_cocos2d_Image_class = nullptr;

static bool js_cocos2dx_Image_hasPremultipliedAlpha(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_hasPremultipliedAlpha : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasPremultipliedAlpha();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_hasPremultipliedAlpha : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_hasPremultipliedAlpha)

static bool js_cocos2dx_Image_saveToFile(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_saveToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_saveToFile : Error processing arguments");
        bool result = cobj->saveToFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_saveToFile : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        bool arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_saveToFile : Error processing arguments");
        bool result = cobj->saveToFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_saveToFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_saveToFile)

static bool js_cocos2dx_Image_hasAlpha(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_hasAlpha : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasAlpha();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_hasAlpha : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_hasAlpha)

static bool js_cocos2dx_Image_isCompressed(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_isCompressed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isCompressed();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_isCompressed : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_isCompressed)

static bool js_cocos2dx_Image_getHeight(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getHeight();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_getHeight : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getHeight)

static bool js_cocos2dx_Image_initWithImageFile(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_initWithImageFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_initWithImageFile : Error processing arguments");
        bool result = cobj->initWithImageFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_initWithImageFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_initWithImageFile)

static bool js_cocos2dx_Image_getWidth(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getWidth();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_getWidth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getWidth)

static bool js_cocos2dx_Image_getBitPerPixel(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getBitPerPixel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getBitPerPixel();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_getBitPerPixel : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getBitPerPixel)

static bool js_cocos2dx_Image_getFileType(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getFileType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getFileType();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_getFileType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getFileType)

static bool js_cocos2dx_Image_getFilePath(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getFilePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getFilePath();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_getFilePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getFilePath)

static bool js_cocos2dx_Image_getNumberOfMipmaps(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getNumberOfMipmaps : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getNumberOfMipmaps();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_getNumberOfMipmaps : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getNumberOfMipmaps)

static bool js_cocos2dx_Image_getRenderFormat(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getRenderFormat : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getRenderFormat();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_getRenderFormat : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getRenderFormat)

static bool js_cocos2dx_Image_initWithRawData(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Image_initWithRawData : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 5) {
        const unsigned char* arg0 = nullptr;
        ssize_t arg1 = 0;
        int arg2 = 0;
        int arg3 = 0;
        int arg4 = 0;
        #pragma warning NO CONVERSION TO NATIVE FOR unsigned char*
		ok = false;
        ok &= seval_to_ssize(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        ok &= seval_to_int32(args[4], (int32_t *)&arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_initWithRawData : Error processing arguments");
        bool result = cobj->initWithRawData(arg0, arg1, arg2, arg3, arg4);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_initWithRawData : Error processing arguments");
        return true;
    }
    if (argc == 6) {
        const unsigned char* arg0 = nullptr;
        ssize_t arg1 = 0;
        int arg2 = 0;
        int arg3 = 0;
        int arg4 = 0;
        bool arg5;
        #pragma warning NO CONVERSION TO NATIVE FOR unsigned char*
		ok = false;
        ok &= seval_to_ssize(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        ok &= seval_to_int32(args[4], (int32_t *)&arg4);
        ok &= seval_to_boolean(args[5], &arg5);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_initWithRawData : Error processing arguments");
        bool result = cobj->initWithRawData(arg0, arg1, arg2, arg3, arg4, arg5);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_initWithRawData : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_initWithRawData)

static bool js_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha : Error processing arguments");
        cocos2d::Image::setPVRImagesHavePremultipliedAlpha(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha)

static bool js_cocos2dx_Image_setPNGPremultipliedAlphaEnabled(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Image_setPNGPremultipliedAlphaEnabled : Error processing arguments");
        cocos2d::Image::setPNGPremultipliedAlphaEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_setPNGPremultipliedAlphaEnabled)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Image_finalize)

static bool js_cocos2dx_Image_constructor(se::State& s)
{
    cocos2d::Image* cobj = new (std::nothrow) cocos2d::Image();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Image_constructor, __jsb_cocos2d_Image_class, js_cocos2d_Image_finalize)




bool js_cocos2d_Image_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Image)", s.nativeThisObject());
        cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Image_finalize)

bool js_register_cocos2dx_Image(se::Object* obj)
{
    auto cls = se::Class::create("Image", obj, nullptr, _SE(js_cocos2dx_Image_constructor));

    cls->defineFunction("hasPremultipliedAlpha", _SE(js_cocos2dx_Image_hasPremultipliedAlpha));
    cls->defineFunction("saveToFile", _SE(js_cocos2dx_Image_saveToFile));
    cls->defineFunction("hasAlpha", _SE(js_cocos2dx_Image_hasAlpha));
    cls->defineFunction("isCompressed", _SE(js_cocos2dx_Image_isCompressed));
    cls->defineFunction("getHeight", _SE(js_cocos2dx_Image_getHeight));
    cls->defineFunction("initWithImageFile", _SE(js_cocos2dx_Image_initWithImageFile));
    cls->defineFunction("getWidth", _SE(js_cocos2dx_Image_getWidth));
    cls->defineFunction("getBitPerPixel", _SE(js_cocos2dx_Image_getBitPerPixel));
    cls->defineFunction("getFileType", _SE(js_cocos2dx_Image_getFileType));
    cls->defineFunction("getFilePath", _SE(js_cocos2dx_Image_getFilePath));
    cls->defineFunction("getNumberOfMipmaps", _SE(js_cocos2dx_Image_getNumberOfMipmaps));
    cls->defineFunction("getRenderFormat", _SE(js_cocos2dx_Image_getRenderFormat));
    cls->defineFunction("initWithRawData", _SE(js_cocos2dx_Image_initWithRawData));
    cls->defineStaticFunction("setPVRImagesHavePremultipliedAlpha", _SE(js_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha));
    cls->defineStaticFunction("setPNGPremultipliedAlphaEnabled", _SE(js_cocos2dx_Image_setPNGPremultipliedAlphaEnabled));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Image_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Image>(cls);

    __jsb_cocos2d_Image_proto = cls->getProto();
    __jsb_cocos2d_Image_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_GLProgramState_proto = nullptr;
se::Class* __jsb_cocos2d_GLProgramState_class = nullptr;

static bool js_cocos2dx_GLProgramState_setUniformCallback(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            std::function<void (cocos2d::GLProgram *, cocos2d::Uniform *)> arg1;
            do {
			    if (args[1].isObject() && args[1].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[1]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](cocos2d::GLProgram* larg0, cocos2d::Uniform* larg1) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(2);
			            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)larg0, &args[0]);
			            ok &= uniform_to_seval(larg1, &args[1]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg1 = lambda;
			    }
			    else
			    {
			        arg1 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->setUniformCallback(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::function<void (cocos2d::GLProgram *, cocos2d::Uniform *)> arg1;
            do {
			    if (args[1].isObject() && args[1].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[1]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](cocos2d::GLProgram* larg0, cocos2d::Uniform* larg1) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(2);
			            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)larg0, &args[0]);
			            ok &= uniform_to_seval(larg1, &args[1]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg1 = lambda;
			    }
			    else
			    {
			        arg1 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->setUniformCallback(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformCallback)

static bool js_cocos2dx_GLProgramState_getVertexAttribsFlags(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_getVertexAttribsFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getVertexAttribsFlags();
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getVertexAttribsFlags : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getVertexAttribsFlags)

static bool js_cocos2dx_GLProgramState_applyAutoBinding(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_applyAutoBinding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_applyAutoBinding : Error processing arguments");
        cobj->applyAutoBinding(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_applyAutoBinding)

static bool js_cocos2dx_GLProgramState_setUniformVec2(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformVec2 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec2(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec2(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformVec2)

static bool js_cocos2dx_GLProgramState_setUniformVec3(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformVec3 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec3(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec3(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformVec3)

static bool js_cocos2dx_GLProgramState_setVertexAttribCallback(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_setVertexAttribCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::function<void (cocos2d::VertexAttrib *)> arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        do {
		    if (args[1].isObject() && args[1].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[1]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](cocos2d::VertexAttrib* larg0) -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(1);
		            ok &= native_ptr_to_seval<cocos2d::VertexAttrib>((cocos2d::VertexAttrib*)larg0, &args[0]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg1 = lambda;
		    }
		    else
		    {
		        arg1 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_setVertexAttribCallback : Error processing arguments");
        cobj->setVertexAttribCallback(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setVertexAttribCallback)

static bool js_cocos2dx_GLProgramState_apply(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_apply : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Mat4 arg0;
        ok &= seval_to_Mat4(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_apply : Error processing arguments");
        cobj->apply(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_apply)

static bool js_cocos2dx_GLProgramState_getNodeBinding(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_getNodeBinding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getNodeBinding();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getNodeBinding : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getNodeBinding)

static bool js_cocos2dx_GLProgramState_applyGLProgram(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_applyGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Mat4 arg0;
        ok &= seval_to_Mat4(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_applyGLProgram : Error processing arguments");
        cobj->applyGLProgram(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_applyGLProgram)

static bool js_cocos2dx_GLProgramState_setNodeBinding(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_setNodeBinding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_setNodeBinding : Error processing arguments");
        cobj->setNodeBinding(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setNodeBinding)

static bool js_cocos2dx_GLProgramState_setUniformInt(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformInt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformInt(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformInt(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformInt)

static bool js_cocos2dx_GLProgramState_setParameterAutoBinding(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_setParameterAutoBinding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_setParameterAutoBinding : Error processing arguments");
        cobj->setParameterAutoBinding(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setParameterAutoBinding)

static bool js_cocos2dx_GLProgramState_setUniformVec2v(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformVec2v : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const cocos2d::Vec2* arg2 = nullptr;
            std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[2], &tempData);arg2=tempData.data();
            if (!ok) { ok = true; break; }
            cobj->setUniformVec2v(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const cocos2d::Vec2* arg2 = nullptr;
            std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[2], &tempData);arg2=tempData.data();
            if (!ok) { ok = true; break; }
            cobj->setUniformVec2v(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformVec2v)

static bool js_cocos2dx_GLProgramState_getUniformCount(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_getUniformCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getUniformCount();
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getUniformCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getUniformCount)

static bool js_cocos2dx_GLProgramState_applyAttributes(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_applyAttributes : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cobj->applyAttributes();
        return true;
    }
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_applyAttributes : Error processing arguments");
        cobj->applyAttributes(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_applyAttributes)

static bool js_cocos2dx_GLProgramState_clone(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLProgramState* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_clone)

static bool js_cocos2dx_GLProgramState_setGLProgram(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_setGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgram* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_setGLProgram : Error processing arguments");
        cobj->setGLProgram(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setGLProgram)

static bool js_cocos2dx_GLProgramState_setUniformFloatv(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformFloatv : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const float* arg2 = 0;
            #pragma warning NO CONVERSION TO NATIVE FOR float*
			ok = false;
            if (!ok) { ok = true; break; }
            cobj->setUniformFloatv(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const float* arg2 = 0;
            #pragma warning NO CONVERSION TO NATIVE FOR float*
			ok = false;
            if (!ok) { ok = true; break; }
            cobj->setUniformFloatv(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformFloatv)

static bool js_cocos2dx_GLProgramState_getGLProgram(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_getGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLProgram* result = cobj->getGLProgram();
        ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getGLProgram : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getGLProgram)

static bool js_cocos2dx_GLProgramState_setUniformTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformTexture(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformTexture(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformTexture)

static bool js_cocos2dx_GLProgramState_applyUniforms(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_applyUniforms : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->applyUniforms();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_applyUniforms)

static bool js_cocos2dx_GLProgramState_setUniformFloat(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformFloat : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformFloat(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformFloat(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformFloat)

static bool js_cocos2dx_GLProgramState_setUniformMat4(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformMat4 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 arg1;
            ok &= seval_to_Mat4(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformMat4(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 arg1;
            ok &= seval_to_Mat4(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformMat4(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformMat4)

static bool js_cocos2dx_GLProgramState_setUniformVec3v(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformVec3v : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const cocos2d::Vec3* arg2 = nullptr;
            ok &= seval_to_native_ptr(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec3v(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const cocos2d::Vec3* arg2 = nullptr;
            ok &= seval_to_native_ptr(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec3v(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformVec3v)

static bool js_cocos2dx_GLProgramState_getVertexAttribCount(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_getVertexAttribCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getVertexAttribCount();
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getVertexAttribCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getVertexAttribCount)

static bool js_cocos2dx_GLProgramState_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgram* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_create : Error processing arguments");
        auto result = cocos2d::GLProgramState::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_GLProgramState_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_create)

static bool js_cocos2dx_GLProgramState_getOrCreateWithGLProgramName(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::GLProgramState* result = cocos2d::GLProgramState::getOrCreateWithGLProgramName(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithGLProgramName : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::GLProgramState* result = cocos2d::GLProgramState::getOrCreateWithGLProgramName(arg0);
            ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithGLProgramName : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getOrCreateWithGLProgramName)

static bool js_cocos2dx_GLProgramState_getOrCreateWithGLProgram(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgram* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithGLProgram : Error processing arguments");
        cocos2d::GLProgramState* result = cocos2d::GLProgramState::getOrCreateWithGLProgram(arg0);
        ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithGLProgram : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getOrCreateWithGLProgram)

static bool js_cocos2dx_GLProgramState_getOrCreateWithShaders(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        std::string arg0;
        std::string arg1;
        std::string arg2;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_std_string(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithShaders : Error processing arguments");
        cocos2d::GLProgramState* result = cocos2d::GLProgramState::getOrCreateWithShaders(arg0, arg1, arg2);
        ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithShaders : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getOrCreateWithShaders)




bool js_register_cocos2dx_GLProgramState(se::Object* obj)
{
    auto cls = se::Class::create("GLProgramState", obj, nullptr, nullptr);

    cls->defineFunction("setUniformCallback", _SE(js_cocos2dx_GLProgramState_setUniformCallback));
    cls->defineFunction("getVertexAttribsFlags", _SE(js_cocos2dx_GLProgramState_getVertexAttribsFlags));
    cls->defineFunction("applyAutoBinding", _SE(js_cocos2dx_GLProgramState_applyAutoBinding));
    cls->defineFunction("setUniformVec2", _SE(js_cocos2dx_GLProgramState_setUniformVec2));
    cls->defineFunction("setUniformVec3", _SE(js_cocos2dx_GLProgramState_setUniformVec3));
    cls->defineFunction("setVertexAttribCallback", _SE(js_cocos2dx_GLProgramState_setVertexAttribCallback));
    cls->defineFunction("apply", _SE(js_cocos2dx_GLProgramState_apply));
    cls->defineFunction("getNodeBinding", _SE(js_cocos2dx_GLProgramState_getNodeBinding));
    cls->defineFunction("applyGLProgram", _SE(js_cocos2dx_GLProgramState_applyGLProgram));
    cls->defineFunction("setNodeBinding", _SE(js_cocos2dx_GLProgramState_setNodeBinding));
    cls->defineFunction("setUniformInt", _SE(js_cocos2dx_GLProgramState_setUniformInt));
    cls->defineFunction("setParameterAutoBinding", _SE(js_cocos2dx_GLProgramState_setParameterAutoBinding));
    cls->defineFunction("setUniformVec2v", _SE(js_cocos2dx_GLProgramState_setUniformVec2v));
    cls->defineFunction("getUniformCount", _SE(js_cocos2dx_GLProgramState_getUniformCount));
    cls->defineFunction("applyAttributes", _SE(js_cocos2dx_GLProgramState_applyAttributes));
    cls->defineFunction("clone", _SE(js_cocos2dx_GLProgramState_clone));
    cls->defineFunction("setGLProgram", _SE(js_cocos2dx_GLProgramState_setGLProgram));
    cls->defineFunction("setUniformFloatv", _SE(js_cocos2dx_GLProgramState_setUniformFloatv));
    cls->defineFunction("getGLProgram", _SE(js_cocos2dx_GLProgramState_getGLProgram));
    cls->defineFunction("setUniformTexture", _SE(js_cocos2dx_GLProgramState_setUniformTexture));
    cls->defineFunction("applyUniforms", _SE(js_cocos2dx_GLProgramState_applyUniforms));
    cls->defineFunction("setUniformFloat", _SE(js_cocos2dx_GLProgramState_setUniformFloat));
    cls->defineFunction("setUniformMat4", _SE(js_cocos2dx_GLProgramState_setUniformMat4));
    cls->defineFunction("setUniformVec3v", _SE(js_cocos2dx_GLProgramState_setUniformVec3v));
    cls->defineFunction("getVertexAttribCount", _SE(js_cocos2dx_GLProgramState_getVertexAttribCount));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_GLProgramState_create));
    cls->defineStaticFunction("getOrCreateWithGLProgramName", _SE(js_cocos2dx_GLProgramState_getOrCreateWithGLProgramName));
    cls->defineStaticFunction("getOrCreateWithGLProgram", _SE(js_cocos2dx_GLProgramState_getOrCreateWithGLProgram));
    cls->defineStaticFunction("getOrCreateWithShaders", _SE(js_cocos2dx_GLProgramState_getOrCreateWithShaders));
    cls->install();
    JSBClassType::registerClass<cocos2d::GLProgramState>(cls);

    __jsb_cocos2d_GLProgramState_proto = cls->getProto();
    __jsb_cocos2d_GLProgramState_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_SpriteFrame_proto = nullptr;
se::Class* __jsb_cocos2d_SpriteFrame_class = nullptr;

static bool js_cocos2dx_SpriteFrame_setAnchorPoint(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setAnchorPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setAnchorPoint : Error processing arguments");
        cobj->setAnchorPoint(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setAnchorPoint)

static bool js_cocos2dx_SpriteFrame_setTexture(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setTexture)

static bool js_cocos2dx_SpriteFrame_getTexture(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getTexture)

static bool js_cocos2dx_SpriteFrame_setOffsetInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setOffsetInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setOffsetInPixels : Error processing arguments");
        cobj->setOffsetInPixels(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setOffsetInPixels)

static bool js_cocos2dx_SpriteFrame_getOriginalSizeInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getOriginalSizeInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getOriginalSizeInPixels();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getOriginalSizeInPixels : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getOriginalSizeInPixels)

static bool js_cocos2dx_SpriteFrame_setOriginalSize(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setOriginalSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setOriginalSize : Error processing arguments");
        cobj->setOriginalSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setOriginalSize)

static bool js_cocos2dx_SpriteFrame_getCenterRect(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getCenterRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Rect& result = cobj->getCenterRect();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getCenterRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getCenterRect)

static bool js_cocos2dx_SpriteFrame_setRectInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setRectInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setRectInPixels : Error processing arguments");
        cobj->setRectInPixels(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setRectInPixels)

static bool js_cocos2dx_SpriteFrame_getRect(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Rect& result = cobj->getRect();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getRect)

static bool js_cocos2dx_SpriteFrame_setCenterRectInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setCenterRectInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setCenterRectInPixels : Error processing arguments");
        cobj->setCenterRectInPixels(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setCenterRectInPixels)

static bool js_cocos2dx_SpriteFrame_setOffset(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setOffset : Error processing arguments");
        cobj->setOffset(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setOffset)

static bool js_cocos2dx_SpriteFrame_initWithTextureFilename(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_SpriteFrame_initWithTextureFilename : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            cocos2d::Vec2 arg3;
            ok &= seval_to_Vec2(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg4;
            ok &= seval_to_Size(args[4], &arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTextureFilename(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_initWithTextureFilename : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTextureFilename(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_initWithTextureFilename : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_initWithTextureFilename)

static bool js_cocos2dx_SpriteFrame_setRect(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setRect : Error processing arguments");
        cobj->setRect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setRect)

static bool js_cocos2dx_SpriteFrame_initWithTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_SpriteFrame_initWithTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            cocos2d::Vec2 arg3;
            ok &= seval_to_Vec2(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg4;
            ok &= seval_to_Size(args[4], &arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTexture(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_initWithTexture : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTexture(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_initWithTexture : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_initWithTexture)

static bool js_cocos2dx_SpriteFrame_getOriginalSize(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getOriginalSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getOriginalSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getOriginalSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getOriginalSize)

static bool js_cocos2dx_SpriteFrame_clone(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::SpriteFrame* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_clone)

static bool js_cocos2dx_SpriteFrame_getRectInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getRectInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Rect& result = cobj->getRectInPixels();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getRectInPixels : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getRectInPixels)

static bool js_cocos2dx_SpriteFrame_isRotated(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_isRotated : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isRotated();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_isRotated : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_isRotated)

static bool js_cocos2dx_SpriteFrame_hasCenterRect(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_hasCenterRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasCenterRect();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_hasCenterRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_hasCenterRect)

static bool js_cocos2dx_SpriteFrame_setRotated(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setRotated : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setRotated : Error processing arguments");
        cobj->setRotated(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setRotated)

static bool js_cocos2dx_SpriteFrame_getOffset(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getOffset();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getOffset : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getOffset)

static bool js_cocos2dx_SpriteFrame_setOriginalSizeInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setOriginalSizeInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setOriginalSizeInPixels : Error processing arguments");
        cobj->setOriginalSizeInPixels(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setOriginalSizeInPixels)

static bool js_cocos2dx_SpriteFrame_getAnchorPoint(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getAnchorPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getAnchorPoint();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getAnchorPoint : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getAnchorPoint)

static bool js_cocos2dx_SpriteFrame_hasAnchorPoint(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_hasAnchorPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasAnchorPoint();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_hasAnchorPoint : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_hasAnchorPoint)

static bool js_cocos2dx_SpriteFrame_getOffsetInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getOffsetInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getOffsetInPixels();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getOffsetInPixels : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getOffsetInPixels)

static bool js_cocos2dx_SpriteFrame_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg3;
            ok &= seval_to_Vec2(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg4;
            ok &= seval_to_Size(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cocos2d::SpriteFrame* result = cocos2d::SpriteFrame::create(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::SpriteFrame* result = cocos2d::SpriteFrame::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_create)

static bool js_cocos2dx_SpriteFrame_createWithTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg3;
            ok &= seval_to_Vec2(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg4;
            ok &= seval_to_Size(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cocos2d::SpriteFrame* result = cocos2d::SpriteFrame::createWithTexture(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_createWithTexture : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::SpriteFrame* result = cocos2d::SpriteFrame::createWithTexture(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_createWithTexture : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_createWithTexture)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_SpriteFrame_finalize)

static bool js_cocos2dx_SpriteFrame_constructor(se::State& s)
{
    cocos2d::SpriteFrame* cobj = new (std::nothrow) cocos2d::SpriteFrame();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_SpriteFrame_constructor, __jsb_cocos2d_SpriteFrame_class, js_cocos2d_SpriteFrame_finalize)

static bool js_cocos2dx_SpriteFrame_ctor(se::State& s)
{
    cocos2d::SpriteFrame* cobj = new (std::nothrow) cocos2d::SpriteFrame();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_SpriteFrame_ctor, __jsb_cocos2d_SpriteFrame_class, js_cocos2d_SpriteFrame_finalize)


    


bool js_cocos2d_SpriteFrame_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::SpriteFrame)", s.nativeThisObject());
        cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_SpriteFrame_finalize)

bool js_register_cocos2dx_SpriteFrame(se::Object* obj)
{
    auto cls = se::Class::create("SpriteFrame", obj, nullptr, _SE(js_cocos2dx_SpriteFrame_constructor));

    cls->defineFunction("setAnchorPoint", _SE(js_cocos2dx_SpriteFrame_setAnchorPoint));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_SpriteFrame_setTexture));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_SpriteFrame_getTexture));
    cls->defineFunction("setOffsetInPixels", _SE(js_cocos2dx_SpriteFrame_setOffsetInPixels));
    cls->defineFunction("getOriginalSizeInPixels", _SE(js_cocos2dx_SpriteFrame_getOriginalSizeInPixels));
    cls->defineFunction("setOriginalSize", _SE(js_cocos2dx_SpriteFrame_setOriginalSize));
    cls->defineFunction("getCenterRect", _SE(js_cocos2dx_SpriteFrame_getCenterRect));
    cls->defineFunction("setRectInPixels", _SE(js_cocos2dx_SpriteFrame_setRectInPixels));
    cls->defineFunction("getRect", _SE(js_cocos2dx_SpriteFrame_getRect));
    cls->defineFunction("setCenterRectInPixels", _SE(js_cocos2dx_SpriteFrame_setCenterRectInPixels));
    cls->defineFunction("setOffset", _SE(js_cocos2dx_SpriteFrame_setOffset));
    cls->defineFunction("initWithTextureFilename", _SE(js_cocos2dx_SpriteFrame_initWithTextureFilename));
    cls->defineFunction("setRect", _SE(js_cocos2dx_SpriteFrame_setRect));
    cls->defineFunction("initWithTexture", _SE(js_cocos2dx_SpriteFrame_initWithTexture));
    cls->defineFunction("getOriginalSize", _SE(js_cocos2dx_SpriteFrame_getOriginalSize));
    cls->defineFunction("clone", _SE(js_cocos2dx_SpriteFrame_clone));
    cls->defineFunction("getRectInPixels", _SE(js_cocos2dx_SpriteFrame_getRectInPixels));
    cls->defineFunction("isRotated", _SE(js_cocos2dx_SpriteFrame_isRotated));
    cls->defineFunction("hasCenterRect", _SE(js_cocos2dx_SpriteFrame_hasCenterRect));
    cls->defineFunction("setRotated", _SE(js_cocos2dx_SpriteFrame_setRotated));
    cls->defineFunction("getOffset", _SE(js_cocos2dx_SpriteFrame_getOffset));
    cls->defineFunction("setOriginalSizeInPixels", _SE(js_cocos2dx_SpriteFrame_setOriginalSizeInPixels));
    cls->defineFunction("getAnchorPoint", _SE(js_cocos2dx_SpriteFrame_getAnchorPoint));
    cls->defineFunction("hasAnchorPoint", _SE(js_cocos2dx_SpriteFrame_hasAnchorPoint));
    cls->defineFunction("getOffsetInPixels", _SE(js_cocos2dx_SpriteFrame_getOffsetInPixels));
    cls->defineFunction("ctor", _SE(js_cocos2dx_SpriteFrame_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_SpriteFrame_create));
    cls->defineStaticFunction("createWithTexture", _SE(js_cocos2dx_SpriteFrame_createWithTexture));
    cls->defineFinalizedFunction(_SE(js_cocos2d_SpriteFrame_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::SpriteFrame>(cls);

    __jsb_cocos2d_SpriteFrame_proto = cls->getProto();
    __jsb_cocos2d_SpriteFrame_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.SpriteFrame.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_AnimationFrame_proto = nullptr;
se::Class* __jsb_cocos2d_AnimationFrame_class = nullptr;

static bool js_cocos2dx_AnimationFrame_setSpriteFrame(se::State& s)
{
    cocos2d::AnimationFrame* cobj = (cocos2d::AnimationFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationFrame_setSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationFrame_setSpriteFrame : Error processing arguments");
        cobj->setSpriteFrame(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationFrame_setSpriteFrame)

static bool js_cocos2dx_AnimationFrame_getUserInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::AnimationFrame* cobj = (cocos2d::AnimationFrame*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_AnimationFrame_getUserInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::ValueMap& result = cobj->getUserInfo();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationFrame_getUserInfo : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::ValueMap& result = cobj->getUserInfo();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationFrame_getUserInfo : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationFrame_getUserInfo)

static bool js_cocos2dx_AnimationFrame_setDelayUnits(se::State& s)
{
    cocos2d::AnimationFrame* cobj = (cocos2d::AnimationFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationFrame_setDelayUnits : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationFrame_setDelayUnits : Error processing arguments");
        cobj->setDelayUnits(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationFrame_setDelayUnits)

static bool js_cocos2dx_AnimationFrame_clone(se::State& s)
{
    cocos2d::AnimationFrame* cobj = (cocos2d::AnimationFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationFrame_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::AnimationFrame* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::AnimationFrame>((cocos2d::AnimationFrame*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationFrame_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationFrame_clone)

static bool js_cocos2dx_AnimationFrame_getSpriteFrame(se::State& s)
{
    cocos2d::AnimationFrame* cobj = (cocos2d::AnimationFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationFrame_getSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::SpriteFrame* result = cobj->getSpriteFrame();
        ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationFrame_getSpriteFrame : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationFrame_getSpriteFrame)

static bool js_cocos2dx_AnimationFrame_getDelayUnits(se::State& s)
{
    cocos2d::AnimationFrame* cobj = (cocos2d::AnimationFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationFrame_getDelayUnits : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getDelayUnits();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationFrame_getDelayUnits : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationFrame_getDelayUnits)

static bool js_cocos2dx_AnimationFrame_setUserInfo(se::State& s)
{
    cocos2d::AnimationFrame* cobj = (cocos2d::AnimationFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationFrame_setUserInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationFrame_setUserInfo : Error processing arguments");
        cobj->setUserInfo(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationFrame_setUserInfo)

static bool js_cocos2dx_AnimationFrame_initWithSpriteFrame(se::State& s)
{
    cocos2d::AnimationFrame* cobj = (cocos2d::AnimationFrame*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationFrame_initWithSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        float arg1 = 0;
        cocos2d::ValueMap arg2;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_ccvaluemap(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationFrame_initWithSpriteFrame : Error processing arguments");
        bool result = cobj->initWithSpriteFrame(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationFrame_initWithSpriteFrame : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationFrame_initWithSpriteFrame)

static bool js_cocos2dx_AnimationFrame_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        float arg1 = 0;
        cocos2d::ValueMap arg2;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_ccvaluemap(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationFrame_create : Error processing arguments");
        auto result = cocos2d::AnimationFrame::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_AnimationFrame_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationFrame_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_AnimationFrame_finalize)

static bool js_cocos2dx_AnimationFrame_constructor(se::State& s)
{
    cocos2d::AnimationFrame* cobj = new (std::nothrow) cocos2d::AnimationFrame();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_AnimationFrame_constructor, __jsb_cocos2d_AnimationFrame_class, js_cocos2d_AnimationFrame_finalize)

static bool js_cocos2dx_AnimationFrame_ctor(se::State& s)
{
    cocos2d::AnimationFrame* cobj = new (std::nothrow) cocos2d::AnimationFrame();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_AnimationFrame_ctor, __jsb_cocos2d_AnimationFrame_class, js_cocos2d_AnimationFrame_finalize)


    


bool js_cocos2d_AnimationFrame_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::AnimationFrame)", s.nativeThisObject());
        cocos2d::AnimationFrame* cobj = (cocos2d::AnimationFrame*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_AnimationFrame_finalize)

bool js_register_cocos2dx_AnimationFrame(se::Object* obj)
{
    auto cls = se::Class::create("AnimationFrame", obj, nullptr, _SE(js_cocos2dx_AnimationFrame_constructor));

    cls->defineFunction("setSpriteFrame", _SE(js_cocos2dx_AnimationFrame_setSpriteFrame));
    cls->defineFunction("getUserInfo", _SE(js_cocos2dx_AnimationFrame_getUserInfo));
    cls->defineFunction("setDelayUnits", _SE(js_cocos2dx_AnimationFrame_setDelayUnits));
    cls->defineFunction("clone", _SE(js_cocos2dx_AnimationFrame_clone));
    cls->defineFunction("getSpriteFrame", _SE(js_cocos2dx_AnimationFrame_getSpriteFrame));
    cls->defineFunction("getDelayUnits", _SE(js_cocos2dx_AnimationFrame_getDelayUnits));
    cls->defineFunction("setUserInfo", _SE(js_cocos2dx_AnimationFrame_setUserInfo));
    cls->defineFunction("initWithSpriteFrame", _SE(js_cocos2dx_AnimationFrame_initWithSpriteFrame));
    cls->defineFunction("ctor", _SE(js_cocos2dx_AnimationFrame_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_AnimationFrame_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_AnimationFrame_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::AnimationFrame>(cls);

    __jsb_cocos2d_AnimationFrame_proto = cls->getProto();
    __jsb_cocos2d_AnimationFrame_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.AnimationFrame.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Animation_proto = nullptr;
se::Class* __jsb_cocos2d_Animation_class = nullptr;

static bool js_cocos2dx_Animation_getLoops(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_getLoops : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getLoops();
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_getLoops : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_getLoops)

static bool js_cocos2dx_Animation_addSpriteFrame(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_addSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_addSpriteFrame : Error processing arguments");
        cobj->addSpriteFrame(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_addSpriteFrame)

static bool js_cocos2dx_Animation_setRestoreOriginalFrame(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_setRestoreOriginalFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_setRestoreOriginalFrame : Error processing arguments");
        cobj->setRestoreOriginalFrame(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_setRestoreOriginalFrame)

static bool js_cocos2dx_Animation_clone(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Animation* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::Animation>((cocos2d::Animation*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_clone)

static bool js_cocos2dx_Animation_getDuration(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_getDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getDuration();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_getDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_getDuration)

static bool js_cocos2dx_Animation_initWithAnimationFrames(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_initWithAnimationFrames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vector<cocos2d::AnimationFrame *> arg0;
        float arg1 = 0;
        unsigned int arg2 = 0;
        ok &= seval_to_Vector(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_initWithAnimationFrames : Error processing arguments");
        bool result = cobj->initWithAnimationFrames(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_initWithAnimationFrames : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_initWithAnimationFrames)

static bool js_cocos2dx_Animation_init(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_init)

static bool js_cocos2dx_Animation_setFrames(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_setFrames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::AnimationFrame *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_setFrames : Error processing arguments");
        cobj->setFrames(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_setFrames)

static bool js_cocos2dx_Animation_getFrames(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_getFrames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vector<cocos2d::AnimationFrame *>& result = cobj->getFrames();
        ok &= Vector_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_getFrames : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_getFrames)

static bool js_cocos2dx_Animation_setLoops(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_setLoops : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_setLoops : Error processing arguments");
        cobj->setLoops(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_setLoops)

static bool js_cocos2dx_Animation_setDelayPerUnit(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_setDelayPerUnit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_setDelayPerUnit : Error processing arguments");
        cobj->setDelayPerUnit(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_setDelayPerUnit)

static bool js_cocos2dx_Animation_addSpriteFrameWithFile(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_addSpriteFrameWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_addSpriteFrameWithFile : Error processing arguments");
        cobj->addSpriteFrameWithFile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_addSpriteFrameWithFile)

static bool js_cocos2dx_Animation_getTotalDelayUnits(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_getTotalDelayUnits : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getTotalDelayUnits();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_getTotalDelayUnits : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_getTotalDelayUnits)

static bool js_cocos2dx_Animation_getDelayPerUnit(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_getDelayPerUnit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getDelayPerUnit();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_getDelayPerUnit : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_getDelayPerUnit)

static bool js_cocos2dx_Animation_initWithSpriteFrames(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_initWithSpriteFrames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_initWithSpriteFrames : Error processing arguments");
        bool result = cobj->initWithSpriteFrames(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_initWithSpriteFrames : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
        float arg1 = 0;
        ok &= seval_to_Vector(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_initWithSpriteFrames : Error processing arguments");
        bool result = cobj->initWithSpriteFrames(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_initWithSpriteFrames : Error processing arguments");
        return true;
    }
    if (argc == 3) {
        cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
        float arg1 = 0;
        unsigned int arg2 = 0;
        ok &= seval_to_Vector(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_initWithSpriteFrames : Error processing arguments");
        bool result = cobj->initWithSpriteFrames(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_initWithSpriteFrames : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_initWithSpriteFrames)

static bool js_cocos2dx_Animation_getRestoreOriginalFrame(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_getRestoreOriginalFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->getRestoreOriginalFrame();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_getRestoreOriginalFrame : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_getRestoreOriginalFrame)

static bool js_cocos2dx_Animation_addSpriteFrameWithTexture(se::State& s)
{
    cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animation_addSpriteFrameWithTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Texture2D* arg0 = nullptr;
        cocos2d::Rect arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_Rect(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_addSpriteFrameWithTexture : Error processing arguments");
        cobj->addSpriteFrameWithTexture(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_addSpriteFrameWithTexture)

static bool js_cocos2dx_Animation_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Vector<cocos2d::AnimationFrame *> arg0;
            ok &= seval_to_Vector(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Animation* result = cocos2d::Animation::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::Animation>((cocos2d::Animation*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            cocos2d::Vector<cocos2d::AnimationFrame *> arg0;
            ok &= seval_to_Vector(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            unsigned int arg2 = 0;
            ok &= seval_to_uint32(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Animation* result = cocos2d::Animation::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::Animation>((cocos2d::Animation*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 0) {
            cocos2d::Animation* result = cocos2d::Animation::create();
            ok &= native_ptr_to_seval<cocos2d::Animation>((cocos2d::Animation*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_create)

static bool js_cocos2dx_Animation_createWithSpriteFrames(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_createWithSpriteFrames : Error processing arguments");
        auto result = cocos2d::Animation::createWithSpriteFrames(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Animation_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
        float arg1 = 0;
        ok &= seval_to_Vector(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_createWithSpriteFrames : Error processing arguments");
        auto result = cocos2d::Animation::createWithSpriteFrames(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Animation_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 3) {
        cocos2d::Vector<cocos2d::SpriteFrame *> arg0;
        float arg1 = 0;
        unsigned int arg2 = 0;
        ok &= seval_to_Vector(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animation_createWithSpriteFrames : Error processing arguments");
        auto result = cocos2d::Animation::createWithSpriteFrames(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Animation_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animation_createWithSpriteFrames)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Animation_finalize)

static bool js_cocos2dx_Animation_constructor(se::State& s)
{
    cocos2d::Animation* cobj = new (std::nothrow) cocos2d::Animation();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Animation_constructor, __jsb_cocos2d_Animation_class, js_cocos2d_Animation_finalize)

static bool js_cocos2dx_Animation_ctor(se::State& s)
{
    cocos2d::Animation* cobj = new (std::nothrow) cocos2d::Animation();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Animation_ctor, __jsb_cocos2d_Animation_class, js_cocos2d_Animation_finalize)


    


bool js_cocos2d_Animation_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Animation)", s.nativeThisObject());
        cocos2d::Animation* cobj = (cocos2d::Animation*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Animation_finalize)

bool js_register_cocos2dx_Animation(se::Object* obj)
{
    auto cls = se::Class::create("Animation", obj, nullptr, _SE(js_cocos2dx_Animation_constructor));

    cls->defineFunction("getLoops", _SE(js_cocos2dx_Animation_getLoops));
    cls->defineFunction("addSpriteFrame", _SE(js_cocos2dx_Animation_addSpriteFrame));
    cls->defineFunction("setRestoreOriginalFrame", _SE(js_cocos2dx_Animation_setRestoreOriginalFrame));
    cls->defineFunction("clone", _SE(js_cocos2dx_Animation_clone));
    cls->defineFunction("getDuration", _SE(js_cocos2dx_Animation_getDuration));
    cls->defineFunction("initWithAnimationFrames", _SE(js_cocos2dx_Animation_initWithAnimationFrames));
    cls->defineFunction("init", _SE(js_cocos2dx_Animation_init));
    cls->defineFunction("setFrames", _SE(js_cocos2dx_Animation_setFrames));
    cls->defineFunction("getFrames", _SE(js_cocos2dx_Animation_getFrames));
    cls->defineFunction("setLoops", _SE(js_cocos2dx_Animation_setLoops));
    cls->defineFunction("setDelayPerUnit", _SE(js_cocos2dx_Animation_setDelayPerUnit));
    cls->defineFunction("addSpriteFrameWithFile", _SE(js_cocos2dx_Animation_addSpriteFrameWithFile));
    cls->defineFunction("getTotalDelayUnits", _SE(js_cocos2dx_Animation_getTotalDelayUnits));
    cls->defineFunction("getDelayPerUnit", _SE(js_cocos2dx_Animation_getDelayPerUnit));
    cls->defineFunction("initWithSpriteFrames", _SE(js_cocos2dx_Animation_initWithSpriteFrames));
    cls->defineFunction("getRestoreOriginalFrame", _SE(js_cocos2dx_Animation_getRestoreOriginalFrame));
    cls->defineFunction("addSpriteFrameWithTexture", _SE(js_cocos2dx_Animation_addSpriteFrameWithTexture));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Animation_ctor));
    cls->defineStaticFunction("createWithAnimationFrames", _SE(js_cocos2dx_Animation_create));
    cls->defineStaticFunction("createWithSpriteFrames", _SE(js_cocos2dx_Animation_createWithSpriteFrames));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Animation_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Animation>(cls);

    __jsb_cocos2d_Animation_proto = cls->getProto();
    __jsb_cocos2d_Animation_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Animation.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ActionInterval_proto = nullptr;
se::Class* __jsb_cocos2d_ActionInterval_class = nullptr;

static bool js_cocos2dx_ActionInterval_getAmplitudeRate(se::State& s)
{
    cocos2d::ActionInterval* cobj = (cocos2d::ActionInterval*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionInterval_getAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitudeRate();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionInterval_getAmplitudeRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionInterval_getAmplitudeRate)

static bool js_cocos2dx_ActionInterval_initWithDuration(se::State& s)
{
    cocos2d::ActionInterval* cobj = (cocos2d::ActionInterval*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionInterval_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionInterval_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionInterval_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionInterval_initWithDuration)

static bool js_cocos2dx_ActionInterval_setAmplitudeRate(se::State& s)
{
    cocos2d::ActionInterval* cobj = (cocos2d::ActionInterval*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionInterval_setAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionInterval_setAmplitudeRate : Error processing arguments");
        cobj->setAmplitudeRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionInterval_setAmplitudeRate)

static bool js_cocos2dx_ActionInterval_getElapsed(se::State& s)
{
    cocos2d::ActionInterval* cobj = (cocos2d::ActionInterval*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionInterval_getElapsed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getElapsed();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionInterval_getElapsed : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionInterval_getElapsed)


extern se::Object* __jsb_cocos2d_FiniteTimeAction_proto;


bool js_register_cocos2dx_ActionInterval(se::Object* obj)
{
    auto cls = se::Class::create("ActionInterval", obj, __jsb_cocos2d_FiniteTimeAction_proto, nullptr);

    cls->defineFunction("getAmplitudeRate", _SE(js_cocos2dx_ActionInterval_getAmplitudeRate));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_ActionInterval_initWithDuration));
    cls->defineFunction("setAmplitudeRate", _SE(js_cocos2dx_ActionInterval_setAmplitudeRate));
    cls->defineFunction("getElapsed", _SE(js_cocos2dx_ActionInterval_getElapsed));
    cls->install();
    JSBClassType::registerClass<cocos2d::ActionInterval>(cls);

    __jsb_cocos2d_ActionInterval_proto = cls->getProto();
    __jsb_cocos2d_ActionInterval_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Sequence_proto = nullptr;
se::Class* __jsb_cocos2d_Sequence_class = nullptr;

static bool js_cocos2dx_Sequence_init(se::State& s)
{
    cocos2d::Sequence* cobj = (cocos2d::Sequence*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sequence_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::FiniteTimeAction *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sequence_init : Error processing arguments");
        bool result = cobj->init(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sequence_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sequence_init)

static bool js_cocos2dx_Sequence_initWithTwoActions(se::State& s)
{
    cocos2d::Sequence* cobj = (cocos2d::Sequence*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sequence_initWithTwoActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        cocos2d::FiniteTimeAction* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sequence_initWithTwoActions : Error processing arguments");
        bool result = cobj->initWithTwoActions(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sequence_initWithTwoActions : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sequence_initWithTwoActions)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Sequence_finalize)

static bool js_cocos2dx_Sequence_constructor(se::State& s)
{
    cocos2d::Sequence* cobj = new (std::nothrow) cocos2d::Sequence();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Sequence_constructor, __jsb_cocos2d_Sequence_class, js_cocos2d_Sequence_finalize)

static bool js_cocos2dx_Sequence_ctor(se::State& s)
{
    cocos2d::Sequence* cobj = new (std::nothrow) cocos2d::Sequence();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Sequence_ctor, __jsb_cocos2d_Sequence_class, js_cocos2d_Sequence_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_Sequence_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Sequence)", s.nativeThisObject());
        cocos2d::Sequence* cobj = (cocos2d::Sequence*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Sequence_finalize)

bool js_register_cocos2dx_Sequence(se::Object* obj)
{
    auto cls = se::Class::create("Sequence", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_Sequence_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_Sequence_init));
    cls->defineFunction("initWithTwoActions", _SE(js_cocos2dx_Sequence_initWithTwoActions));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Sequence_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Sequence_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Sequence>(cls);

    __jsb_cocos2d_Sequence_proto = cls->getProto();
    __jsb_cocos2d_Sequence_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Sequence.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Repeat_proto = nullptr;
se::Class* __jsb_cocos2d_Repeat_class = nullptr;

static bool js_cocos2dx_Repeat_setInnerAction(se::State& s)
{
    cocos2d::Repeat* cobj = (cocos2d::Repeat*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Repeat_setInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Repeat_setInnerAction : Error processing arguments");
        cobj->setInnerAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Repeat_setInnerAction)

static bool js_cocos2dx_Repeat_initWithAction(se::State& s)
{
    cocos2d::Repeat* cobj = (cocos2d::Repeat*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Repeat_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        unsigned int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Repeat_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Repeat_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Repeat_initWithAction)

static bool js_cocos2dx_Repeat_getInnerAction(se::State& s)
{
    cocos2d::Repeat* cobj = (cocos2d::Repeat*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Repeat_getInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::FiniteTimeAction* result = cobj->getInnerAction();
        ok &= native_ptr_to_seval<cocos2d::FiniteTimeAction>((cocos2d::FiniteTimeAction*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Repeat_getInnerAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Repeat_getInnerAction)

static bool js_cocos2dx_Repeat_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        unsigned int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Repeat_create : Error processing arguments");
        auto result = cocos2d::Repeat::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Repeat_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Repeat_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Repeat_finalize)

static bool js_cocos2dx_Repeat_constructor(se::State& s)
{
    cocos2d::Repeat* cobj = new (std::nothrow) cocos2d::Repeat();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Repeat_constructor, __jsb_cocos2d_Repeat_class, js_cocos2d_Repeat_finalize)

static bool js_cocos2dx_Repeat_ctor(se::State& s)
{
    cocos2d::Repeat* cobj = new (std::nothrow) cocos2d::Repeat();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Repeat_ctor, __jsb_cocos2d_Repeat_class, js_cocos2d_Repeat_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_Repeat_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Repeat)", s.nativeThisObject());
        cocos2d::Repeat* cobj = (cocos2d::Repeat*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Repeat_finalize)

bool js_register_cocos2dx_Repeat(se::Object* obj)
{
    auto cls = se::Class::create("Repeat", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_Repeat_constructor));

    cls->defineFunction("setInnerAction", _SE(js_cocos2dx_Repeat_setInnerAction));
    cls->defineFunction("initWithAction", _SE(js_cocos2dx_Repeat_initWithAction));
    cls->defineFunction("getInnerAction", _SE(js_cocos2dx_Repeat_getInnerAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Repeat_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Repeat_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Repeat_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Repeat>(cls);

    __jsb_cocos2d_Repeat_proto = cls->getProto();
    __jsb_cocos2d_Repeat_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Repeat.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_RepeatForever_proto = nullptr;
se::Class* __jsb_cocos2d_RepeatForever_class = nullptr;

static bool js_cocos2dx_RepeatForever_setInnerAction(se::State& s)
{
    cocos2d::RepeatForever* cobj = (cocos2d::RepeatForever*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RepeatForever_setInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RepeatForever_setInnerAction : Error processing arguments");
        cobj->setInnerAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RepeatForever_setInnerAction)

static bool js_cocos2dx_RepeatForever_initWithAction(se::State& s)
{
    cocos2d::RepeatForever* cobj = (cocos2d::RepeatForever*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RepeatForever_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RepeatForever_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RepeatForever_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RepeatForever_initWithAction)

static bool js_cocos2dx_RepeatForever_getInnerAction(se::State& s)
{
    cocos2d::RepeatForever* cobj = (cocos2d::RepeatForever*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RepeatForever_getInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ActionInterval* result = cobj->getInnerAction();
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RepeatForever_getInnerAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RepeatForever_getInnerAction)

static bool js_cocos2dx_RepeatForever_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RepeatForever_create : Error processing arguments");
        auto result = cocos2d::RepeatForever::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_RepeatForever_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RepeatForever_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_RepeatForever_finalize)

static bool js_cocos2dx_RepeatForever_constructor(se::State& s)
{
    cocos2d::RepeatForever* cobj = new (std::nothrow) cocos2d::RepeatForever();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_RepeatForever_constructor, __jsb_cocos2d_RepeatForever_class, js_cocos2d_RepeatForever_finalize)

static bool js_cocos2dx_RepeatForever_ctor(se::State& s)
{
    cocos2d::RepeatForever* cobj = new (std::nothrow) cocos2d::RepeatForever();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_RepeatForever_ctor, __jsb_cocos2d_RepeatForever_class, js_cocos2d_RepeatForever_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_RepeatForever_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::RepeatForever)", s.nativeThisObject());
        cocos2d::RepeatForever* cobj = (cocos2d::RepeatForever*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_RepeatForever_finalize)

bool js_register_cocos2dx_RepeatForever(se::Object* obj)
{
    auto cls = se::Class::create("RepeatForever", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_RepeatForever_constructor));

    cls->defineFunction("setInnerAction", _SE(js_cocos2dx_RepeatForever_setInnerAction));
    cls->defineFunction("initWithAction", _SE(js_cocos2dx_RepeatForever_initWithAction));
    cls->defineFunction("getInnerAction", _SE(js_cocos2dx_RepeatForever_getInnerAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_RepeatForever_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_RepeatForever_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_RepeatForever_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::RepeatForever>(cls);

    __jsb_cocos2d_RepeatForever_proto = cls->getProto();
    __jsb_cocos2d_RepeatForever_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.RepeatForever.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Spawn_proto = nullptr;
se::Class* __jsb_cocos2d_Spawn_class = nullptr;

static bool js_cocos2dx_Spawn_init(se::State& s)
{
    cocos2d::Spawn* cobj = (cocos2d::Spawn*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Spawn_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::FiniteTimeAction *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Spawn_init : Error processing arguments");
        bool result = cobj->init(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Spawn_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Spawn_init)

static bool js_cocos2dx_Spawn_initWithTwoActions(se::State& s)
{
    cocos2d::Spawn* cobj = (cocos2d::Spawn*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Spawn_initWithTwoActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        cocos2d::FiniteTimeAction* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Spawn_initWithTwoActions : Error processing arguments");
        bool result = cobj->initWithTwoActions(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Spawn_initWithTwoActions : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Spawn_initWithTwoActions)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Spawn_finalize)

static bool js_cocos2dx_Spawn_constructor(se::State& s)
{
    cocos2d::Spawn* cobj = new (std::nothrow) cocos2d::Spawn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Spawn_constructor, __jsb_cocos2d_Spawn_class, js_cocos2d_Spawn_finalize)

static bool js_cocos2dx_Spawn_ctor(se::State& s)
{
    cocos2d::Spawn* cobj = new (std::nothrow) cocos2d::Spawn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Spawn_ctor, __jsb_cocos2d_Spawn_class, js_cocos2d_Spawn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_Spawn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Spawn)", s.nativeThisObject());
        cocos2d::Spawn* cobj = (cocos2d::Spawn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Spawn_finalize)

bool js_register_cocos2dx_Spawn(se::Object* obj)
{
    auto cls = se::Class::create("Spawn", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_Spawn_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_Spawn_init));
    cls->defineFunction("initWithTwoActions", _SE(js_cocos2dx_Spawn_initWithTwoActions));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Spawn_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Spawn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Spawn>(cls);

    __jsb_cocos2d_Spawn_proto = cls->getProto();
    __jsb_cocos2d_Spawn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Spawn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_RotateTo_proto = nullptr;
se::Class* __jsb_cocos2d_RotateTo_class = nullptr;

static bool js_cocos2dx_RotateTo_initWithDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::RotateTo* cobj = (cocos2d::RotateTo*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_RotateTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RotateTo_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RotateTo_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RotateTo_initWithDuration)

static bool js_cocos2dx_RotateTo_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::RotateTo* result = cocos2d::RotateTo::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::RotateTo>((cocos2d::RotateTo*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RotateTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::RotateTo* result = cocos2d::RotateTo::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::RotateTo>((cocos2d::RotateTo*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RotateTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::RotateTo* result = cocos2d::RotateTo::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::RotateTo>((cocos2d::RotateTo*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RotateTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RotateTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_RotateTo_finalize)

static bool js_cocos2dx_RotateTo_constructor(se::State& s)
{
    cocos2d::RotateTo* cobj = new (std::nothrow) cocos2d::RotateTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_RotateTo_constructor, __jsb_cocos2d_RotateTo_class, js_cocos2d_RotateTo_finalize)

static bool js_cocos2dx_RotateTo_ctor(se::State& s)
{
    cocos2d::RotateTo* cobj = new (std::nothrow) cocos2d::RotateTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_RotateTo_ctor, __jsb_cocos2d_RotateTo_class, js_cocos2d_RotateTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_RotateTo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::RotateTo)", s.nativeThisObject());
        cocos2d::RotateTo* cobj = (cocos2d::RotateTo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_RotateTo_finalize)

bool js_register_cocos2dx_RotateTo(se::Object* obj)
{
    auto cls = se::Class::create("RotateTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_RotateTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_RotateTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_RotateTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_RotateTo_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_RotateTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::RotateTo>(cls);

    __jsb_cocos2d_RotateTo_proto = cls->getProto();
    __jsb_cocos2d_RotateTo_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.RotateTo.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_RotateBy_proto = nullptr;
se::Class* __jsb_cocos2d_RotateBy_class = nullptr;

static bool js_cocos2dx_RotateBy_initWithDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::RotateBy* cobj = (cocos2d::RotateBy*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_RotateBy_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RotateBy_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RotateBy_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RotateBy_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RotateBy_initWithDuration)

static bool js_cocos2dx_RotateBy_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::RotateBy* result = cocos2d::RotateBy::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::RotateBy>((cocos2d::RotateBy*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RotateBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::RotateBy* result = cocos2d::RotateBy::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::RotateBy>((cocos2d::RotateBy*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RotateBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::RotateBy* result = cocos2d::RotateBy::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::RotateBy>((cocos2d::RotateBy*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RotateBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RotateBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_RotateBy_finalize)

static bool js_cocos2dx_RotateBy_constructor(se::State& s)
{
    cocos2d::RotateBy* cobj = new (std::nothrow) cocos2d::RotateBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_RotateBy_constructor, __jsb_cocos2d_RotateBy_class, js_cocos2d_RotateBy_finalize)

static bool js_cocos2dx_RotateBy_ctor(se::State& s)
{
    cocos2d::RotateBy* cobj = new (std::nothrow) cocos2d::RotateBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_RotateBy_ctor, __jsb_cocos2d_RotateBy_class, js_cocos2d_RotateBy_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_RotateBy_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::RotateBy)", s.nativeThisObject());
        cocos2d::RotateBy* cobj = (cocos2d::RotateBy*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_RotateBy_finalize)

bool js_register_cocos2dx_RotateBy(se::Object* obj)
{
    auto cls = se::Class::create("RotateBy", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_RotateBy_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_RotateBy_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_RotateBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_RotateBy_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_RotateBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::RotateBy>(cls);

    __jsb_cocos2d_RotateBy_proto = cls->getProto();
    __jsb_cocos2d_RotateBy_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.RotateBy.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_MoveBy_proto = nullptr;
se::Class* __jsb_cocos2d_MoveBy_class = nullptr;

static bool js_cocos2dx_MoveBy_initWithDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::MoveBy* cobj = (cocos2d::MoveBy*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_MoveBy_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MoveBy_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MoveBy_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MoveBy_initWithDuration)

static bool js_cocos2dx_MoveBy_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::MoveBy* result = cocos2d::MoveBy::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::MoveBy>((cocos2d::MoveBy*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MoveBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::MoveBy* result = cocos2d::MoveBy::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::MoveBy>((cocos2d::MoveBy*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MoveBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MoveBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MoveBy_finalize)

static bool js_cocos2dx_MoveBy_constructor(se::State& s)
{
    cocos2d::MoveBy* cobj = new (std::nothrow) cocos2d::MoveBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MoveBy_constructor, __jsb_cocos2d_MoveBy_class, js_cocos2d_MoveBy_finalize)

static bool js_cocos2dx_MoveBy_ctor(se::State& s)
{
    cocos2d::MoveBy* cobj = new (std::nothrow) cocos2d::MoveBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MoveBy_ctor, __jsb_cocos2d_MoveBy_class, js_cocos2d_MoveBy_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_MoveBy_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::MoveBy)", s.nativeThisObject());
        cocos2d::MoveBy* cobj = (cocos2d::MoveBy*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MoveBy_finalize)

bool js_register_cocos2dx_MoveBy(se::Object* obj)
{
    auto cls = se::Class::create("MoveBy", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_MoveBy_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_MoveBy_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MoveBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_MoveBy_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_MoveBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MoveBy>(cls);

    __jsb_cocos2d_MoveBy_proto = cls->getProto();
    __jsb_cocos2d_MoveBy_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.MoveBy.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_MoveTo_proto = nullptr;
se::Class* __jsb_cocos2d_MoveTo_class = nullptr;

static bool js_cocos2dx_MoveTo_initWithDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::MoveTo* cobj = (cocos2d::MoveTo*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_MoveTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MoveTo_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MoveTo_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MoveTo_initWithDuration)

static bool js_cocos2dx_MoveTo_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::MoveTo* result = cocos2d::MoveTo::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::MoveTo>((cocos2d::MoveTo*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MoveTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::MoveTo* result = cocos2d::MoveTo::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::MoveTo>((cocos2d::MoveTo*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MoveTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MoveTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MoveTo_finalize)

static bool js_cocos2dx_MoveTo_constructor(se::State& s)
{
    cocos2d::MoveTo* cobj = new (std::nothrow) cocos2d::MoveTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MoveTo_constructor, __jsb_cocos2d_MoveTo_class, js_cocos2d_MoveTo_finalize)

static bool js_cocos2dx_MoveTo_ctor(se::State& s)
{
    cocos2d::MoveTo* cobj = new (std::nothrow) cocos2d::MoveTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MoveTo_ctor, __jsb_cocos2d_MoveTo_class, js_cocos2d_MoveTo_finalize)


    

extern se::Object* __jsb_cocos2d_MoveBy_proto;

bool js_cocos2d_MoveTo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::MoveTo)", s.nativeThisObject());
        cocos2d::MoveTo* cobj = (cocos2d::MoveTo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MoveTo_finalize)

bool js_register_cocos2dx_MoveTo(se::Object* obj)
{
    auto cls = se::Class::create("MoveTo", obj, __jsb_cocos2d_MoveBy_proto, _SE(js_cocos2dx_MoveTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_MoveTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MoveTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_MoveTo_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_MoveTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MoveTo>(cls);

    __jsb_cocos2d_MoveTo_proto = cls->getProto();
    __jsb_cocos2d_MoveTo_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.MoveTo.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_SkewTo_proto = nullptr;
se::Class* __jsb_cocos2d_SkewTo_class = nullptr;

static bool js_cocos2dx_SkewTo_initWithDuration(se::State& s)
{
    cocos2d::SkewTo* cobj = (cocos2d::SkewTo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SkewTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SkewTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SkewTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SkewTo_initWithDuration)

static bool js_cocos2dx_SkewTo_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SkewTo_create : Error processing arguments");
        auto result = cocos2d::SkewTo::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SkewTo_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SkewTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_SkewTo_finalize)

static bool js_cocos2dx_SkewTo_constructor(se::State& s)
{
    cocos2d::SkewTo* cobj = new (std::nothrow) cocos2d::SkewTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_SkewTo_constructor, __jsb_cocos2d_SkewTo_class, js_cocos2d_SkewTo_finalize)

static bool js_cocos2dx_SkewTo_ctor(se::State& s)
{
    cocos2d::SkewTo* cobj = new (std::nothrow) cocos2d::SkewTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_SkewTo_ctor, __jsb_cocos2d_SkewTo_class, js_cocos2d_SkewTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_SkewTo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::SkewTo)", s.nativeThisObject());
        cocos2d::SkewTo* cobj = (cocos2d::SkewTo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_SkewTo_finalize)

bool js_register_cocos2dx_SkewTo(se::Object* obj)
{
    auto cls = se::Class::create("SkewTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_SkewTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_SkewTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_SkewTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_SkewTo_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_SkewTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::SkewTo>(cls);

    __jsb_cocos2d_SkewTo_proto = cls->getProto();
    __jsb_cocos2d_SkewTo_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.SkewTo.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_SkewBy_proto = nullptr;
se::Class* __jsb_cocos2d_SkewBy_class = nullptr;

static bool js_cocos2dx_SkewBy_initWithDuration(se::State& s)
{
    cocos2d::SkewBy* cobj = (cocos2d::SkewBy*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SkewBy_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SkewBy_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SkewBy_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SkewBy_initWithDuration)

static bool js_cocos2dx_SkewBy_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SkewBy_create : Error processing arguments");
        auto result = cocos2d::SkewBy::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SkewBy_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SkewBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_SkewBy_finalize)

static bool js_cocos2dx_SkewBy_constructor(se::State& s)
{
    cocos2d::SkewBy* cobj = new (std::nothrow) cocos2d::SkewBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_SkewBy_constructor, __jsb_cocos2d_SkewBy_class, js_cocos2d_SkewBy_finalize)

static bool js_cocos2dx_SkewBy_ctor(se::State& s)
{
    cocos2d::SkewBy* cobj = new (std::nothrow) cocos2d::SkewBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_SkewBy_ctor, __jsb_cocos2d_SkewBy_class, js_cocos2d_SkewBy_finalize)


    

extern se::Object* __jsb_cocos2d_SkewTo_proto;

bool js_cocos2d_SkewBy_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::SkewBy)", s.nativeThisObject());
        cocos2d::SkewBy* cobj = (cocos2d::SkewBy*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_SkewBy_finalize)

bool js_register_cocos2dx_SkewBy(se::Object* obj)
{
    auto cls = se::Class::create("SkewBy", obj, __jsb_cocos2d_SkewTo_proto, _SE(js_cocos2dx_SkewBy_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_SkewBy_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_SkewBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_SkewBy_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_SkewBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::SkewBy>(cls);

    __jsb_cocos2d_SkewBy_proto = cls->getProto();
    __jsb_cocos2d_SkewBy_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.SkewBy.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_JumpBy_proto = nullptr;
se::Class* __jsb_cocos2d_JumpBy_class = nullptr;

static bool js_cocos2dx_JumpBy_initWithDuration(se::State& s)
{
    cocos2d::JumpBy* cobj = (cocos2d::JumpBy*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_JumpBy_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        float arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpBy_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpBy_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpBy_initWithDuration)

static bool js_cocos2dx_JumpBy_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        float arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpBy_create : Error processing arguments");
        auto result = cocos2d::JumpBy::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_JumpBy_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_JumpBy_finalize)

static bool js_cocos2dx_JumpBy_constructor(se::State& s)
{
    cocos2d::JumpBy* cobj = new (std::nothrow) cocos2d::JumpBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_JumpBy_constructor, __jsb_cocos2d_JumpBy_class, js_cocos2d_JumpBy_finalize)

static bool js_cocos2dx_JumpBy_ctor(se::State& s)
{
    cocos2d::JumpBy* cobj = new (std::nothrow) cocos2d::JumpBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_JumpBy_ctor, __jsb_cocos2d_JumpBy_class, js_cocos2d_JumpBy_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_JumpBy_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::JumpBy)", s.nativeThisObject());
        cocos2d::JumpBy* cobj = (cocos2d::JumpBy*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_JumpBy_finalize)

bool js_register_cocos2dx_JumpBy(se::Object* obj)
{
    auto cls = se::Class::create("JumpBy", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_JumpBy_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_JumpBy_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_JumpBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_JumpBy_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_JumpBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::JumpBy>(cls);

    __jsb_cocos2d_JumpBy_proto = cls->getProto();
    __jsb_cocos2d_JumpBy_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.JumpBy.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_JumpTo_proto = nullptr;
se::Class* __jsb_cocos2d_JumpTo_class = nullptr;

static bool js_cocos2dx_JumpTo_initWithDuration(se::State& s)
{
    cocos2d::JumpTo* cobj = (cocos2d::JumpTo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_JumpTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        float arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpTo_initWithDuration)

static bool js_cocos2dx_JumpTo_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        float arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpTo_create : Error processing arguments");
        auto result = cocos2d::JumpTo::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_JumpTo_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_JumpTo_finalize)

static bool js_cocos2dx_JumpTo_constructor(se::State& s)
{
    cocos2d::JumpTo* cobj = new (std::nothrow) cocos2d::JumpTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_JumpTo_constructor, __jsb_cocos2d_JumpTo_class, js_cocos2d_JumpTo_finalize)

static bool js_cocos2dx_JumpTo_ctor(se::State& s)
{
    cocos2d::JumpTo* cobj = new (std::nothrow) cocos2d::JumpTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_JumpTo_ctor, __jsb_cocos2d_JumpTo_class, js_cocos2d_JumpTo_finalize)


    

extern se::Object* __jsb_cocos2d_JumpBy_proto;

bool js_cocos2d_JumpTo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::JumpTo)", s.nativeThisObject());
        cocos2d::JumpTo* cobj = (cocos2d::JumpTo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_JumpTo_finalize)

bool js_register_cocos2dx_JumpTo(se::Object* obj)
{
    auto cls = se::Class::create("JumpTo", obj, __jsb_cocos2d_JumpBy_proto, _SE(js_cocos2dx_JumpTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_JumpTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_JumpTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_JumpTo_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_JumpTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::JumpTo>(cls);

    __jsb_cocos2d_JumpTo_proto = cls->getProto();
    __jsb_cocos2d_JumpTo_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.JumpTo.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_BezierBy_proto = nullptr;
se::Class* __jsb_cocos2d_BezierBy_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_BezierBy_finalize)

static bool js_cocos2dx_BezierBy_constructor(se::State& s)
{
    cocos2d::BezierBy* cobj = new (std::nothrow) cocos2d::BezierBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_BezierBy_constructor, __jsb_cocos2d_BezierBy_class, js_cocos2d_BezierBy_finalize)

static bool js_cocos2dx_BezierBy_ctor(se::State& s)
{
    cocos2d::BezierBy* cobj = new (std::nothrow) cocos2d::BezierBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_BezierBy_ctor, __jsb_cocos2d_BezierBy_class, js_cocos2d_BezierBy_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_BezierBy_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::BezierBy)", s.nativeThisObject());
        cocos2d::BezierBy* cobj = (cocos2d::BezierBy*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_BezierBy_finalize)

bool js_register_cocos2dx_BezierBy(se::Object* obj)
{
    auto cls = se::Class::create("BezierBy", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_BezierBy_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_BezierBy_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_BezierBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::BezierBy>(cls);

    __jsb_cocos2d_BezierBy_proto = cls->getProto();
    __jsb_cocos2d_BezierBy_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.BezierBy.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_BezierTo_proto = nullptr;
se::Class* __jsb_cocos2d_BezierTo_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_BezierTo_finalize)

static bool js_cocos2dx_BezierTo_constructor(se::State& s)
{
    cocos2d::BezierTo* cobj = new (std::nothrow) cocos2d::BezierTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_BezierTo_constructor, __jsb_cocos2d_BezierTo_class, js_cocos2d_BezierTo_finalize)

static bool js_cocos2dx_BezierTo_ctor(se::State& s)
{
    cocos2d::BezierTo* cobj = new (std::nothrow) cocos2d::BezierTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_BezierTo_ctor, __jsb_cocos2d_BezierTo_class, js_cocos2d_BezierTo_finalize)


    

extern se::Object* __jsb_cocos2d_BezierBy_proto;

bool js_cocos2d_BezierTo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::BezierTo)", s.nativeThisObject());
        cocos2d::BezierTo* cobj = (cocos2d::BezierTo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_BezierTo_finalize)

bool js_register_cocos2dx_BezierTo(se::Object* obj)
{
    auto cls = se::Class::create("BezierTo", obj, __jsb_cocos2d_BezierBy_proto, _SE(js_cocos2dx_BezierTo_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_BezierTo_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_BezierTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::BezierTo>(cls);

    __jsb_cocos2d_BezierTo_proto = cls->getProto();
    __jsb_cocos2d_BezierTo_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.BezierTo.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ScaleTo_proto = nullptr;
se::Class* __jsb_cocos2d_ScaleTo_class = nullptr;

static bool js_cocos2dx_ScaleTo_initWithDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::ScaleTo* cobj = (cocos2d::ScaleTo*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_ScaleTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ScaleTo_initWithDuration)

static bool js_cocos2dx_ScaleTo_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleTo* result = cocos2d::ScaleTo::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::ScaleTo>((cocos2d::ScaleTo*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleTo* result = cocos2d::ScaleTo::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::ScaleTo>((cocos2d::ScaleTo*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleTo* result = cocos2d::ScaleTo::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::ScaleTo>((cocos2d::ScaleTo*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ScaleTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ScaleTo_finalize)

static bool js_cocos2dx_ScaleTo_constructor(se::State& s)
{
    cocos2d::ScaleTo* cobj = new (std::nothrow) cocos2d::ScaleTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ScaleTo_constructor, __jsb_cocos2d_ScaleTo_class, js_cocos2d_ScaleTo_finalize)

static bool js_cocos2dx_ScaleTo_ctor(se::State& s)
{
    cocos2d::ScaleTo* cobj = new (std::nothrow) cocos2d::ScaleTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ScaleTo_ctor, __jsb_cocos2d_ScaleTo_class, js_cocos2d_ScaleTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_ScaleTo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ScaleTo)", s.nativeThisObject());
        cocos2d::ScaleTo* cobj = (cocos2d::ScaleTo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ScaleTo_finalize)

bool js_register_cocos2dx_ScaleTo(se::Object* obj)
{
    auto cls = se::Class::create("ScaleTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_ScaleTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_ScaleTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ScaleTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ScaleTo_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ScaleTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ScaleTo>(cls);

    __jsb_cocos2d_ScaleTo_proto = cls->getProto();
    __jsb_cocos2d_ScaleTo_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ScaleTo.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ScaleBy_proto = nullptr;
se::Class* __jsb_cocos2d_ScaleBy_class = nullptr;

static bool js_cocos2dx_ScaleBy_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleBy* result = cocos2d::ScaleBy::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::ScaleBy>((cocos2d::ScaleBy*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ScaleBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleBy* result = cocos2d::ScaleBy::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::ScaleBy>((cocos2d::ScaleBy*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ScaleBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleBy* result = cocos2d::ScaleBy::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::ScaleBy>((cocos2d::ScaleBy*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ScaleBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ScaleBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ScaleBy_finalize)

static bool js_cocos2dx_ScaleBy_constructor(se::State& s)
{
    cocos2d::ScaleBy* cobj = new (std::nothrow) cocos2d::ScaleBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ScaleBy_constructor, __jsb_cocos2d_ScaleBy_class, js_cocos2d_ScaleBy_finalize)

static bool js_cocos2dx_ScaleBy_ctor(se::State& s)
{
    cocos2d::ScaleBy* cobj = new (std::nothrow) cocos2d::ScaleBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ScaleBy_ctor, __jsb_cocos2d_ScaleBy_class, js_cocos2d_ScaleBy_finalize)


    

extern se::Object* __jsb_cocos2d_ScaleTo_proto;

bool js_cocos2d_ScaleBy_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ScaleBy)", s.nativeThisObject());
        cocos2d::ScaleBy* cobj = (cocos2d::ScaleBy*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ScaleBy_finalize)

bool js_register_cocos2dx_ScaleBy(se::Object* obj)
{
    auto cls = se::Class::create("ScaleBy", obj, __jsb_cocos2d_ScaleTo_proto, _SE(js_cocos2dx_ScaleBy_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_ScaleBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ScaleBy_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ScaleBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ScaleBy>(cls);

    __jsb_cocos2d_ScaleBy_proto = cls->getProto();
    __jsb_cocos2d_ScaleBy_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ScaleBy.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Blink_proto = nullptr;
se::Class* __jsb_cocos2d_Blink_class = nullptr;

static bool js_cocos2dx_Blink_initWithDuration(se::State& s)
{
    cocos2d::Blink* cobj = (cocos2d::Blink*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Blink_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        int arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Blink_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Blink_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Blink_initWithDuration)

static bool js_cocos2dx_Blink_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        int arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Blink_create : Error processing arguments");
        auto result = cocos2d::Blink::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Blink_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Blink_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Blink_finalize)

static bool js_cocos2dx_Blink_constructor(se::State& s)
{
    cocos2d::Blink* cobj = new (std::nothrow) cocos2d::Blink();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Blink_constructor, __jsb_cocos2d_Blink_class, js_cocos2d_Blink_finalize)

static bool js_cocos2dx_Blink_ctor(se::State& s)
{
    cocos2d::Blink* cobj = new (std::nothrow) cocos2d::Blink();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Blink_ctor, __jsb_cocos2d_Blink_class, js_cocos2d_Blink_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_Blink_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Blink)", s.nativeThisObject());
        cocos2d::Blink* cobj = (cocos2d::Blink*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Blink_finalize)

bool js_register_cocos2dx_Blink(se::Object* obj)
{
    auto cls = se::Class::create("Blink", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_Blink_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_Blink_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Blink_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Blink_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Blink_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Blink>(cls);

    __jsb_cocos2d_Blink_proto = cls->getProto();
    __jsb_cocos2d_Blink_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Blink.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_FadeTo_proto = nullptr;
se::Class* __jsb_cocos2d_FadeTo_class = nullptr;

static bool js_cocos2dx_FadeTo_initWithDuration(se::State& s)
{
    cocos2d::FadeTo* cobj = (cocos2d::FadeTo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FadeTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        uint8_t arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_uint8(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeTo_initWithDuration)

static bool js_cocos2dx_FadeTo_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        uint8_t arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_uint8(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeTo_create : Error processing arguments");
        auto result = cocos2d::FadeTo::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FadeTo_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FadeTo_finalize)

static bool js_cocos2dx_FadeTo_constructor(se::State& s)
{
    cocos2d::FadeTo* cobj = new (std::nothrow) cocos2d::FadeTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FadeTo_constructor, __jsb_cocos2d_FadeTo_class, js_cocos2d_FadeTo_finalize)

static bool js_cocos2dx_FadeTo_ctor(se::State& s)
{
    cocos2d::FadeTo* cobj = new (std::nothrow) cocos2d::FadeTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FadeTo_ctor, __jsb_cocos2d_FadeTo_class, js_cocos2d_FadeTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_FadeTo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::FadeTo)", s.nativeThisObject());
        cocos2d::FadeTo* cobj = (cocos2d::FadeTo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FadeTo_finalize)

bool js_register_cocos2dx_FadeTo(se::Object* obj)
{
    auto cls = se::Class::create("FadeTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_FadeTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_FadeTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FadeTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FadeTo_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_FadeTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FadeTo>(cls);

    __jsb_cocos2d_FadeTo_proto = cls->getProto();
    __jsb_cocos2d_FadeTo_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.FadeTo.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_FadeIn_proto = nullptr;
se::Class* __jsb_cocos2d_FadeIn_class = nullptr;

static bool js_cocos2dx_FadeIn_setReverseAction(se::State& s)
{
    cocos2d::FadeIn* cobj = (cocos2d::FadeIn*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FadeIn_setReverseAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FadeTo* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeIn_setReverseAction : Error processing arguments");
        cobj->setReverseAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeIn_setReverseAction)

static bool js_cocos2dx_FadeIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeIn_create : Error processing arguments");
        auto result = cocos2d::FadeIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FadeIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FadeIn_finalize)

static bool js_cocos2dx_FadeIn_constructor(se::State& s)
{
    cocos2d::FadeIn* cobj = new (std::nothrow) cocos2d::FadeIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FadeIn_constructor, __jsb_cocos2d_FadeIn_class, js_cocos2d_FadeIn_finalize)

static bool js_cocos2dx_FadeIn_ctor(se::State& s)
{
    cocos2d::FadeIn* cobj = new (std::nothrow) cocos2d::FadeIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FadeIn_ctor, __jsb_cocos2d_FadeIn_class, js_cocos2d_FadeIn_finalize)


    

extern se::Object* __jsb_cocos2d_FadeTo_proto;

bool js_cocos2d_FadeIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::FadeIn)", s.nativeThisObject());
        cocos2d::FadeIn* cobj = (cocos2d::FadeIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FadeIn_finalize)

bool js_register_cocos2dx_FadeIn(se::Object* obj)
{
    auto cls = se::Class::create("FadeIn", obj, __jsb_cocos2d_FadeTo_proto, _SE(js_cocos2dx_FadeIn_constructor));

    cls->defineFunction("setReverseAction", _SE(js_cocos2dx_FadeIn_setReverseAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FadeIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FadeIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_FadeIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FadeIn>(cls);

    __jsb_cocos2d_FadeIn_proto = cls->getProto();
    __jsb_cocos2d_FadeIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.FadeIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_FadeOut_proto = nullptr;
se::Class* __jsb_cocos2d_FadeOut_class = nullptr;

static bool js_cocos2dx_FadeOut_setReverseAction(se::State& s)
{
    cocos2d::FadeOut* cobj = (cocos2d::FadeOut*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FadeOut_setReverseAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FadeTo* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeOut_setReverseAction : Error processing arguments");
        cobj->setReverseAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOut_setReverseAction)

static bool js_cocos2dx_FadeOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeOut_create : Error processing arguments");
        auto result = cocos2d::FadeOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FadeOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FadeOut_finalize)

static bool js_cocos2dx_FadeOut_constructor(se::State& s)
{
    cocos2d::FadeOut* cobj = new (std::nothrow) cocos2d::FadeOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FadeOut_constructor, __jsb_cocos2d_FadeOut_class, js_cocos2d_FadeOut_finalize)

static bool js_cocos2dx_FadeOut_ctor(se::State& s)
{
    cocos2d::FadeOut* cobj = new (std::nothrow) cocos2d::FadeOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FadeOut_ctor, __jsb_cocos2d_FadeOut_class, js_cocos2d_FadeOut_finalize)


    

extern se::Object* __jsb_cocos2d_FadeTo_proto;

bool js_cocos2d_FadeOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::FadeOut)", s.nativeThisObject());
        cocos2d::FadeOut* cobj = (cocos2d::FadeOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FadeOut_finalize)

bool js_register_cocos2dx_FadeOut(se::Object* obj)
{
    auto cls = se::Class::create("FadeOut", obj, __jsb_cocos2d_FadeTo_proto, _SE(js_cocos2dx_FadeOut_constructor));

    cls->defineFunction("setReverseAction", _SE(js_cocos2dx_FadeOut_setReverseAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FadeOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FadeOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_FadeOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FadeOut>(cls);

    __jsb_cocos2d_FadeOut_proto = cls->getProto();
    __jsb_cocos2d_FadeOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.FadeOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TintTo_proto = nullptr;
se::Class* __jsb_cocos2d_TintTo_class = nullptr;

static bool js_cocos2dx_TintTo_initWithDuration(se::State& s)
{
    cocos2d::TintTo* cobj = (cocos2d::TintTo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TintTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        uint8_t arg1;
        uint8_t arg2;
        uint8_t arg3;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_uint8(args[1], &arg1);
        ok &= seval_to_uint8(args[2], &arg2);
        ok &= seval_to_uint8(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TintTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TintTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TintTo_initWithDuration)

static bool js_cocos2dx_TintTo_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg1;
            ok &= seval_to_Color3B(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TintTo* result = cocos2d::TintTo::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::TintTo>((cocos2d::TintTo*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TintTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            uint8_t arg1;
            ok &= seval_to_uint8(args[1], &arg1);
            if (!ok) { ok = true; break; }
            uint8_t arg2;
            ok &= seval_to_uint8(args[2], &arg2);
            if (!ok) { ok = true; break; }
            uint8_t arg3;
            ok &= seval_to_uint8(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TintTo* result = cocos2d::TintTo::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::TintTo>((cocos2d::TintTo*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TintTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TintTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TintTo_finalize)

static bool js_cocos2dx_TintTo_constructor(se::State& s)
{
    cocos2d::TintTo* cobj = new (std::nothrow) cocos2d::TintTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TintTo_constructor, __jsb_cocos2d_TintTo_class, js_cocos2d_TintTo_finalize)

static bool js_cocos2dx_TintTo_ctor(se::State& s)
{
    cocos2d::TintTo* cobj = new (std::nothrow) cocos2d::TintTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TintTo_ctor, __jsb_cocos2d_TintTo_class, js_cocos2d_TintTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_TintTo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TintTo)", s.nativeThisObject());
        cocos2d::TintTo* cobj = (cocos2d::TintTo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TintTo_finalize)

bool js_register_cocos2dx_TintTo(se::Object* obj)
{
    auto cls = se::Class::create("TintTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_TintTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_TintTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TintTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TintTo_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TintTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TintTo>(cls);

    __jsb_cocos2d_TintTo_proto = cls->getProto();
    __jsb_cocos2d_TintTo_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TintTo.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TintBy_proto = nullptr;
se::Class* __jsb_cocos2d_TintBy_class = nullptr;

static bool js_cocos2dx_TintBy_initWithDuration(se::State& s)
{
    cocos2d::TintBy* cobj = (cocos2d::TintBy*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TintBy_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        int16_t arg1 = 0;
        int16_t arg2 = 0;
        int16_t arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_int16(args[1], &arg1);
        ok &= seval_to_int16(args[2], &arg2);
        ok &= seval_to_int16(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TintBy_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TintBy_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TintBy_initWithDuration)

static bool js_cocos2dx_TintBy_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        int16_t arg1 = 0;
        int16_t arg2 = 0;
        int16_t arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_int16(args[1], &arg1);
        ok &= seval_to_int16(args[2], &arg2);
        ok &= seval_to_int16(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TintBy_create : Error processing arguments");
        auto result = cocos2d::TintBy::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TintBy_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TintBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TintBy_finalize)

static bool js_cocos2dx_TintBy_constructor(se::State& s)
{
    cocos2d::TintBy* cobj = new (std::nothrow) cocos2d::TintBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TintBy_constructor, __jsb_cocos2d_TintBy_class, js_cocos2d_TintBy_finalize)

static bool js_cocos2dx_TintBy_ctor(se::State& s)
{
    cocos2d::TintBy* cobj = new (std::nothrow) cocos2d::TintBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TintBy_ctor, __jsb_cocos2d_TintBy_class, js_cocos2d_TintBy_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_TintBy_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TintBy)", s.nativeThisObject());
        cocos2d::TintBy* cobj = (cocos2d::TintBy*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TintBy_finalize)

bool js_register_cocos2dx_TintBy(se::Object* obj)
{
    auto cls = se::Class::create("TintBy", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_TintBy_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_TintBy_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TintBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TintBy_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TintBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TintBy>(cls);

    __jsb_cocos2d_TintBy_proto = cls->getProto();
    __jsb_cocos2d_TintBy_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TintBy.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_DelayTime_proto = nullptr;
se::Class* __jsb_cocos2d_DelayTime_class = nullptr;

static bool js_cocos2dx_DelayTime_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DelayTime_create : Error processing arguments");
        auto result = cocos2d::DelayTime::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_DelayTime_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DelayTime_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_DelayTime_finalize)

static bool js_cocos2dx_DelayTime_constructor(se::State& s)
{
    cocos2d::DelayTime* cobj = new (std::nothrow) cocos2d::DelayTime();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_DelayTime_constructor, __jsb_cocos2d_DelayTime_class, js_cocos2d_DelayTime_finalize)

static bool js_cocos2dx_DelayTime_ctor(se::State& s)
{
    cocos2d::DelayTime* cobj = new (std::nothrow) cocos2d::DelayTime();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_DelayTime_ctor, __jsb_cocos2d_DelayTime_class, js_cocos2d_DelayTime_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_DelayTime_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::DelayTime)", s.nativeThisObject());
        cocos2d::DelayTime* cobj = (cocos2d::DelayTime*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_DelayTime_finalize)

bool js_register_cocos2dx_DelayTime(se::Object* obj)
{
    auto cls = se::Class::create("DelayTime", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_DelayTime_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_DelayTime_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_DelayTime_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_DelayTime_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::DelayTime>(cls);

    __jsb_cocos2d_DelayTime_proto = cls->getProto();
    __jsb_cocos2d_DelayTime_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.DelayTime.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ReverseTime_proto = nullptr;
se::Class* __jsb_cocos2d_ReverseTime_class = nullptr;

static bool js_cocos2dx_ReverseTime_initWithAction(se::State& s)
{
    cocos2d::ReverseTime* cobj = (cocos2d::ReverseTime*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ReverseTime_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ReverseTime_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ReverseTime_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ReverseTime_initWithAction)

static bool js_cocos2dx_ReverseTime_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ReverseTime_create : Error processing arguments");
        auto result = cocos2d::ReverseTime::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ReverseTime_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ReverseTime_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ReverseTime_finalize)

static bool js_cocos2dx_ReverseTime_constructor(se::State& s)
{
    cocos2d::ReverseTime* cobj = new (std::nothrow) cocos2d::ReverseTime();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ReverseTime_constructor, __jsb_cocos2d_ReverseTime_class, js_cocos2d_ReverseTime_finalize)

static bool js_cocos2dx_ReverseTime_ctor(se::State& s)
{
    cocos2d::ReverseTime* cobj = new (std::nothrow) cocos2d::ReverseTime();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ReverseTime_ctor, __jsb_cocos2d_ReverseTime_class, js_cocos2d_ReverseTime_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_ReverseTime_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ReverseTime)", s.nativeThisObject());
        cocos2d::ReverseTime* cobj = (cocos2d::ReverseTime*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ReverseTime_finalize)

bool js_register_cocos2dx_ReverseTime(se::Object* obj)
{
    auto cls = se::Class::create("ReverseTime", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_ReverseTime_constructor));

    cls->defineFunction("initWithAction", _SE(js_cocos2dx_ReverseTime_initWithAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ReverseTime_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ReverseTime_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ReverseTime_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ReverseTime>(cls);

    __jsb_cocos2d_ReverseTime_proto = cls->getProto();
    __jsb_cocos2d_ReverseTime_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ReverseTime.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Animate_proto = nullptr;
se::Class* __jsb_cocos2d_Animate_class = nullptr;

static bool js_cocos2dx_Animate_initWithAnimation(se::State& s)
{
    cocos2d::Animate* cobj = (cocos2d::Animate*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animate_initWithAnimation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Animation* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animate_initWithAnimation : Error processing arguments");
        bool result = cobj->initWithAnimation(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animate_initWithAnimation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animate_initWithAnimation)

static bool js_cocos2dx_Animate_getAnimation(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Animate* cobj = (cocos2d::Animate*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Animate_getAnimation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::Animation* result = cobj->getAnimation();
            ok &= native_ptr_to_seval<cocos2d::Animation>((cocos2d::Animation*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animate_getAnimation : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::Animation* result = cobj->getAnimation();
            ok &= native_ptr_to_seval<cocos2d::Animation>((cocos2d::Animation*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animate_getAnimation : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animate_getAnimation)

static bool js_cocos2dx_Animate_getCurrentFrameIndex(se::State& s)
{
    cocos2d::Animate* cobj = (cocos2d::Animate*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animate_getCurrentFrameIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getCurrentFrameIndex();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animate_getCurrentFrameIndex : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animate_getCurrentFrameIndex)

static bool js_cocos2dx_Animate_setAnimation(se::State& s)
{
    cocos2d::Animate* cobj = (cocos2d::Animate*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Animate_setAnimation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Animation* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animate_setAnimation : Error processing arguments");
        cobj->setAnimation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animate_setAnimation)

static bool js_cocos2dx_Animate_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Animation* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Animate_create : Error processing arguments");
        auto result = cocos2d::Animate::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Animate_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Animate_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Animate_finalize)

static bool js_cocos2dx_Animate_constructor(se::State& s)
{
    cocos2d::Animate* cobj = new (std::nothrow) cocos2d::Animate();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Animate_constructor, __jsb_cocos2d_Animate_class, js_cocos2d_Animate_finalize)

static bool js_cocos2dx_Animate_ctor(se::State& s)
{
    cocos2d::Animate* cobj = new (std::nothrow) cocos2d::Animate();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Animate_ctor, __jsb_cocos2d_Animate_class, js_cocos2d_Animate_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_Animate_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Animate)", s.nativeThisObject());
        cocos2d::Animate* cobj = (cocos2d::Animate*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Animate_finalize)

bool js_register_cocos2dx_Animate(se::Object* obj)
{
    auto cls = se::Class::create("Animate", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_Animate_constructor));

    cls->defineFunction("initWithAnimation", _SE(js_cocos2dx_Animate_initWithAnimation));
    cls->defineFunction("getAnimation", _SE(js_cocos2dx_Animate_getAnimation));
    cls->defineFunction("getCurrentFrameIndex", _SE(js_cocos2dx_Animate_getCurrentFrameIndex));
    cls->defineFunction("setAnimation", _SE(js_cocos2dx_Animate_setAnimation));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Animate_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Animate_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Animate_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Animate>(cls);

    __jsb_cocos2d_Animate_proto = cls->getProto();
    __jsb_cocos2d_Animate_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Animate.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TargetedAction_proto = nullptr;
se::Class* __jsb_cocos2d_TargetedAction_class = nullptr;

static bool js_cocos2dx_TargetedAction_getForcedTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TargetedAction* cobj = (cocos2d::TargetedAction*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TargetedAction_getForcedTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::Node* result = cobj->getForcedTarget();
            ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TargetedAction_getForcedTarget : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::Node* result = cobj->getForcedTarget();
            ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TargetedAction_getForcedTarget : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TargetedAction_getForcedTarget)

static bool js_cocos2dx_TargetedAction_initWithTarget(se::State& s)
{
    cocos2d::TargetedAction* cobj = (cocos2d::TargetedAction*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TargetedAction_initWithTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        cocos2d::FiniteTimeAction* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TargetedAction_initWithTarget : Error processing arguments");
        bool result = cobj->initWithTarget(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TargetedAction_initWithTarget : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TargetedAction_initWithTarget)

static bool js_cocos2dx_TargetedAction_setForcedTarget(se::State& s)
{
    cocos2d::TargetedAction* cobj = (cocos2d::TargetedAction*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TargetedAction_setForcedTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TargetedAction_setForcedTarget : Error processing arguments");
        cobj->setForcedTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TargetedAction_setForcedTarget)

static bool js_cocos2dx_TargetedAction_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        cocos2d::FiniteTimeAction* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TargetedAction_create : Error processing arguments");
        auto result = cocos2d::TargetedAction::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TargetedAction_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TargetedAction_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TargetedAction_finalize)

static bool js_cocos2dx_TargetedAction_constructor(se::State& s)
{
    cocos2d::TargetedAction* cobj = new (std::nothrow) cocos2d::TargetedAction();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TargetedAction_constructor, __jsb_cocos2d_TargetedAction_class, js_cocos2d_TargetedAction_finalize)

static bool js_cocos2dx_TargetedAction_ctor(se::State& s)
{
    cocos2d::TargetedAction* cobj = new (std::nothrow) cocos2d::TargetedAction();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TargetedAction_ctor, __jsb_cocos2d_TargetedAction_class, js_cocos2d_TargetedAction_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_TargetedAction_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TargetedAction)", s.nativeThisObject());
        cocos2d::TargetedAction* cobj = (cocos2d::TargetedAction*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TargetedAction_finalize)

bool js_register_cocos2dx_TargetedAction(se::Object* obj)
{
    auto cls = se::Class::create("TargetedAction", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_TargetedAction_constructor));

    cls->defineFunction("getForcedTarget", _SE(js_cocos2dx_TargetedAction_getForcedTarget));
    cls->defineFunction("initWithTarget", _SE(js_cocos2dx_TargetedAction_initWithTarget));
    cls->defineFunction("setForcedTarget", _SE(js_cocos2dx_TargetedAction_setForcedTarget));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TargetedAction_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TargetedAction_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TargetedAction_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TargetedAction>(cls);

    __jsb_cocos2d_TargetedAction_proto = cls->getProto();
    __jsb_cocos2d_TargetedAction_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TargetedAction.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ActionFloat_proto = nullptr;
se::Class* __jsb_cocos2d_ActionFloat_class = nullptr;

static bool js_cocos2dx_ActionFloat_initWithDuration(se::State& s)
{
    cocos2d::ActionFloat* cobj = (cocos2d::ActionFloat*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionFloat_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        std::function<void (float)> arg3;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        do {
		    if (args[3].isObject() && args[3].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[3]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](float larg0) -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(1);
		            ok &= float_to_seval(larg0, &args[0]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg3 = lambda;
		    }
		    else
		    {
		        arg3 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionFloat_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionFloat_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionFloat_initWithDuration)

static bool js_cocos2dx_ActionFloat_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        std::function<void (float)> arg3;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        do {
		    if (args[3].isObject() && args[3].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[3]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](float larg0) -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(1);
		            ok &= float_to_seval(larg0, &args[0]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg3 = lambda;
		    }
		    else
		    {
		        arg3 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionFloat_create : Error processing arguments");
        auto result = cocos2d::ActionFloat::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ActionFloat_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionFloat_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ActionFloat_finalize)

static bool js_cocos2dx_ActionFloat_constructor(se::State& s)
{
    cocos2d::ActionFloat* cobj = new (std::nothrow) cocos2d::ActionFloat();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ActionFloat_constructor, __jsb_cocos2d_ActionFloat_class, js_cocos2d_ActionFloat_finalize)

static bool js_cocos2dx_ActionFloat_ctor(se::State& s)
{
    cocos2d::ActionFloat* cobj = new (std::nothrow) cocos2d::ActionFloat();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ActionFloat_ctor, __jsb_cocos2d_ActionFloat_class, js_cocos2d_ActionFloat_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_ActionFloat_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ActionFloat)", s.nativeThisObject());
        cocos2d::ActionFloat* cobj = (cocos2d::ActionFloat*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ActionFloat_finalize)

bool js_register_cocos2dx_ActionFloat(se::Object* obj)
{
    auto cls = se::Class::create("ActionFloat", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_ActionFloat_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_ActionFloat_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ActionFloat_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ActionFloat_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ActionFloat_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ActionFloat>(cls);

    __jsb_cocos2d_ActionFloat_proto = cls->getProto();
    __jsb_cocos2d_ActionFloat_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ActionFloat.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Configuration_proto = nullptr;
se::Class* __jsb_cocos2d_Configuration_class = nullptr;

static bool js_cocos2dx_Configuration_supportsPVRTC(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsPVRTC : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsPVRTC();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsPVRTC : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsPVRTC)

static bool js_cocos2dx_Configuration_supportsOESDepth24(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsOESDepth24 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsOESDepth24();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsOESDepth24 : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsOESDepth24)

static bool js_cocos2dx_Configuration_getMaxModelviewStackDepth(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxModelviewStackDepth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxModelviewStackDepth();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxModelviewStackDepth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxModelviewStackDepth)

static bool js_cocos2dx_Configuration_supportsShareableVAO(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsShareableVAO : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsShareableVAO();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsShareableVAO : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsShareableVAO)

static bool js_cocos2dx_Configuration_supportsBGRA8888(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsBGRA8888 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsBGRA8888();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsBGRA8888 : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsBGRA8888)

static bool js_cocos2dx_Configuration_checkForGLExtension(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_checkForGLExtension : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_checkForGLExtension : Error processing arguments");
        bool result = cobj->checkForGLExtension(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_checkForGLExtension : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_checkForGLExtension)

static bool js_cocos2dx_Configuration_supportsATITC(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsATITC : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsATITC();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsATITC : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsATITC)

static bool js_cocos2dx_Configuration_supportsNPOT(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsNPOT : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsNPOT();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsNPOT : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsNPOT)

static bool js_cocos2dx_Configuration_init(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_init)

static bool js_cocos2dx_Configuration_getAnimate3DQuality(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getAnimate3DQuality : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getAnimate3DQuality();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getAnimate3DQuality : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getAnimate3DQuality)

static bool js_cocos2dx_Configuration_getMaxSupportPointLightInShader(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxSupportPointLightInShader : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxSupportPointLightInShader();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxSupportPointLightInShader : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxSupportPointLightInShader)

static bool js_cocos2dx_Configuration_getMaxTextureSize(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxTextureSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxTextureSize();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxTextureSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxTextureSize)

static bool js_cocos2dx_Configuration_setValue(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_setValue : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        cocos2d::Value arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_ccvalue(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_setValue : Error processing arguments");
        cobj->setValue(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_setValue)

static bool js_cocos2dx_Configuration_getMaxSupportSpotLightInShader(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxSupportSpotLightInShader : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxSupportSpotLightInShader();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxSupportSpotLightInShader : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxSupportSpotLightInShader)

static bool js_cocos2dx_Configuration_supportsETC(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsETC : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsETC();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsETC : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsETC)

static bool js_cocos2dx_Configuration_getMaxSupportDirLightInShader(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxSupportDirLightInShader : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxSupportDirLightInShader();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxSupportDirLightInShader : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxSupportDirLightInShader)

static bool js_cocos2dx_Configuration_loadConfigFile(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_loadConfigFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_loadConfigFile : Error processing arguments");
        cobj->loadConfigFile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_loadConfigFile)

static bool js_cocos2dx_Configuration_supportsDiscardFramebuffer(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsDiscardFramebuffer : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsDiscardFramebuffer();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsDiscardFramebuffer : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsDiscardFramebuffer)

static bool js_cocos2dx_Configuration_supportsOESPackedDepthStencil(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsOESPackedDepthStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsOESPackedDepthStencil();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsOESPackedDepthStencil : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsOESPackedDepthStencil)

static bool js_cocos2dx_Configuration_supportsS3TC(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsS3TC : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsS3TC();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsS3TC : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsS3TC)

static bool js_cocos2dx_Configuration_getInfo(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getInfo();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getInfo : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getInfo)

static bool js_cocos2dx_Configuration_getMaxTextureUnits(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxTextureUnits : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxTextureUnits();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxTextureUnits : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxTextureUnits)

static bool js_cocos2dx_Configuration_getValue(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getValue : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getValue : Error processing arguments");
        const cocos2d::Value& result = cobj->getValue(arg0);
        ok &= ccvalue_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getValue : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        cocos2d::Value arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_ccvalue(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getValue : Error processing arguments");
        const cocos2d::Value& result = cobj->getValue(arg0, arg1);
        ok &= ccvalue_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getValue : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getValue)

static bool js_cocos2dx_Configuration_gatherGPUInfo(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_gatherGPUInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->gatherGPUInfo();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_gatherGPUInfo)

static bool js_cocos2dx_Configuration_supportsMapBuffer(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsMapBuffer : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsMapBuffer();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsMapBuffer : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsMapBuffer)

static bool js_cocos2dx_Configuration_destroyInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::Configuration::destroyInstance();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_destroyInstance)

static bool js_cocos2dx_Configuration_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Configuration::getInstance();
        se::Object* obj = nullptr;
        if (result->_scriptObject == nullptr)
        {
            obj = se::Object::createObjectWithClass(__jsb_cocos2d_Configuration_class, true);
            obj->setPrivateData(result);
            result->_scriptObject = obj;
        }
        else
        {
            obj = se::Object::getObjectWithPtr(result);
        }
        assert(obj);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getInstance)




bool js_register_cocos2dx_Configuration(se::Object* obj)
{
    auto cls = se::Class::create("Configuration", obj, nullptr, nullptr);

    cls->defineFunction("supportsPVRTC", _SE(js_cocos2dx_Configuration_supportsPVRTC));
    cls->defineFunction("supportsOESDepth24", _SE(js_cocos2dx_Configuration_supportsOESDepth24));
    cls->defineFunction("getMaxModelviewStackDepth", _SE(js_cocos2dx_Configuration_getMaxModelviewStackDepth));
    cls->defineFunction("supportsShareableVAO", _SE(js_cocos2dx_Configuration_supportsShareableVAO));
    cls->defineFunction("supportsBGRA8888", _SE(js_cocos2dx_Configuration_supportsBGRA8888));
    cls->defineFunction("checkForGLExtension", _SE(js_cocos2dx_Configuration_checkForGLExtension));
    cls->defineFunction("supportsATITC", _SE(js_cocos2dx_Configuration_supportsATITC));
    cls->defineFunction("supportsNPOT", _SE(js_cocos2dx_Configuration_supportsNPOT));
    cls->defineFunction("init", _SE(js_cocos2dx_Configuration_init));
    cls->defineFunction("getAnimate3DQuality", _SE(js_cocos2dx_Configuration_getAnimate3DQuality));
    cls->defineFunction("getMaxSupportPointLightInShader", _SE(js_cocos2dx_Configuration_getMaxSupportPointLightInShader));
    cls->defineFunction("getMaxTextureSize", _SE(js_cocos2dx_Configuration_getMaxTextureSize));
    cls->defineFunction("setValue", _SE(js_cocos2dx_Configuration_setValue));
    cls->defineFunction("getMaxSupportSpotLightInShader", _SE(js_cocos2dx_Configuration_getMaxSupportSpotLightInShader));
    cls->defineFunction("supportsETC", _SE(js_cocos2dx_Configuration_supportsETC));
    cls->defineFunction("getMaxSupportDirLightInShader", _SE(js_cocos2dx_Configuration_getMaxSupportDirLightInShader));
    cls->defineFunction("loadConfigFile", _SE(js_cocos2dx_Configuration_loadConfigFile));
    cls->defineFunction("supportsDiscardFramebuffer", _SE(js_cocos2dx_Configuration_supportsDiscardFramebuffer));
    cls->defineFunction("supportsOESPackedDepthStencil", _SE(js_cocos2dx_Configuration_supportsOESPackedDepthStencil));
    cls->defineFunction("supportsS3TC", _SE(js_cocos2dx_Configuration_supportsS3TC));
    cls->defineFunction("dumpInfo", _SE(js_cocos2dx_Configuration_getInfo));
    cls->defineFunction("getMaxTextureUnits", _SE(js_cocos2dx_Configuration_getMaxTextureUnits));
    cls->defineFunction("getValue", _SE(js_cocos2dx_Configuration_getValue));
    cls->defineFunction("gatherGPUInfo", _SE(js_cocos2dx_Configuration_gatherGPUInfo));
    cls->defineFunction("supportsMapBuffer", _SE(js_cocos2dx_Configuration_supportsMapBuffer));
    cls->defineStaticFunction("destroyInstance", _SE(js_cocos2dx_Configuration_destroyInstance));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_Configuration_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::Configuration>(cls);

    __jsb_cocos2d_Configuration_proto = cls->getProto();
    __jsb_cocos2d_Configuration_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Properties_proto = nullptr;
se::Class* __jsb_cocos2d_Properties_class = nullptr;

static bool js_cocos2dx_Properties_getVariable(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getVariable : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        const char* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getVariable : Error processing arguments");
        const char* result = cobj->getVariable(arg0, arg1);
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getVariable : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getVariable)

static bool js_cocos2dx_Properties_getString(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        const char* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getString : Error processing arguments");
        const char* result = cobj->getString(arg0, arg1);
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getString)

static bool js_cocos2dx_Properties_getLong(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getLong : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getLong : Error processing arguments");
        long result = cobj->getLong(arg0);
        ok &= long_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getLong : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getLong)

static bool js_cocos2dx_Properties_getNamespace(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Properties_getNamespace : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const char* result = cobj->getNamespace();
            ok &= std_string_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getNamespace : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            cocos2d::Properties* result = cobj->getNamespace(arg0);
            ok &= native_ptr_to_seval<cocos2d::Properties>((cocos2d::Properties*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getNamespace : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            bool arg1;
            ok &= seval_to_boolean(args[1], &arg1);
            cocos2d::Properties* result = cobj->getNamespace(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::Properties>((cocos2d::Properties*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getNamespace : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            bool arg1;
            ok &= seval_to_boolean(args[1], &arg1);
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            cocos2d::Properties* result = cobj->getNamespace(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::Properties>((cocos2d::Properties*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getNamespace : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getNamespace)

static bool js_cocos2dx_Properties_getPath(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getPath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        std::string* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        #pragma warning NO CONVERSION TO NATIVE FOR std::string*
		ok = false;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getPath : Error processing arguments");
        bool result = cobj->getPath(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getPath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getPath)

static bool js_cocos2dx_Properties_getMat4(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getMat4 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        cocos2d::Mat4* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getMat4 : Error processing arguments");
        bool result = cobj->getMat4(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getMat4 : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getMat4)

static bool js_cocos2dx_Properties_exists(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_exists : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_exists : Error processing arguments");
        bool result = cobj->exists(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_exists : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_exists)

static bool js_cocos2dx_Properties_setString(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_setString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        const char* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_setString : Error processing arguments");
        bool result = cobj->setString(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_setString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_setString)

static bool js_cocos2dx_Properties_getId(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getId : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const char* result = cobj->getId();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getId : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getId)

static bool js_cocos2dx_Properties_rewind(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_rewind : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->rewind();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_rewind)

static bool js_cocos2dx_Properties_setVariable(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_setVariable : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        const char* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_setVariable : Error processing arguments");
        cobj->setVariable(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_setVariable)

static bool js_cocos2dx_Properties_getBool(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getBool : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getBool : Error processing arguments");
        bool result = cobj->getBool(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getBool : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        const char* arg0 = nullptr;
        bool arg1;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getBool : Error processing arguments");
        bool result = cobj->getBool(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getBool : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getBool)

static bool js_cocos2dx_Properties_getColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Properties_getColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            cocos2d::Vec4* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->getColor(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getColor : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            cocos2d::Vec3* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->getColor(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getColor : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getColor)

static bool js_cocos2dx_Properties_getType(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getType : Error processing arguments");
        int result = (int)cobj->getType(arg0);
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getType)

static bool js_cocos2dx_Properties_getNextNamespace(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getNextNamespace : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Properties* result = cobj->getNextNamespace();
        ok &= native_ptr_to_seval<cocos2d::Properties>((cocos2d::Properties*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getNextNamespace : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getNextNamespace)

static bool js_cocos2dx_Properties_getInt(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getInt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getInt : Error processing arguments");
        int result = cobj->getInt(arg0);
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getInt : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getInt)

static bool js_cocos2dx_Properties_getVec3(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getVec3 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        cocos2d::Vec3* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getVec3 : Error processing arguments");
        bool result = cobj->getVec3(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getVec3 : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getVec3)

static bool js_cocos2dx_Properties_getVec2(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getVec2 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        cocos2d::Vec2* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[1], &tempData);arg1=tempData.data();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getVec2 : Error processing arguments");
        bool result = cobj->getVec2(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getVec2 : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getVec2)

static bool js_cocos2dx_Properties_getVec4(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getVec4 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        cocos2d::Vec4* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getVec4 : Error processing arguments");
        bool result = cobj->getVec4(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getVec4 : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getVec4)

static bool js_cocos2dx_Properties_getNextProperty(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getNextProperty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const char* result = cobj->getNextProperty();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getNextProperty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getNextProperty)

static bool js_cocos2dx_Properties_getFloat(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getFloat : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getFloat : Error processing arguments");
        float result = cobj->getFloat(arg0);
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getFloat : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getFloat)

static bool js_cocos2dx_Properties_getQuaternionFromAxisAngle(se::State& s)
{
    cocos2d::Properties* cobj = (cocos2d::Properties*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Properties_getQuaternionFromAxisAngle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        cocos2d::Quaternion* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getQuaternionFromAxisAngle : Error processing arguments");
        bool result = cobj->getQuaternionFromAxisAngle(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_getQuaternionFromAxisAngle : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_getQuaternionFromAxisAngle)

static bool js_cocos2dx_Properties_parseColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            cocos2d::Vec4* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cocos2d::Properties::parseColor(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_parseColor : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            cocos2d::Vec3* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cocos2d::Properties::parseColor(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_parseColor : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_parseColor)

static bool js_cocos2dx_Properties_parseVec3(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        cocos2d::Vec3* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_parseVec3 : Error processing arguments");
        bool result = cocos2d::Properties::parseVec3(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_parseVec3 : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_parseVec3)

static bool js_cocos2dx_Properties_parseAxisAngle(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        cocos2d::Quaternion* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_parseAxisAngle : Error processing arguments");
        bool result = cocos2d::Properties::parseAxisAngle(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_parseAxisAngle : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_parseAxisAngle)

static bool js_cocos2dx_Properties_parseVec2(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        cocos2d::Vec2* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[1], &tempData);arg1=tempData.data();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_parseVec2 : Error processing arguments");
        bool result = cocos2d::Properties::parseVec2(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_parseVec2 : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_parseVec2)

static bool js_cocos2dx_Properties_createNonRefCounted(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_createNonRefCounted : Error processing arguments");
        cocos2d::Properties* result = cocos2d::Properties::createNonRefCounted(arg0);
        ok &= native_ptr_to_seval<cocos2d::Properties>((cocos2d::Properties*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_createNonRefCounted : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_createNonRefCounted)

static bool js_cocos2dx_Properties_parseVec4(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        cocos2d::Vec4* arg1 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_parseVec4 : Error processing arguments");
        bool result = cocos2d::Properties::parseVec4(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Properties_parseVec4 : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Properties_parseVec4)




bool js_register_cocos2dx_Properties(se::Object* obj)
{
    auto cls = se::Class::create("Properties", obj, nullptr, nullptr);

    cls->defineFunction("getVariable", _SE(js_cocos2dx_Properties_getVariable));
    cls->defineFunction("getString", _SE(js_cocos2dx_Properties_getString));
    cls->defineFunction("getLong", _SE(js_cocos2dx_Properties_getLong));
    cls->defineFunction("getNamespace", _SE(js_cocos2dx_Properties_getNamespace));
    cls->defineFunction("getPath", _SE(js_cocos2dx_Properties_getPath));
    cls->defineFunction("getMat4", _SE(js_cocos2dx_Properties_getMat4));
    cls->defineFunction("exists", _SE(js_cocos2dx_Properties_exists));
    cls->defineFunction("setString", _SE(js_cocos2dx_Properties_setString));
    cls->defineFunction("getId", _SE(js_cocos2dx_Properties_getId));
    cls->defineFunction("rewind", _SE(js_cocos2dx_Properties_rewind));
    cls->defineFunction("setVariable", _SE(js_cocos2dx_Properties_setVariable));
    cls->defineFunction("getBool", _SE(js_cocos2dx_Properties_getBool));
    cls->defineFunction("getColor", _SE(js_cocos2dx_Properties_getColor));
    cls->defineFunction("getType", _SE(js_cocos2dx_Properties_getType));
    cls->defineFunction("getNextNamespace", _SE(js_cocos2dx_Properties_getNextNamespace));
    cls->defineFunction("getInt", _SE(js_cocos2dx_Properties_getInt));
    cls->defineFunction("getVec3", _SE(js_cocos2dx_Properties_getVec3));
    cls->defineFunction("getVec2", _SE(js_cocos2dx_Properties_getVec2));
    cls->defineFunction("getVec4", _SE(js_cocos2dx_Properties_getVec4));
    cls->defineFunction("getNextProperty", _SE(js_cocos2dx_Properties_getNextProperty));
    cls->defineFunction("getFloat", _SE(js_cocos2dx_Properties_getFloat));
    cls->defineFunction("getQuaternionFromAxisAngle", _SE(js_cocos2dx_Properties_getQuaternionFromAxisAngle));
    cls->defineStaticFunction("parseColor", _SE(js_cocos2dx_Properties_parseColor));
    cls->defineStaticFunction("parseVec3", _SE(js_cocos2dx_Properties_parseVec3));
    cls->defineStaticFunction("parseAxisAngle", _SE(js_cocos2dx_Properties_parseAxisAngle));
    cls->defineStaticFunction("parseVec2", _SE(js_cocos2dx_Properties_parseVec2));
    cls->defineStaticFunction("createNonRefCounted", _SE(js_cocos2dx_Properties_createNonRefCounted));
    cls->defineStaticFunction("parseVec4", _SE(js_cocos2dx_Properties_parseVec4));
    cls->install();
    JSBClassType::registerClass<cocos2d::Properties>(cls);

    __jsb_cocos2d_Properties_proto = cls->getProto();
    __jsb_cocos2d_Properties_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_FileUtils_proto = nullptr;
se::Class* __jsb_cocos2d_FileUtils_class = nullptr;

static bool js_cocos2dx_FileUtils_fullPathForFilename(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_fullPathForFilename : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_fullPathForFilename : Error processing arguments");
        std::string result = cobj->fullPathForFilename(arg0);
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_fullPathForFilename : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_fullPathForFilename)

static bool js_cocos2dx_FileUtils_getStringFromFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_getStringFromFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::function<void (std::basic_string<char>)> arg1;
            do {
			    if (args[1].isObject() && args[1].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[1]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](std::basic_string<char> larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= std_string_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg1 = lambda;
			    }
			    else
			    {
			        arg1 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->getStringFromFile(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string result = cobj->getStringFromFile(arg0);
            ok &= std_string_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getStringFromFile : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getStringFromFile)

static bool js_cocos2dx_FileUtils_removeFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_removeFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::function<void (bool)> arg1;
            do {
			    if (args[1].isObject() && args[1].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[1]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](bool larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= boolean_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg1 = lambda;
			    }
			    else
			    {
			        arg1 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->removeFile(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->removeFile(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_removeFile : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_removeFile)

static bool js_cocos2dx_FileUtils_isAbsolutePath(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_isAbsolutePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isAbsolutePath : Error processing arguments");
        bool result = cobj->isAbsolutePath(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isAbsolutePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_isAbsolutePath)

static bool js_cocos2dx_FileUtils_renameFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_renameFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            std::function<void (bool)> arg3;
            do {
			    if (args[3].isObject() && args[3].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[3]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](bool larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= boolean_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg3 = lambda;
			    }
			    else
			    {
			        arg3 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->renameFile(arg0, arg1, arg2, arg3);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->renameFile(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_renameFile : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->renameFile(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_renameFile : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::function<void (bool)> arg2;
            do {
			    if (args[2].isObject() && args[2].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[2]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](bool larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= boolean_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg2 = lambda;
			    }
			    else
			    {
			        arg2 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->renameFile(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_renameFile)

static bool js_cocos2dx_FileUtils_getDefaultResourceRootPath(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getDefaultResourceRootPath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getDefaultResourceRootPath();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getDefaultResourceRootPath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getDefaultResourceRootPath)

static bool js_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile : Error processing arguments");
        cobj->loadFilenameLookupDictionaryFromFile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile)

static bool js_cocos2dx_FileUtils_isPopupNotify(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_isPopupNotify : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isPopupNotify();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isPopupNotify : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_isPopupNotify)

static bool js_cocos2dx_FileUtils_getValueVectorFromFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getValueVectorFromFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueVectorFromFile : Error processing arguments");
        cocos2d::ValueVector result = cobj->getValueVectorFromFile(arg0);
        ok &= ccvaluevector_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueVectorFromFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getValueVectorFromFile)

static bool js_cocos2dx_FileUtils_getSearchPaths(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getSearchPaths : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::vector<std::string>& result = cobj->getSearchPaths();
        ok &= std_vector_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getSearchPaths : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getSearchPaths)

static bool js_cocos2dx_FileUtils_writeToFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_writeToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ValueMap arg0;
        std::string arg1;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeToFile : Error processing arguments");
        bool result = cobj->writeToFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeToFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_writeToFile)

static bool js_cocos2dx_FileUtils_getOriginalSearchPaths(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getOriginalSearchPaths : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::vector<std::string>& result = cobj->getOriginalSearchPaths();
        ok &= std_vector_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getOriginalSearchPaths : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getOriginalSearchPaths)

static bool js_cocos2dx_FileUtils_getNewFilename(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getNewFilename : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getNewFilename : Error processing arguments");
        std::string result = cobj->getNewFilename(arg0);
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getNewFilename : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getNewFilename)

static bool js_cocos2dx_FileUtils_listFiles(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_listFiles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_listFiles : Error processing arguments");
        std::vector<std::string> result = cobj->listFiles(arg0);
        ok &= std_vector_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_listFiles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_listFiles)

static bool js_cocos2dx_FileUtils_getValueMapFromFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getValueMapFromFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueMapFromFile : Error processing arguments");
        cocos2d::ValueMap result = cobj->getValueMapFromFile(arg0);
        ok &= ccvaluemap_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueMapFromFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getValueMapFromFile)

static bool js_cocos2dx_FileUtils_getFileSize(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_getFileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::function<void (long)> arg1;
            do {
			    if (args[1].isObject() && args[1].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[1]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](long larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= long_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg1 = lambda;
			    }
			    else
			    {
			        arg1 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->getFileSize(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            long result = cobj->getFileSize(arg0);
            ok &= long_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getFileSize : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getFileSize)

static bool js_cocos2dx_FileUtils_getValueMapFromData(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getValueMapFromData : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        int arg1 = 0;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueMapFromData : Error processing arguments");
        cocos2d::ValueMap result = cobj->getValueMapFromData(arg0, arg1);
        ok &= ccvaluemap_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueMapFromData : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getValueMapFromData)

static bool js_cocos2dx_FileUtils_removeDirectory(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_removeDirectory : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::function<void (bool)> arg1;
            do {
			    if (args[1].isObject() && args[1].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[1]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](bool larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= boolean_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg1 = lambda;
			    }
			    else
			    {
			        arg1 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->removeDirectory(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->removeDirectory(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_removeDirectory : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_removeDirectory)

static bool js_cocos2dx_FileUtils_setSearchPaths(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_setSearchPaths : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::vector<std::string> arg0;
        ok &= seval_to_std_vector_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setSearchPaths : Error processing arguments");
        cobj->setSearchPaths(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setSearchPaths)

static bool js_cocos2dx_FileUtils_writeStringToFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_writeStringToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::function<void (bool)> arg2;
            do {
			    if (args[2].isObject() && args[2].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[2]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](bool larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= boolean_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg2 = lambda;
			    }
			    else
			    {
			        arg2 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->writeStringToFile(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->writeStringToFile(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeStringToFile : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_writeStringToFile)

static bool js_cocos2dx_FileUtils_setSearchResolutionsOrder(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_setSearchResolutionsOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::vector<std::string> arg0;
        ok &= seval_to_std_vector_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setSearchResolutionsOrder : Error processing arguments");
        cobj->setSearchResolutionsOrder(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setSearchResolutionsOrder)

static bool js_cocos2dx_FileUtils_addSearchResolutionsOrder(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_addSearchResolutionsOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_addSearchResolutionsOrder : Error processing arguments");
        cobj->addSearchResolutionsOrder(arg0);
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        bool arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_addSearchResolutionsOrder : Error processing arguments");
        cobj->addSearchResolutionsOrder(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_addSearchResolutionsOrder)

static bool js_cocos2dx_FileUtils_addSearchPath(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_addSearchPath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_addSearchPath : Error processing arguments");
        cobj->addSearchPath(arg0);
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        bool arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_addSearchPath : Error processing arguments");
        cobj->addSearchPath(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_addSearchPath)

static bool js_cocos2dx_FileUtils_writeValueVectorToFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_writeValueVectorToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            cocos2d::ValueVector arg0;
            ok &= seval_to_ccvaluevector(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::function<void (bool)> arg2;
            do {
			    if (args[2].isObject() && args[2].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[2]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](bool larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= boolean_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg2 = lambda;
			    }
			    else
			    {
			        arg2 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->writeValueVectorToFile(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            cocos2d::ValueVector arg0;
            ok &= seval_to_ccvaluevector(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->writeValueVectorToFile(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeValueVectorToFile : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_writeValueVectorToFile)

static bool js_cocos2dx_FileUtils_isFileExist(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_isFileExist : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::function<void (bool)> arg1;
            do {
			    if (args[1].isObject() && args[1].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[1]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](bool larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= boolean_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg1 = lambda;
			    }
			    else
			    {
			        arg1 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->isFileExist(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->isFileExist(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isFileExist : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_isFileExist)

static bool js_cocos2dx_FileUtils_purgeCachedEntries(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_purgeCachedEntries : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->purgeCachedEntries();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_purgeCachedEntries)

static bool js_cocos2dx_FileUtils_fullPathFromRelativeFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_fullPathFromRelativeFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_fullPathFromRelativeFile : Error processing arguments");
        std::string result = cobj->fullPathFromRelativeFile(arg0, arg1);
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_fullPathFromRelativeFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_fullPathFromRelativeFile)

static bool js_cocos2dx_FileUtils_getSuitableFOpen(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getSuitableFOpen : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getSuitableFOpen : Error processing arguments");
        std::string result = cobj->getSuitableFOpen(arg0);
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getSuitableFOpen : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getSuitableFOpen)

static bool js_cocos2dx_FileUtils_writeValueMapToFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_writeValueMapToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            cocos2d::ValueMap arg0;
            ok &= seval_to_ccvaluemap(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::function<void (bool)> arg2;
            do {
			    if (args[2].isObject() && args[2].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[2]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](bool larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= boolean_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg2 = lambda;
			    }
			    else
			    {
			        arg2 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->writeValueMapToFile(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            cocos2d::ValueMap arg0;
            ok &= seval_to_ccvaluemap(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->writeValueMapToFile(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeValueMapToFile : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_writeValueMapToFile)

static bool js_cocos2dx_FileUtils_getFileExtension(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getFileExtension : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getFileExtension : Error processing arguments");
        std::string result = cobj->getFileExtension(arg0);
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getFileExtension : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getFileExtension)

static bool js_cocos2dx_FileUtils_setWritablePath(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_setWritablePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setWritablePath : Error processing arguments");
        cobj->setWritablePath(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setWritablePath)

static bool js_cocos2dx_FileUtils_setPopupNotify(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_setPopupNotify : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setPopupNotify : Error processing arguments");
        cobj->setPopupNotify(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setPopupNotify)

static bool js_cocos2dx_FileUtils_isDirectoryExist(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_isDirectoryExist : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::function<void (bool)> arg1;
            do {
			    if (args[1].isObject() && args[1].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[1]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](bool larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= boolean_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg1 = lambda;
			    }
			    else
			    {
			        arg1 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->isDirectoryExist(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->isDirectoryExist(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isDirectoryExist : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_isDirectoryExist)

static bool js_cocos2dx_FileUtils_setDefaultResourceRootPath(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_setDefaultResourceRootPath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setDefaultResourceRootPath : Error processing arguments");
        cobj->setDefaultResourceRootPath(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setDefaultResourceRootPath)

static bool js_cocos2dx_FileUtils_getSearchResolutionsOrder(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getSearchResolutionsOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::vector<std::string>& result = cobj->getSearchResolutionsOrder();
        ok &= std_vector_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getSearchResolutionsOrder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getSearchResolutionsOrder)

static bool js_cocos2dx_FileUtils_createDirectory(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_createDirectory : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::function<void (bool)> arg1;
            do {
			    if (args[1].isObject() && args[1].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[1]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](bool larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= boolean_to_seval(larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg1 = lambda;
			    }
			    else
			    {
			        arg1 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->createDirectory(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->createDirectory(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_createDirectory : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_createDirectory)

static bool js_cocos2dx_FileUtils_getWritablePath(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getWritablePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getWritablePath();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getWritablePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getWritablePath)

static bool js_cocos2dx_FileUtils_listFilesRecursively(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_listFilesRecursively : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::vector<std::basic_string<char>, std::allocator<std::basic_string<char> > >* arg1 = nullptr;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_listFilesRecursively : Error processing arguments");
        cobj->listFilesRecursively(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_listFilesRecursively)

static bool js_cocos2dx_FileUtils_setDelegate(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FileUtils* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setDelegate : Error processing arguments");
        cocos2d::FileUtils::setDelegate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setDelegate)

static bool js_cocos2dx_FileUtils_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::FileUtils* result = cocos2d::FileUtils::getInstance();
        ok &= native_ptr_to_seval<cocos2d::FileUtils>((cocos2d::FileUtils*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getInstance : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getInstance)




bool js_register_cocos2dx_FileUtils(se::Object* obj)
{
    auto cls = se::Class::create("FileUtils", obj, nullptr, nullptr);

    cls->defineFunction("fullPathForFilename", _SE(js_cocos2dx_FileUtils_fullPathForFilename));
    cls->defineFunction("getStringFromFile", _SE(js_cocos2dx_FileUtils_getStringFromFile));
    cls->defineFunction("removeFile", _SE(js_cocos2dx_FileUtils_removeFile));
    cls->defineFunction("isAbsolutePath", _SE(js_cocos2dx_FileUtils_isAbsolutePath));
    cls->defineFunction("renameFile", _SE(js_cocos2dx_FileUtils_renameFile));
    cls->defineFunction("getDefaultResourceRootPath", _SE(js_cocos2dx_FileUtils_getDefaultResourceRootPath));
    cls->defineFunction("loadFilenameLookup", _SE(js_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile));
    cls->defineFunction("isPopupNotify", _SE(js_cocos2dx_FileUtils_isPopupNotify));
    cls->defineFunction("getValueVectorFromFile", _SE(js_cocos2dx_FileUtils_getValueVectorFromFile));
    cls->defineFunction("getSearchPaths", _SE(js_cocos2dx_FileUtils_getSearchPaths));
    cls->defineFunction("writeToFile", _SE(js_cocos2dx_FileUtils_writeToFile));
    cls->defineFunction("getOriginalSearchPaths", _SE(js_cocos2dx_FileUtils_getOriginalSearchPaths));
    cls->defineFunction("getNewFilename", _SE(js_cocos2dx_FileUtils_getNewFilename));
    cls->defineFunction("listFiles", _SE(js_cocos2dx_FileUtils_listFiles));
    cls->defineFunction("getValueMapFromFile", _SE(js_cocos2dx_FileUtils_getValueMapFromFile));
    cls->defineFunction("getFileSize", _SE(js_cocos2dx_FileUtils_getFileSize));
    cls->defineFunction("getValueMapFromData", _SE(js_cocos2dx_FileUtils_getValueMapFromData));
    cls->defineFunction("removeDirectory", _SE(js_cocos2dx_FileUtils_removeDirectory));
    cls->defineFunction("setSearchPaths", _SE(js_cocos2dx_FileUtils_setSearchPaths));
    cls->defineFunction("writeStringToFile", _SE(js_cocos2dx_FileUtils_writeStringToFile));
    cls->defineFunction("setSearchResolutionsOrder", _SE(js_cocos2dx_FileUtils_setSearchResolutionsOrder));
    cls->defineFunction("addSearchResolutionsOrder", _SE(js_cocos2dx_FileUtils_addSearchResolutionsOrder));
    cls->defineFunction("addSearchPath", _SE(js_cocos2dx_FileUtils_addSearchPath));
    cls->defineFunction("writeValueVectorToFile", _SE(js_cocos2dx_FileUtils_writeValueVectorToFile));
    cls->defineFunction("isFileExist", _SE(js_cocos2dx_FileUtils_isFileExist));
    cls->defineFunction("purgeCachedEntries", _SE(js_cocos2dx_FileUtils_purgeCachedEntries));
    cls->defineFunction("fullPathFromRelativeFile", _SE(js_cocos2dx_FileUtils_fullPathFromRelativeFile));
    cls->defineFunction("getSuitableFOpen", _SE(js_cocos2dx_FileUtils_getSuitableFOpen));
    cls->defineFunction("writeValueMapToFile", _SE(js_cocos2dx_FileUtils_writeValueMapToFile));
    cls->defineFunction("getFileExtension", _SE(js_cocos2dx_FileUtils_getFileExtension));
    cls->defineFunction("setWritablePath", _SE(js_cocos2dx_FileUtils_setWritablePath));
    cls->defineFunction("setPopupNotify", _SE(js_cocos2dx_FileUtils_setPopupNotify));
    cls->defineFunction("isDirectoryExist", _SE(js_cocos2dx_FileUtils_isDirectoryExist));
    cls->defineFunction("setDefaultResourceRootPath", _SE(js_cocos2dx_FileUtils_setDefaultResourceRootPath));
    cls->defineFunction("getSearchResolutionsOrder", _SE(js_cocos2dx_FileUtils_getSearchResolutionsOrder));
    cls->defineFunction("createDirectory", _SE(js_cocos2dx_FileUtils_createDirectory));
    cls->defineFunction("getWritablePath", _SE(js_cocos2dx_FileUtils_getWritablePath));
    cls->defineFunction("listFilesRecursively", _SE(js_cocos2dx_FileUtils_listFilesRecursively));
    cls->defineStaticFunction("setDelegate", _SE(js_cocos2dx_FileUtils_setDelegate));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_FileUtils_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::FileUtils>(cls);

    __jsb_cocos2d_FileUtils_proto = cls->getProto();
    __jsb_cocos2d_FileUtils_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventAcceleration_proto = nullptr;
se::Class* __jsb_cocos2d_EventAcceleration_class = nullptr;


extern se::Object* __jsb_cocos2d_Event_proto;


bool js_register_cocos2dx_EventAcceleration(se::Object* obj)
{
    auto cls = se::Class::create("EventAcceleration", obj, __jsb_cocos2d_Event_proto, nullptr);

    cls->install();
    JSBClassType::registerClass<cocos2d::EventAcceleration>(cls);

    __jsb_cocos2d_EventAcceleration_proto = cls->getProto();
    __jsb_cocos2d_EventAcceleration_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventCustom_proto = nullptr;
se::Class* __jsb_cocos2d_EventCustom_class = nullptr;

static bool js_cocos2dx_EventCustom_getEventName(se::State& s)
{
    cocos2d::EventCustom* cobj = (cocos2d::EventCustom*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventCustom_getEventName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getEventName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventCustom_getEventName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventCustom_getEventName)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventCustom_finalize)

static bool js_cocos2dx_EventCustom_constructor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string arg0;
    ok &= seval_to_std_string(args[0], &arg0);
    JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventCustom_constructor : Error processing arguments");
    cocos2d::EventCustom* cobj = new (std::nothrow) cocos2d::EventCustom(arg0);
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventCustom_constructor, __jsb_cocos2d_EventCustom_class, js_cocos2d_EventCustom_finalize)



extern se::Object* __jsb_cocos2d_Event_proto;

bool js_cocos2d_EventCustom_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EventCustom)", s.nativeThisObject());
        cocos2d::EventCustom* cobj = (cocos2d::EventCustom*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventCustom_finalize)

bool js_register_cocos2dx_EventCustom(se::Object* obj)
{
    auto cls = se::Class::create("EventCustom", obj, __jsb_cocos2d_Event_proto, _SE(js_cocos2dx_EventCustom_constructor));

    cls->defineFunction("getEventName", _SE(js_cocos2dx_EventCustom_getEventName));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EventCustom_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventCustom>(cls);

    __jsb_cocos2d_EventCustom_proto = cls->getProto();
    __jsb_cocos2d_EventCustom_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventListener_proto = nullptr;
se::Class* __jsb_cocos2d_EventListener_class = nullptr;

static bool js_cocos2dx_EventListener_setEnabled(se::State& s)
{
    cocos2d::EventListener* cobj = (cocos2d::EventListener*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListener_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListener_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListener_setEnabled)

static bool js_cocos2dx_EventListener_isEnabled(se::State& s)
{
    cocos2d::EventListener* cobj = (cocos2d::EventListener*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListener_isEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListener_isEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListener_isEnabled)

static bool js_cocos2dx_EventListener_clone(se::State& s)
{
    cocos2d::EventListener* cobj = (cocos2d::EventListener*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListener_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::EventListener* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::EventListener>((cocos2d::EventListener*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListener_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListener_clone)

static bool js_cocos2dx_EventListener_checkAvailable(se::State& s)
{
    cocos2d::EventListener* cobj = (cocos2d::EventListener*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListener_checkAvailable : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->checkAvailable();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListener_checkAvailable : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListener_checkAvailable)




bool js_register_cocos2dx_EventListener(se::Object* obj)
{
    auto cls = se::Class::create("EventListener", obj, nullptr, nullptr);

    cls->defineFunction("setEnabled", _SE(js_cocos2dx_EventListener_setEnabled));
    cls->defineFunction("isEnabled", _SE(js_cocos2dx_EventListener_isEnabled));
    cls->defineFunction("clone", _SE(js_cocos2dx_EventListener_clone));
    cls->defineFunction("checkAvailable", _SE(js_cocos2dx_EventListener_checkAvailable));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListener>(cls);

    __jsb_cocos2d_EventListener_proto = cls->getProto();
    __jsb_cocos2d_EventListener_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventDispatcher_proto = nullptr;
se::Class* __jsb_cocos2d_EventDispatcher_class = nullptr;

static bool js_cocos2dx_EventDispatcher_setEnabled(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_setEnabled)

static bool js_cocos2dx_EventDispatcher_removeAllEventListeners(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_removeAllEventListeners : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllEventListeners();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_removeAllEventListeners)

static bool js_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::EventListener* arg0 = nullptr;
        cocos2d::Node* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority : Error processing arguments");
        cobj->addEventListenerWithSceneGraphPriority(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority)

static bool js_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::EventListener* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority : Error processing arguments");
        cobj->addEventListenerWithFixedPriority(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority)

static bool js_cocos2dx_EventDispatcher_removeEventListenersForTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_EventDispatcher_removeEventListenersForTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->removeEventListenersForTarget(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool arg1;
            ok &= seval_to_boolean(args[1], &arg1);
            cobj->removeEventListenersForTarget(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::EventListener::Type arg0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            cobj->removeEventListenersForType(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_removeEventListenersForTarget)

static bool js_cocos2dx_EventDispatcher_resumeEventListenersForTarget(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_resumeEventListenersForTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_resumeEventListenersForTarget : Error processing arguments");
        cobj->resumeEventListenersForTarget(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        bool arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_resumeEventListenersForTarget : Error processing arguments");
        cobj->resumeEventListenersForTarget(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_resumeEventListenersForTarget)

static bool js_cocos2dx_EventDispatcher_setPriority(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_setPriority : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::EventListener* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_setPriority : Error processing arguments");
        cobj->setPriority(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_setPriority)

static bool js_cocos2dx_EventDispatcher_dispatchEvent(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_dispatchEvent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Event* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_dispatchEvent : Error processing arguments");
        cobj->dispatchEvent(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_dispatchEvent)

static bool js_cocos2dx_EventDispatcher_hasEventListener(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_hasEventListener : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventListener::ListenerID arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_hasEventListener : Error processing arguments");
        bool result = cobj->hasEventListener(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_hasEventListener : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_hasEventListener)

static bool js_cocos2dx_EventDispatcher_pauseEventListenersForTarget(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_pauseEventListenersForTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_pauseEventListenersForTarget : Error processing arguments");
        cobj->pauseEventListenersForTarget(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        bool arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_pauseEventListenersForTarget : Error processing arguments");
        cobj->pauseEventListenersForTarget(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_pauseEventListenersForTarget)

static bool js_cocos2dx_EventDispatcher_removeCustomEventListeners(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_removeCustomEventListeners : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_removeCustomEventListeners : Error processing arguments");
        cobj->removeCustomEventListeners(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_removeCustomEventListeners)

static bool js_cocos2dx_EventDispatcher_removeEventListener(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_removeEventListener : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventListener* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_removeEventListener : Error processing arguments");
        cobj->removeEventListener(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_removeEventListener)

static bool js_cocos2dx_EventDispatcher_isEnabled(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_isEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_isEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_isEnabled)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventDispatcher_finalize)

static bool js_cocos2dx_EventDispatcher_constructor(se::State& s)
{
    cocos2d::EventDispatcher* cobj = new (std::nothrow) cocos2d::EventDispatcher();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventDispatcher_constructor, __jsb_cocos2d_EventDispatcher_class, js_cocos2d_EventDispatcher_finalize)




bool js_cocos2d_EventDispatcher_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EventDispatcher)", s.nativeThisObject());
        cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventDispatcher_finalize)

bool js_register_cocos2dx_EventDispatcher(se::Object* obj)
{
    auto cls = se::Class::create("EventDispatcher", obj, nullptr, _SE(js_cocos2dx_EventDispatcher_constructor));

    cls->defineFunction("setEnabled", _SE(js_cocos2dx_EventDispatcher_setEnabled));
    cls->defineFunction("removeAllListeners", _SE(js_cocos2dx_EventDispatcher_removeAllEventListeners));
    cls->defineFunction("addEventListenerWithSceneGraphPriority", _SE(js_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority));
    cls->defineFunction("addEventListenerWithFixedPriority", _SE(js_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority));
    cls->defineFunction("removeListeners", _SE(js_cocos2dx_EventDispatcher_removeEventListenersForTarget));
    cls->defineFunction("resumeTarget", _SE(js_cocos2dx_EventDispatcher_resumeEventListenersForTarget));
    cls->defineFunction("setPriority", _SE(js_cocos2dx_EventDispatcher_setPriority));
    cls->defineFunction("dispatchEvent", _SE(js_cocos2dx_EventDispatcher_dispatchEvent));
    cls->defineFunction("hasEventListener", _SE(js_cocos2dx_EventDispatcher_hasEventListener));
    cls->defineFunction("pauseTarget", _SE(js_cocos2dx_EventDispatcher_pauseEventListenersForTarget));
    cls->defineFunction("removeCustomListeners", _SE(js_cocos2dx_EventDispatcher_removeCustomEventListeners));
    cls->defineFunction("removeListener", _SE(js_cocos2dx_EventDispatcher_removeEventListener));
    cls->defineFunction("isEnabled", _SE(js_cocos2dx_EventDispatcher_isEnabled));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EventDispatcher_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventDispatcher>(cls);

    __jsb_cocos2d_EventDispatcher_proto = cls->getProto();
    __jsb_cocos2d_EventDispatcher_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventFocus_proto = nullptr;
se::Class* __jsb_cocos2d_EventFocus_class = nullptr;


extern se::Object* __jsb_cocos2d_Event_proto;


bool js_register_cocos2dx_EventFocus(se::Object* obj)
{
    auto cls = se::Class::create("EventFocus", obj, __jsb_cocos2d_Event_proto, nullptr);

    cls->install();
    JSBClassType::registerClass<cocos2d::EventFocus>(cls);

    __jsb_cocos2d_EventFocus_proto = cls->getProto();
    __jsb_cocos2d_EventFocus_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventListenerAcceleration_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerAcceleration_class = nullptr;

static bool js_cocos2dx_EventListenerAcceleration_init(se::State& s)
{
    cocos2d::EventListenerAcceleration* cobj = (cocos2d::EventListenerAcceleration*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerAcceleration_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void (cocos2d::Acceleration *, cocos2d::Event *)> arg0;
        do {
		    if (args[0].isObject() && args[0].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[0]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](cocos2d::Acceleration* larg0, cocos2d::Event* larg1) -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(2);
		            ok &= Acceleration_to_seval(larg0, &args[0]);
		            ok &= native_ptr_to_seval<cocos2d::Event>((cocos2d::Event*)larg1, &args[1]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg0 = lambda;
		    }
		    else
		    {
		        arg0 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerAcceleration_init : Error processing arguments");
        bool result = cobj->init(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerAcceleration_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerAcceleration_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerAcceleration_finalize)

static bool js_cocos2dx_EventListenerAcceleration_constructor(se::State& s)
{
    cocos2d::EventListenerAcceleration* cobj = new (std::nothrow) cocos2d::EventListenerAcceleration();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerAcceleration_constructor, __jsb_cocos2d_EventListenerAcceleration_class, js_cocos2d_EventListenerAcceleration_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

bool js_cocos2d_EventListenerAcceleration_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EventListenerAcceleration)", s.nativeThisObject());
        cocos2d::EventListenerAcceleration* cobj = (cocos2d::EventListenerAcceleration*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerAcceleration_finalize)

bool js_register_cocos2dx_EventListenerAcceleration(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerAcceleration", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerAcceleration_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerAcceleration_init));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EventListenerAcceleration_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerAcceleration>(cls);

    __jsb_cocos2d_EventListenerAcceleration_proto = cls->getProto();
    __jsb_cocos2d_EventListenerAcceleration_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventListenerCustom_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerCustom_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerCustom_finalize)

static bool js_cocos2dx_EventListenerCustom_constructor(se::State& s)
{
    cocos2d::EventListenerCustom* cobj = new (std::nothrow) cocos2d::EventListenerCustom();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerCustom_constructor, __jsb_cocos2d_EventListenerCustom_class, js_cocos2d_EventListenerCustom_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

bool js_cocos2d_EventListenerCustom_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EventListenerCustom)", s.nativeThisObject());
        cocos2d::EventListenerCustom* cobj = (cocos2d::EventListenerCustom*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerCustom_finalize)

bool js_register_cocos2dx_EventListenerCustom(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerCustom", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerCustom_constructor));

    cls->defineFinalizedFunction(_SE(js_cocos2d_EventListenerCustom_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerCustom>(cls);

    __jsb_cocos2d_EventListenerCustom_proto = cls->getProto();
    __jsb_cocos2d_EventListenerCustom_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventListenerFocus_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerFocus_class = nullptr;

static bool js_cocos2dx_EventListenerFocus_init(se::State& s)
{
    cocos2d::EventListenerFocus* cobj = (cocos2d::EventListenerFocus*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerFocus_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerFocus_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerFocus_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerFocus_finalize)

static bool js_cocos2dx_EventListenerFocus_constructor(se::State& s)
{
    cocos2d::EventListenerFocus* cobj = new (std::nothrow) cocos2d::EventListenerFocus();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerFocus_constructor, __jsb_cocos2d_EventListenerFocus_class, js_cocos2d_EventListenerFocus_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

bool js_cocos2d_EventListenerFocus_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EventListenerFocus)", s.nativeThisObject());
        cocos2d::EventListenerFocus* cobj = (cocos2d::EventListenerFocus*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerFocus_finalize)

bool js_register_cocos2dx_EventListenerFocus(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerFocus", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerFocus_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerFocus_init));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EventListenerFocus_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerFocus>(cls);

    __jsb_cocos2d_EventListenerFocus_proto = cls->getProto();
    __jsb_cocos2d_EventListenerFocus_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventListenerKeyboard_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerKeyboard_class = nullptr;

static bool js_cocos2dx_EventListenerKeyboard_init(se::State& s)
{
    cocos2d::EventListenerKeyboard* cobj = (cocos2d::EventListenerKeyboard*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerKeyboard_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerKeyboard_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerKeyboard_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerKeyboard_finalize)

static bool js_cocos2dx_EventListenerKeyboard_constructor(se::State& s)
{
    cocos2d::EventListenerKeyboard* cobj = new (std::nothrow) cocos2d::EventListenerKeyboard();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerKeyboard_constructor, __jsb_cocos2d_EventListenerKeyboard_class, js_cocos2d_EventListenerKeyboard_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

bool js_cocos2d_EventListenerKeyboard_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EventListenerKeyboard)", s.nativeThisObject());
        cocos2d::EventListenerKeyboard* cobj = (cocos2d::EventListenerKeyboard*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerKeyboard_finalize)

bool js_register_cocos2dx_EventListenerKeyboard(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerKeyboard", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerKeyboard_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerKeyboard_init));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EventListenerKeyboard_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerKeyboard>(cls);

    __jsb_cocos2d_EventListenerKeyboard_proto = cls->getProto();
    __jsb_cocos2d_EventListenerKeyboard_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventMouse_proto = nullptr;
se::Class* __jsb_cocos2d_EventMouse_class = nullptr;

static bool js_cocos2dx_EventMouse_getMouseButton(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getMouseButton : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getMouseButton();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getMouseButton : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getMouseButton)

static bool js_cocos2dx_EventMouse_getLocation(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getLocation)

static bool js_cocos2dx_EventMouse_setMouseButton(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_setMouseButton : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventMouse::MouseButton arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_setMouseButton : Error processing arguments");
        cobj->setMouseButton(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_setMouseButton)

static bool js_cocos2dx_EventMouse_setScrollData(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_setScrollData : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_setScrollData : Error processing arguments");
        cobj->setScrollData(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_setScrollData)

static bool js_cocos2dx_EventMouse_getPreviousLocationInView(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getPreviousLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getPreviousLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getPreviousLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getPreviousLocationInView)

static bool js_cocos2dx_EventMouse_getDelta(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getDelta : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getDelta();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getDelta : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getDelta)

static bool js_cocos2dx_EventMouse_getStartLocation(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getStartLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getStartLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getStartLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getStartLocation)

static bool js_cocos2dx_EventMouse_getCursorY(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getCursorY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getCursorY();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getCursorY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getCursorY)

static bool js_cocos2dx_EventMouse_getCursorX(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getCursorX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getCursorX();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getCursorX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getCursorX)

static bool js_cocos2dx_EventMouse_getLocationInView(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getLocationInView)

static bool js_cocos2dx_EventMouse_getScrollY(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getScrollY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScrollY();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getScrollY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getScrollY)

static bool js_cocos2dx_EventMouse_setCursorPosition(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_setCursorPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_setCursorPosition : Error processing arguments");
        cobj->setCursorPosition(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_setCursorPosition)

static bool js_cocos2dx_EventMouse_getScrollX(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getScrollX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScrollX();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getScrollX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getScrollX)

static bool js_cocos2dx_EventMouse_getPreviousLocation(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getPreviousLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getPreviousLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getPreviousLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getPreviousLocation)

static bool js_cocos2dx_EventMouse_getStartLocationInView(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getStartLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getStartLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getStartLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getStartLocationInView)


extern se::Object* __jsb_cocos2d_Event_proto;


bool js_register_cocos2dx_EventMouse(se::Object* obj)
{
    auto cls = se::Class::create("EventMouse", obj, __jsb_cocos2d_Event_proto, nullptr);

    cls->defineFunction("getButton", _SE(js_cocos2dx_EventMouse_getMouseButton));
    cls->defineFunction("getLocation", _SE(js_cocos2dx_EventMouse_getLocation));
    cls->defineFunction("setButton", _SE(js_cocos2dx_EventMouse_setMouseButton));
    cls->defineFunction("setScrollData", _SE(js_cocos2dx_EventMouse_setScrollData));
    cls->defineFunction("getPreviousLocationInView", _SE(js_cocos2dx_EventMouse_getPreviousLocationInView));
    cls->defineFunction("getDelta", _SE(js_cocos2dx_EventMouse_getDelta));
    cls->defineFunction("getStartLocation", _SE(js_cocos2dx_EventMouse_getStartLocation));
    cls->defineFunction("getLocationY", _SE(js_cocos2dx_EventMouse_getCursorY));
    cls->defineFunction("getLocationX", _SE(js_cocos2dx_EventMouse_getCursorX));
    cls->defineFunction("getLocationInView", _SE(js_cocos2dx_EventMouse_getLocationInView));
    cls->defineFunction("getScrollY", _SE(js_cocos2dx_EventMouse_getScrollY));
    cls->defineFunction("setLocation", _SE(js_cocos2dx_EventMouse_setCursorPosition));
    cls->defineFunction("getScrollX", _SE(js_cocos2dx_EventMouse_getScrollX));
    cls->defineFunction("getPreviousLocation", _SE(js_cocos2dx_EventMouse_getPreviousLocation));
    cls->defineFunction("getStartLocationInView", _SE(js_cocos2dx_EventMouse_getStartLocationInView));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventMouse>(cls);

    __jsb_cocos2d_EventMouse_proto = cls->getProto();
    __jsb_cocos2d_EventMouse_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventListenerMouse_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerMouse_class = nullptr;

static bool js_cocos2dx_EventListenerMouse_init(se::State& s)
{
    cocos2d::EventListenerMouse* cobj = (cocos2d::EventListenerMouse*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerMouse_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerMouse_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerMouse_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerMouse_finalize)

static bool js_cocos2dx_EventListenerMouse_constructor(se::State& s)
{
    cocos2d::EventListenerMouse* cobj = new (std::nothrow) cocos2d::EventListenerMouse();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerMouse_constructor, __jsb_cocos2d_EventListenerMouse_class, js_cocos2d_EventListenerMouse_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

bool js_cocos2d_EventListenerMouse_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EventListenerMouse)", s.nativeThisObject());
        cocos2d::EventListenerMouse* cobj = (cocos2d::EventListenerMouse*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerMouse_finalize)

bool js_register_cocos2dx_EventListenerMouse(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerMouse", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerMouse_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerMouse_init));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EventListenerMouse_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerMouse>(cls);

    __jsb_cocos2d_EventListenerMouse_proto = cls->getProto();
    __jsb_cocos2d_EventListenerMouse_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventListenerTouchOneByOne_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerTouchOneByOne_class = nullptr;

static bool js_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches(se::State& s)
{
    cocos2d::EventListenerTouchOneByOne* cobj = (cocos2d::EventListenerTouchOneByOne*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isSwallowTouches();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches)

static bool js_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches(se::State& s)
{
    cocos2d::EventListenerTouchOneByOne* cobj = (cocos2d::EventListenerTouchOneByOne*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches : Error processing arguments");
        cobj->setSwallowTouches(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches)

static bool js_cocos2dx_EventListenerTouchOneByOne_init(se::State& s)
{
    cocos2d::EventListenerTouchOneByOne* cobj = (cocos2d::EventListenerTouchOneByOne*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerTouchOneByOne_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerTouchOneByOne_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerTouchOneByOne_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerTouchOneByOne_finalize)

static bool js_cocos2dx_EventListenerTouchOneByOne_constructor(se::State& s)
{
    cocos2d::EventListenerTouchOneByOne* cobj = new (std::nothrow) cocos2d::EventListenerTouchOneByOne();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerTouchOneByOne_constructor, __jsb_cocos2d_EventListenerTouchOneByOne_class, js_cocos2d_EventListenerTouchOneByOne_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

bool js_cocos2d_EventListenerTouchOneByOne_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EventListenerTouchOneByOne)", s.nativeThisObject());
        cocos2d::EventListenerTouchOneByOne* cobj = (cocos2d::EventListenerTouchOneByOne*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerTouchOneByOne_finalize)

bool js_register_cocos2dx_EventListenerTouchOneByOne(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerTouchOneByOne", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerTouchOneByOne_constructor));

    cls->defineFunction("isSwallowTouches", _SE(js_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches));
    cls->defineFunction("setSwallowTouches", _SE(js_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches));
    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerTouchOneByOne_init));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EventListenerTouchOneByOne_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerTouchOneByOne>(cls);

    __jsb_cocos2d_EventListenerTouchOneByOne_proto = cls->getProto();
    __jsb_cocos2d_EventListenerTouchOneByOne_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EventListenerTouchAllAtOnce_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerTouchAllAtOnce_class = nullptr;

static bool js_cocos2dx_EventListenerTouchAllAtOnce_init(se::State& s)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = (cocos2d::EventListenerTouchAllAtOnce*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerTouchAllAtOnce_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerTouchAllAtOnce_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerTouchAllAtOnce_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerTouchAllAtOnce_finalize)

static bool js_cocos2dx_EventListenerTouchAllAtOnce_constructor(se::State& s)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = new (std::nothrow) cocos2d::EventListenerTouchAllAtOnce();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerTouchAllAtOnce_constructor, __jsb_cocos2d_EventListenerTouchAllAtOnce_class, js_cocos2d_EventListenerTouchAllAtOnce_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

bool js_cocos2d_EventListenerTouchAllAtOnce_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EventListenerTouchAllAtOnce)", s.nativeThisObject());
        cocos2d::EventListenerTouchAllAtOnce* cobj = (cocos2d::EventListenerTouchAllAtOnce*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerTouchAllAtOnce_finalize)

bool js_register_cocos2dx_EventListenerTouchAllAtOnce(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerTouchAllAtOnce", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerTouchAllAtOnce_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerTouchAllAtOnce_init));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EventListenerTouchAllAtOnce_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerTouchAllAtOnce>(cls);

    __jsb_cocos2d_EventListenerTouchAllAtOnce_proto = cls->getProto();
    __jsb_cocos2d_EventListenerTouchAllAtOnce_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ActionCamera_proto = nullptr;
se::Class* __jsb_cocos2d_ActionCamera_class = nullptr;

static bool js_cocos2dx_ActionCamera_setEye(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::ActionCamera* cobj = (cocos2d::ActionCamera*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_ActionCamera_setEye : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->setEye(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Vec3 arg0;
            ok &= seval_to_Vec3(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setEye(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionCamera_setEye)

static bool js_cocos2dx_ActionCamera_getEye(se::State& s)
{
    cocos2d::ActionCamera* cobj = (cocos2d::ActionCamera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionCamera_getEye : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec3& result = cobj->getEye();
        ok &= Vec3_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionCamera_getEye : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionCamera_getEye)

static bool js_cocos2dx_ActionCamera_setUp(se::State& s)
{
    cocos2d::ActionCamera* cobj = (cocos2d::ActionCamera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionCamera_setUp : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec3 arg0;
        ok &= seval_to_Vec3(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionCamera_setUp : Error processing arguments");
        cobj->setUp(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionCamera_setUp)

static bool js_cocos2dx_ActionCamera_getCenter(se::State& s)
{
    cocos2d::ActionCamera* cobj = (cocos2d::ActionCamera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionCamera_getCenter : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec3& result = cobj->getCenter();
        ok &= Vec3_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionCamera_getCenter : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionCamera_getCenter)

static bool js_cocos2dx_ActionCamera_setCenter(se::State& s)
{
    cocos2d::ActionCamera* cobj = (cocos2d::ActionCamera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionCamera_setCenter : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec3 arg0;
        ok &= seval_to_Vec3(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionCamera_setCenter : Error processing arguments");
        cobj->setCenter(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionCamera_setCenter)

static bool js_cocos2dx_ActionCamera_getUp(se::State& s)
{
    cocos2d::ActionCamera* cobj = (cocos2d::ActionCamera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionCamera_getUp : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec3& result = cobj->getUp();
        ok &= Vec3_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionCamera_getUp : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionCamera_getUp)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ActionCamera_finalize)

static bool js_cocos2dx_ActionCamera_constructor(se::State& s)
{
    cocos2d::ActionCamera* cobj = new (std::nothrow) cocos2d::ActionCamera();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ActionCamera_constructor, __jsb_cocos2d_ActionCamera_class, js_cocos2d_ActionCamera_finalize)

static bool js_cocos2dx_ActionCamera_ctor(se::State& s)
{
    cocos2d::ActionCamera* cobj = new (std::nothrow) cocos2d::ActionCamera();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ActionCamera_ctor, __jsb_cocos2d_ActionCamera_class, js_cocos2d_ActionCamera_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_ActionCamera_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ActionCamera)", s.nativeThisObject());
        cocos2d::ActionCamera* cobj = (cocos2d::ActionCamera*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ActionCamera_finalize)

bool js_register_cocos2dx_ActionCamera(se::Object* obj)
{
    auto cls = se::Class::create("ActionCamera", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_ActionCamera_constructor));

    cls->defineFunction("setEye", _SE(js_cocos2dx_ActionCamera_setEye));
    cls->defineFunction("getEye", _SE(js_cocos2dx_ActionCamera_getEye));
    cls->defineFunction("setUp", _SE(js_cocos2dx_ActionCamera_setUp));
    cls->defineFunction("getCenter", _SE(js_cocos2dx_ActionCamera_getCenter));
    cls->defineFunction("setCenter", _SE(js_cocos2dx_ActionCamera_setCenter));
    cls->defineFunction("getUp", _SE(js_cocos2dx_ActionCamera_getUp));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ActionCamera_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ActionCamera_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ActionCamera>(cls);

    __jsb_cocos2d_ActionCamera_proto = cls->getProto();
    __jsb_cocos2d_ActionCamera_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ActionCamera.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_OrbitCamera_proto = nullptr;
se::Class* __jsb_cocos2d_OrbitCamera_class = nullptr;

static bool js_cocos2dx_OrbitCamera_sphericalRadius(se::State& s)
{
    cocos2d::OrbitCamera* cobj = (cocos2d::OrbitCamera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_OrbitCamera_sphericalRadius : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float* arg0 = 0;
        float* arg1 = 0;
        float* arg2 = 0;
        #pragma warning NO CONVERSION TO NATIVE FOR float*
		ok = false;
        #pragma warning NO CONVERSION TO NATIVE FOR float*
		ok = false;
        #pragma warning NO CONVERSION TO NATIVE FOR float*
		ok = false;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_OrbitCamera_sphericalRadius : Error processing arguments");
        cobj->sphericalRadius(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_OrbitCamera_sphericalRadius)

static bool js_cocos2dx_OrbitCamera_initWithDuration(se::State& s)
{
    cocos2d::OrbitCamera* cobj = (cocos2d::OrbitCamera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_OrbitCamera_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 7) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        float arg4 = 0;
        float arg5 = 0;
        float arg6 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        ok &= seval_to_float(args[4], &arg4);
        ok &= seval_to_float(args[5], &arg5);
        ok &= seval_to_float(args[6], &arg6);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_OrbitCamera_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_OrbitCamera_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 7);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_OrbitCamera_initWithDuration)

static bool js_cocos2dx_OrbitCamera_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 7) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        float arg4 = 0;
        float arg5 = 0;
        float arg6 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        ok &= seval_to_float(args[4], &arg4);
        ok &= seval_to_float(args[5], &arg5);
        ok &= seval_to_float(args[6], &arg6);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_OrbitCamera_create : Error processing arguments");
        auto result = cocos2d::OrbitCamera::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_OrbitCamera_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 7);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_OrbitCamera_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_OrbitCamera_finalize)

static bool js_cocos2dx_OrbitCamera_constructor(se::State& s)
{
    cocos2d::OrbitCamera* cobj = new (std::nothrow) cocos2d::OrbitCamera();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_OrbitCamera_constructor, __jsb_cocos2d_OrbitCamera_class, js_cocos2d_OrbitCamera_finalize)

static bool js_cocos2dx_OrbitCamera_ctor(se::State& s)
{
    cocos2d::OrbitCamera* cobj = new (std::nothrow) cocos2d::OrbitCamera();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_OrbitCamera_ctor, __jsb_cocos2d_OrbitCamera_class, js_cocos2d_OrbitCamera_finalize)


    

extern se::Object* __jsb_cocos2d_ActionCamera_proto;

bool js_cocos2d_OrbitCamera_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::OrbitCamera)", s.nativeThisObject());
        cocos2d::OrbitCamera* cobj = (cocos2d::OrbitCamera*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_OrbitCamera_finalize)

bool js_register_cocos2dx_OrbitCamera(se::Object* obj)
{
    auto cls = se::Class::create("OrbitCamera", obj, __jsb_cocos2d_ActionCamera_proto, _SE(js_cocos2dx_OrbitCamera_constructor));

    cls->defineFunction("sphericalRadius", _SE(js_cocos2dx_OrbitCamera_sphericalRadius));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_OrbitCamera_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_OrbitCamera_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_OrbitCamera_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_OrbitCamera_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::OrbitCamera>(cls);

    __jsb_cocos2d_OrbitCamera_proto = cls->getProto();
    __jsb_cocos2d_OrbitCamera_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.OrbitCamera.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_CardinalSplineTo_proto = nullptr;
se::Class* __jsb_cocos2d_CardinalSplineTo_class = nullptr;

static bool js_cocos2dx_CardinalSplineTo_updatePosition(se::State& s)
{
    cocos2d::CardinalSplineTo* cobj = (cocos2d::CardinalSplineTo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CardinalSplineTo_updatePosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CardinalSplineTo_updatePosition : Error processing arguments");
        cobj->updatePosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CardinalSplineTo_updatePosition)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CardinalSplineTo_finalize)

static bool js_cocos2dx_CardinalSplineTo_constructor(se::State& s)
{
    cocos2d::CardinalSplineTo* cobj = new (std::nothrow) cocos2d::CardinalSplineTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CardinalSplineTo_constructor, __jsb_cocos2d_CardinalSplineTo_class, js_cocos2d_CardinalSplineTo_finalize)



extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_CardinalSplineTo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::CardinalSplineTo)", s.nativeThisObject());
        cocos2d::CardinalSplineTo* cobj = (cocos2d::CardinalSplineTo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CardinalSplineTo_finalize)

bool js_register_cocos2dx_CardinalSplineTo(se::Object* obj)
{
    auto cls = se::Class::create("CardinalSplineTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_CardinalSplineTo_constructor));

    cls->defineFunction("updatePosition", _SE(js_cocos2dx_CardinalSplineTo_updatePosition));
    cls->defineFinalizedFunction(_SE(js_cocos2d_CardinalSplineTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CardinalSplineTo>(cls);

    __jsb_cocos2d_CardinalSplineTo_proto = cls->getProto();
    __jsb_cocos2d_CardinalSplineTo_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_CardinalSplineBy_proto = nullptr;
se::Class* __jsb_cocos2d_CardinalSplineBy_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CardinalSplineBy_finalize)

static bool js_cocos2dx_CardinalSplineBy_constructor(se::State& s)
{
    cocos2d::CardinalSplineBy* cobj = new (std::nothrow) cocos2d::CardinalSplineBy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CardinalSplineBy_constructor, __jsb_cocos2d_CardinalSplineBy_class, js_cocos2d_CardinalSplineBy_finalize)



extern se::Object* __jsb_cocos2d_CardinalSplineTo_proto;

bool js_cocos2d_CardinalSplineBy_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::CardinalSplineBy)", s.nativeThisObject());
        cocos2d::CardinalSplineBy* cobj = (cocos2d::CardinalSplineBy*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CardinalSplineBy_finalize)

bool js_register_cocos2dx_CardinalSplineBy(se::Object* obj)
{
    auto cls = se::Class::create("CardinalSplineBy", obj, __jsb_cocos2d_CardinalSplineTo_proto, _SE(js_cocos2dx_CardinalSplineBy_constructor));

    cls->defineFinalizedFunction(_SE(js_cocos2d_CardinalSplineBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CardinalSplineBy>(cls);

    __jsb_cocos2d_CardinalSplineBy_proto = cls->getProto();
    __jsb_cocos2d_CardinalSplineBy_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_CatmullRomTo_proto = nullptr;
se::Class* __jsb_cocos2d_CatmullRomTo_class = nullptr;


extern se::Object* __jsb_cocos2d_CardinalSplineTo_proto;


bool js_register_cocos2dx_CatmullRomTo(se::Object* obj)
{
    auto cls = se::Class::create("CatmullRomTo", obj, __jsb_cocos2d_CardinalSplineTo_proto, nullptr);

    cls->install();
    JSBClassType::registerClass<cocos2d::CatmullRomTo>(cls);

    __jsb_cocos2d_CatmullRomTo_proto = cls->getProto();
    __jsb_cocos2d_CatmullRomTo_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_CatmullRomBy_proto = nullptr;
se::Class* __jsb_cocos2d_CatmullRomBy_class = nullptr;


extern se::Object* __jsb_cocos2d_CardinalSplineBy_proto;


bool js_register_cocos2dx_CatmullRomBy(se::Object* obj)
{
    auto cls = se::Class::create("CatmullRomBy", obj, __jsb_cocos2d_CardinalSplineBy_proto, nullptr);

    cls->install();
    JSBClassType::registerClass<cocos2d::CatmullRomBy>(cls);

    __jsb_cocos2d_CatmullRomBy_proto = cls->getProto();
    __jsb_cocos2d_CatmullRomBy_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ActionEase_proto = nullptr;
se::Class* __jsb_cocos2d_ActionEase_class = nullptr;

static bool js_cocos2dx_ActionEase_initWithAction(se::State& s)
{
    cocos2d::ActionEase* cobj = (cocos2d::ActionEase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionEase_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionEase_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionEase_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionEase_initWithAction)

static bool js_cocos2dx_ActionEase_getInnerAction(se::State& s)
{
    cocos2d::ActionEase* cobj = (cocos2d::ActionEase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionEase_getInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ActionInterval* result = cobj->getInnerAction();
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionEase_getInnerAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionEase_getInnerAction)


extern se::Object* __jsb_cocos2d_ActionInterval_proto;


bool js_register_cocos2dx_ActionEase(se::Object* obj)
{
    auto cls = se::Class::create("ActionEase", obj, __jsb_cocos2d_ActionInterval_proto, nullptr);

    cls->defineFunction("initWithAction", _SE(js_cocos2dx_ActionEase_initWithAction));
    cls->defineFunction("getInnerAction", _SE(js_cocos2dx_ActionEase_getInnerAction));
    cls->install();
    JSBClassType::registerClass<cocos2d::ActionEase>(cls);

    __jsb_cocos2d_ActionEase_proto = cls->getProto();
    __jsb_cocos2d_ActionEase_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EaseRateAction_proto = nullptr;
se::Class* __jsb_cocos2d_EaseRateAction_class = nullptr;

static bool js_cocos2dx_EaseRateAction_setRate(se::State& s)
{
    cocos2d::EaseRateAction* cobj = (cocos2d::EaseRateAction*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EaseRateAction_setRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseRateAction_setRate : Error processing arguments");
        cobj->setRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseRateAction_setRate)

static bool js_cocos2dx_EaseRateAction_initWithAction(se::State& s)
{
    cocos2d::EaseRateAction* cobj = (cocos2d::EaseRateAction*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EaseRateAction_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseRateAction_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseRateAction_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseRateAction_initWithAction)

static bool js_cocos2dx_EaseRateAction_getRate(se::State& s)
{
    cocos2d::EaseRateAction* cobj = (cocos2d::EaseRateAction*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EaseRateAction_getRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRate();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseRateAction_getRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseRateAction_getRate)

static bool js_cocos2dx_EaseRateAction_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseRateAction_create : Error processing arguments");
        auto result = cocos2d::EaseRateAction::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseRateAction_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseRateAction_create)


extern se::Object* __jsb_cocos2d_ActionEase_proto;


bool js_register_cocos2dx_EaseRateAction(se::Object* obj)
{
    auto cls = se::Class::create("EaseRateAction", obj, __jsb_cocos2d_ActionEase_proto, nullptr);

    cls->defineFunction("setRate", _SE(js_cocos2dx_EaseRateAction_setRate));
    cls->defineFunction("initWithAction", _SE(js_cocos2dx_EaseRateAction_initWithAction));
    cls->defineFunction("getRate", _SE(js_cocos2dx_EaseRateAction_getRate));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseRateAction_create));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseRateAction>(cls);

    __jsb_cocos2d_EaseRateAction_proto = cls->getProto();
    __jsb_cocos2d_EaseRateAction_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EaseExponentialIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseExponentialIn_class = nullptr;

static bool js_cocos2dx_EaseExponentialIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseExponentialIn_create : Error processing arguments");
        auto result = cocos2d::EaseExponentialIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseExponentialIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseExponentialIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseExponentialIn_finalize)

static bool js_cocos2dx_EaseExponentialIn_constructor(se::State& s)
{
    cocos2d::EaseExponentialIn* cobj = new (std::nothrow) cocos2d::EaseExponentialIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseExponentialIn_constructor, __jsb_cocos2d_EaseExponentialIn_class, js_cocos2d_EaseExponentialIn_finalize)

static bool js_cocos2dx_EaseExponentialIn_ctor(se::State& s)
{
    cocos2d::EaseExponentialIn* cobj = new (std::nothrow) cocos2d::EaseExponentialIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseExponentialIn_ctor, __jsb_cocos2d_EaseExponentialIn_class, js_cocos2d_EaseExponentialIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseExponentialIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseExponentialIn)", s.nativeThisObject());
        cocos2d::EaseExponentialIn* cobj = (cocos2d::EaseExponentialIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseExponentialIn_finalize)

bool js_register_cocos2dx_EaseExponentialIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseExponentialIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseExponentialIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseExponentialIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseExponentialIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseExponentialIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseExponentialIn>(cls);

    __jsb_cocos2d_EaseExponentialIn_proto = cls->getProto();
    __jsb_cocos2d_EaseExponentialIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseExponentialIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseExponentialOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseExponentialOut_class = nullptr;

static bool js_cocos2dx_EaseExponentialOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseExponentialOut_create : Error processing arguments");
        auto result = cocos2d::EaseExponentialOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseExponentialOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseExponentialOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseExponentialOut_finalize)

static bool js_cocos2dx_EaseExponentialOut_constructor(se::State& s)
{
    cocos2d::EaseExponentialOut* cobj = new (std::nothrow) cocos2d::EaseExponentialOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseExponentialOut_constructor, __jsb_cocos2d_EaseExponentialOut_class, js_cocos2d_EaseExponentialOut_finalize)

static bool js_cocos2dx_EaseExponentialOut_ctor(se::State& s)
{
    cocos2d::EaseExponentialOut* cobj = new (std::nothrow) cocos2d::EaseExponentialOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseExponentialOut_ctor, __jsb_cocos2d_EaseExponentialOut_class, js_cocos2d_EaseExponentialOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseExponentialOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseExponentialOut)", s.nativeThisObject());
        cocos2d::EaseExponentialOut* cobj = (cocos2d::EaseExponentialOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseExponentialOut_finalize)

bool js_register_cocos2dx_EaseExponentialOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseExponentialOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseExponentialOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseExponentialOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseExponentialOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseExponentialOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseExponentialOut>(cls);

    __jsb_cocos2d_EaseExponentialOut_proto = cls->getProto();
    __jsb_cocos2d_EaseExponentialOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseExponentialOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseExponentialInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseExponentialInOut_class = nullptr;

static bool js_cocos2dx_EaseExponentialInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseExponentialInOut_create : Error processing arguments");
        auto result = cocos2d::EaseExponentialInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseExponentialInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseExponentialInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseExponentialInOut_finalize)

static bool js_cocos2dx_EaseExponentialInOut_constructor(se::State& s)
{
    cocos2d::EaseExponentialInOut* cobj = new (std::nothrow) cocos2d::EaseExponentialInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseExponentialInOut_constructor, __jsb_cocos2d_EaseExponentialInOut_class, js_cocos2d_EaseExponentialInOut_finalize)

static bool js_cocos2dx_EaseExponentialInOut_ctor(se::State& s)
{
    cocos2d::EaseExponentialInOut* cobj = new (std::nothrow) cocos2d::EaseExponentialInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseExponentialInOut_ctor, __jsb_cocos2d_EaseExponentialInOut_class, js_cocos2d_EaseExponentialInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseExponentialInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseExponentialInOut)", s.nativeThisObject());
        cocos2d::EaseExponentialInOut* cobj = (cocos2d::EaseExponentialInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseExponentialInOut_finalize)

bool js_register_cocos2dx_EaseExponentialInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseExponentialInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseExponentialInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseExponentialInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseExponentialInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseExponentialInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseExponentialInOut>(cls);

    __jsb_cocos2d_EaseExponentialInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseExponentialInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseExponentialInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseSineIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseSineIn_class = nullptr;

static bool js_cocos2dx_EaseSineIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseSineIn_create : Error processing arguments");
        auto result = cocos2d::EaseSineIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseSineIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseSineIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseSineIn_finalize)

static bool js_cocos2dx_EaseSineIn_constructor(se::State& s)
{
    cocos2d::EaseSineIn* cobj = new (std::nothrow) cocos2d::EaseSineIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseSineIn_constructor, __jsb_cocos2d_EaseSineIn_class, js_cocos2d_EaseSineIn_finalize)

static bool js_cocos2dx_EaseSineIn_ctor(se::State& s)
{
    cocos2d::EaseSineIn* cobj = new (std::nothrow) cocos2d::EaseSineIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseSineIn_ctor, __jsb_cocos2d_EaseSineIn_class, js_cocos2d_EaseSineIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseSineIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseSineIn)", s.nativeThisObject());
        cocos2d::EaseSineIn* cobj = (cocos2d::EaseSineIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseSineIn_finalize)

bool js_register_cocos2dx_EaseSineIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseSineIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseSineIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseSineIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseSineIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseSineIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseSineIn>(cls);

    __jsb_cocos2d_EaseSineIn_proto = cls->getProto();
    __jsb_cocos2d_EaseSineIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseSineIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseSineOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseSineOut_class = nullptr;

static bool js_cocos2dx_EaseSineOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseSineOut_create : Error processing arguments");
        auto result = cocos2d::EaseSineOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseSineOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseSineOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseSineOut_finalize)

static bool js_cocos2dx_EaseSineOut_constructor(se::State& s)
{
    cocos2d::EaseSineOut* cobj = new (std::nothrow) cocos2d::EaseSineOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseSineOut_constructor, __jsb_cocos2d_EaseSineOut_class, js_cocos2d_EaseSineOut_finalize)

static bool js_cocos2dx_EaseSineOut_ctor(se::State& s)
{
    cocos2d::EaseSineOut* cobj = new (std::nothrow) cocos2d::EaseSineOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseSineOut_ctor, __jsb_cocos2d_EaseSineOut_class, js_cocos2d_EaseSineOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseSineOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseSineOut)", s.nativeThisObject());
        cocos2d::EaseSineOut* cobj = (cocos2d::EaseSineOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseSineOut_finalize)

bool js_register_cocos2dx_EaseSineOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseSineOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseSineOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseSineOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseSineOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseSineOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseSineOut>(cls);

    __jsb_cocos2d_EaseSineOut_proto = cls->getProto();
    __jsb_cocos2d_EaseSineOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseSineOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseSineInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseSineInOut_class = nullptr;

static bool js_cocos2dx_EaseSineInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseSineInOut_create : Error processing arguments");
        auto result = cocos2d::EaseSineInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseSineInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseSineInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseSineInOut_finalize)

static bool js_cocos2dx_EaseSineInOut_constructor(se::State& s)
{
    cocos2d::EaseSineInOut* cobj = new (std::nothrow) cocos2d::EaseSineInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseSineInOut_constructor, __jsb_cocos2d_EaseSineInOut_class, js_cocos2d_EaseSineInOut_finalize)

static bool js_cocos2dx_EaseSineInOut_ctor(se::State& s)
{
    cocos2d::EaseSineInOut* cobj = new (std::nothrow) cocos2d::EaseSineInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseSineInOut_ctor, __jsb_cocos2d_EaseSineInOut_class, js_cocos2d_EaseSineInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseSineInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseSineInOut)", s.nativeThisObject());
        cocos2d::EaseSineInOut* cobj = (cocos2d::EaseSineInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseSineInOut_finalize)

bool js_register_cocos2dx_EaseSineInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseSineInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseSineInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseSineInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseSineInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseSineInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseSineInOut>(cls);

    __jsb_cocos2d_EaseSineInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseSineInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseSineInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseBounce_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBounce_class = nullptr;


extern se::Object* __jsb_cocos2d_ActionEase_proto;


bool js_register_cocos2dx_EaseBounce(se::Object* obj)
{
    auto cls = se::Class::create("EaseBounce", obj, __jsb_cocos2d_ActionEase_proto, nullptr);

    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBounce>(cls);

    __jsb_cocos2d_EaseBounce_proto = cls->getProto();
    __jsb_cocos2d_EaseBounce_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EaseBounceIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBounceIn_class = nullptr;

static bool js_cocos2dx_EaseBounceIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseBounceIn_create : Error processing arguments");
        auto result = cocos2d::EaseBounceIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBounceIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBounceIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBounceIn_finalize)

static bool js_cocos2dx_EaseBounceIn_constructor(se::State& s)
{
    cocos2d::EaseBounceIn* cobj = new (std::nothrow) cocos2d::EaseBounceIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBounceIn_constructor, __jsb_cocos2d_EaseBounceIn_class, js_cocos2d_EaseBounceIn_finalize)

static bool js_cocos2dx_EaseBounceIn_ctor(se::State& s)
{
    cocos2d::EaseBounceIn* cobj = new (std::nothrow) cocos2d::EaseBounceIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBounceIn_ctor, __jsb_cocos2d_EaseBounceIn_class, js_cocos2d_EaseBounceIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseBounceIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseBounceIn)", s.nativeThisObject());
        cocos2d::EaseBounceIn* cobj = (cocos2d::EaseBounceIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBounceIn_finalize)

bool js_register_cocos2dx_EaseBounceIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseBounceIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseBounceIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBounceIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBounceIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseBounceIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBounceIn>(cls);

    __jsb_cocos2d_EaseBounceIn_proto = cls->getProto();
    __jsb_cocos2d_EaseBounceIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseBounceIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseBounceOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBounceOut_class = nullptr;

static bool js_cocos2dx_EaseBounceOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseBounceOut_create : Error processing arguments");
        auto result = cocos2d::EaseBounceOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBounceOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBounceOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBounceOut_finalize)

static bool js_cocos2dx_EaseBounceOut_constructor(se::State& s)
{
    cocos2d::EaseBounceOut* cobj = new (std::nothrow) cocos2d::EaseBounceOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBounceOut_constructor, __jsb_cocos2d_EaseBounceOut_class, js_cocos2d_EaseBounceOut_finalize)

static bool js_cocos2dx_EaseBounceOut_ctor(se::State& s)
{
    cocos2d::EaseBounceOut* cobj = new (std::nothrow) cocos2d::EaseBounceOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBounceOut_ctor, __jsb_cocos2d_EaseBounceOut_class, js_cocos2d_EaseBounceOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseBounceOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseBounceOut)", s.nativeThisObject());
        cocos2d::EaseBounceOut* cobj = (cocos2d::EaseBounceOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBounceOut_finalize)

bool js_register_cocos2dx_EaseBounceOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseBounceOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseBounceOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBounceOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBounceOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseBounceOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBounceOut>(cls);

    __jsb_cocos2d_EaseBounceOut_proto = cls->getProto();
    __jsb_cocos2d_EaseBounceOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseBounceOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseBounceInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBounceInOut_class = nullptr;

static bool js_cocos2dx_EaseBounceInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseBounceInOut_create : Error processing arguments");
        auto result = cocos2d::EaseBounceInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBounceInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBounceInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBounceInOut_finalize)

static bool js_cocos2dx_EaseBounceInOut_constructor(se::State& s)
{
    cocos2d::EaseBounceInOut* cobj = new (std::nothrow) cocos2d::EaseBounceInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBounceInOut_constructor, __jsb_cocos2d_EaseBounceInOut_class, js_cocos2d_EaseBounceInOut_finalize)

static bool js_cocos2dx_EaseBounceInOut_ctor(se::State& s)
{
    cocos2d::EaseBounceInOut* cobj = new (std::nothrow) cocos2d::EaseBounceInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBounceInOut_ctor, __jsb_cocos2d_EaseBounceInOut_class, js_cocos2d_EaseBounceInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseBounceInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseBounceInOut)", s.nativeThisObject());
        cocos2d::EaseBounceInOut* cobj = (cocos2d::EaseBounceInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBounceInOut_finalize)

bool js_register_cocos2dx_EaseBounceInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseBounceInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseBounceInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBounceInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBounceInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseBounceInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBounceInOut>(cls);

    __jsb_cocos2d_EaseBounceInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseBounceInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseBounceInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseBackIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBackIn_class = nullptr;

static bool js_cocos2dx_EaseBackIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseBackIn_create : Error processing arguments");
        auto result = cocos2d::EaseBackIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBackIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBackIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBackIn_finalize)

static bool js_cocos2dx_EaseBackIn_constructor(se::State& s)
{
    cocos2d::EaseBackIn* cobj = new (std::nothrow) cocos2d::EaseBackIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBackIn_constructor, __jsb_cocos2d_EaseBackIn_class, js_cocos2d_EaseBackIn_finalize)

static bool js_cocos2dx_EaseBackIn_ctor(se::State& s)
{
    cocos2d::EaseBackIn* cobj = new (std::nothrow) cocos2d::EaseBackIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBackIn_ctor, __jsb_cocos2d_EaseBackIn_class, js_cocos2d_EaseBackIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseBackIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseBackIn)", s.nativeThisObject());
        cocos2d::EaseBackIn* cobj = (cocos2d::EaseBackIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBackIn_finalize)

bool js_register_cocos2dx_EaseBackIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseBackIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseBackIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBackIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBackIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseBackIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBackIn>(cls);

    __jsb_cocos2d_EaseBackIn_proto = cls->getProto();
    __jsb_cocos2d_EaseBackIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseBackIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseBackOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBackOut_class = nullptr;

static bool js_cocos2dx_EaseBackOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseBackOut_create : Error processing arguments");
        auto result = cocos2d::EaseBackOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBackOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBackOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBackOut_finalize)

static bool js_cocos2dx_EaseBackOut_constructor(se::State& s)
{
    cocos2d::EaseBackOut* cobj = new (std::nothrow) cocos2d::EaseBackOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBackOut_constructor, __jsb_cocos2d_EaseBackOut_class, js_cocos2d_EaseBackOut_finalize)

static bool js_cocos2dx_EaseBackOut_ctor(se::State& s)
{
    cocos2d::EaseBackOut* cobj = new (std::nothrow) cocos2d::EaseBackOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBackOut_ctor, __jsb_cocos2d_EaseBackOut_class, js_cocos2d_EaseBackOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseBackOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseBackOut)", s.nativeThisObject());
        cocos2d::EaseBackOut* cobj = (cocos2d::EaseBackOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBackOut_finalize)

bool js_register_cocos2dx_EaseBackOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseBackOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseBackOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBackOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBackOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseBackOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBackOut>(cls);

    __jsb_cocos2d_EaseBackOut_proto = cls->getProto();
    __jsb_cocos2d_EaseBackOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseBackOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseBackInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBackInOut_class = nullptr;

static bool js_cocos2dx_EaseBackInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseBackInOut_create : Error processing arguments");
        auto result = cocos2d::EaseBackInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBackInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBackInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBackInOut_finalize)

static bool js_cocos2dx_EaseBackInOut_constructor(se::State& s)
{
    cocos2d::EaseBackInOut* cobj = new (std::nothrow) cocos2d::EaseBackInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBackInOut_constructor, __jsb_cocos2d_EaseBackInOut_class, js_cocos2d_EaseBackInOut_finalize)

static bool js_cocos2dx_EaseBackInOut_ctor(se::State& s)
{
    cocos2d::EaseBackInOut* cobj = new (std::nothrow) cocos2d::EaseBackInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBackInOut_ctor, __jsb_cocos2d_EaseBackInOut_class, js_cocos2d_EaseBackInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseBackInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseBackInOut)", s.nativeThisObject());
        cocos2d::EaseBackInOut* cobj = (cocos2d::EaseBackInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBackInOut_finalize)

bool js_register_cocos2dx_EaseBackInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseBackInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseBackInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBackInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBackInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseBackInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBackInOut>(cls);

    __jsb_cocos2d_EaseBackInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseBackInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseBackInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseQuadraticActionIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuadraticActionIn_class = nullptr;

static bool js_cocos2dx_EaseQuadraticActionIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuadraticActionIn_create : Error processing arguments");
        auto result = cocos2d::EaseQuadraticActionIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuadraticActionIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuadraticActionIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionIn_finalize)

static bool js_cocos2dx_EaseQuadraticActionIn_constructor(se::State& s)
{
    cocos2d::EaseQuadraticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuadraticActionIn_constructor, __jsb_cocos2d_EaseQuadraticActionIn_class, js_cocos2d_EaseQuadraticActionIn_finalize)

static bool js_cocos2dx_EaseQuadraticActionIn_ctor(se::State& s)
{
    cocos2d::EaseQuadraticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuadraticActionIn_ctor, __jsb_cocos2d_EaseQuadraticActionIn_class, js_cocos2d_EaseQuadraticActionIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseQuadraticActionIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseQuadraticActionIn)", s.nativeThisObject());
        cocos2d::EaseQuadraticActionIn* cobj = (cocos2d::EaseQuadraticActionIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionIn_finalize)

bool js_register_cocos2dx_EaseQuadraticActionIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuadraticActionIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuadraticActionIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuadraticActionIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuadraticActionIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseQuadraticActionIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuadraticActionIn>(cls);

    __jsb_cocos2d_EaseQuadraticActionIn_proto = cls->getProto();
    __jsb_cocos2d_EaseQuadraticActionIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseQuadraticActionIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseQuadraticActionOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuadraticActionOut_class = nullptr;

static bool js_cocos2dx_EaseQuadraticActionOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuadraticActionOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuadraticActionOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuadraticActionOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuadraticActionOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionOut_finalize)

static bool js_cocos2dx_EaseQuadraticActionOut_constructor(se::State& s)
{
    cocos2d::EaseQuadraticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuadraticActionOut_constructor, __jsb_cocos2d_EaseQuadraticActionOut_class, js_cocos2d_EaseQuadraticActionOut_finalize)

static bool js_cocos2dx_EaseQuadraticActionOut_ctor(se::State& s)
{
    cocos2d::EaseQuadraticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuadraticActionOut_ctor, __jsb_cocos2d_EaseQuadraticActionOut_class, js_cocos2d_EaseQuadraticActionOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseQuadraticActionOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseQuadraticActionOut)", s.nativeThisObject());
        cocos2d::EaseQuadraticActionOut* cobj = (cocos2d::EaseQuadraticActionOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionOut_finalize)

bool js_register_cocos2dx_EaseQuadraticActionOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuadraticActionOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuadraticActionOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuadraticActionOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuadraticActionOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseQuadraticActionOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuadraticActionOut>(cls);

    __jsb_cocos2d_EaseQuadraticActionOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuadraticActionOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseQuadraticActionOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseQuadraticActionInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuadraticActionInOut_class = nullptr;

static bool js_cocos2dx_EaseQuadraticActionInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuadraticActionInOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuadraticActionInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuadraticActionInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuadraticActionInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionInOut_finalize)

static bool js_cocos2dx_EaseQuadraticActionInOut_constructor(se::State& s)
{
    cocos2d::EaseQuadraticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuadraticActionInOut_constructor, __jsb_cocos2d_EaseQuadraticActionInOut_class, js_cocos2d_EaseQuadraticActionInOut_finalize)

static bool js_cocos2dx_EaseQuadraticActionInOut_ctor(se::State& s)
{
    cocos2d::EaseQuadraticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuadraticActionInOut_ctor, __jsb_cocos2d_EaseQuadraticActionInOut_class, js_cocos2d_EaseQuadraticActionInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseQuadraticActionInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseQuadraticActionInOut)", s.nativeThisObject());
        cocos2d::EaseQuadraticActionInOut* cobj = (cocos2d::EaseQuadraticActionInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionInOut_finalize)

bool js_register_cocos2dx_EaseQuadraticActionInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuadraticActionInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuadraticActionInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuadraticActionInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuadraticActionInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseQuadraticActionInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuadraticActionInOut>(cls);

    __jsb_cocos2d_EaseQuadraticActionInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuadraticActionInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseQuadraticActionInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseQuarticActionIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuarticActionIn_class = nullptr;

static bool js_cocos2dx_EaseQuarticActionIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuarticActionIn_create : Error processing arguments");
        auto result = cocos2d::EaseQuarticActionIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuarticActionIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuarticActionIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionIn_finalize)

static bool js_cocos2dx_EaseQuarticActionIn_constructor(se::State& s)
{
    cocos2d::EaseQuarticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuarticActionIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuarticActionIn_constructor, __jsb_cocos2d_EaseQuarticActionIn_class, js_cocos2d_EaseQuarticActionIn_finalize)

static bool js_cocos2dx_EaseQuarticActionIn_ctor(se::State& s)
{
    cocos2d::EaseQuarticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuarticActionIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuarticActionIn_ctor, __jsb_cocos2d_EaseQuarticActionIn_class, js_cocos2d_EaseQuarticActionIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseQuarticActionIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseQuarticActionIn)", s.nativeThisObject());
        cocos2d::EaseQuarticActionIn* cobj = (cocos2d::EaseQuarticActionIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionIn_finalize)

bool js_register_cocos2dx_EaseQuarticActionIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuarticActionIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuarticActionIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuarticActionIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuarticActionIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseQuarticActionIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuarticActionIn>(cls);

    __jsb_cocos2d_EaseQuarticActionIn_proto = cls->getProto();
    __jsb_cocos2d_EaseQuarticActionIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseQuarticActionIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseQuarticActionOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuarticActionOut_class = nullptr;

static bool js_cocos2dx_EaseQuarticActionOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuarticActionOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuarticActionOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuarticActionOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuarticActionOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionOut_finalize)

static bool js_cocos2dx_EaseQuarticActionOut_constructor(se::State& s)
{
    cocos2d::EaseQuarticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuarticActionOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuarticActionOut_constructor, __jsb_cocos2d_EaseQuarticActionOut_class, js_cocos2d_EaseQuarticActionOut_finalize)

static bool js_cocos2dx_EaseQuarticActionOut_ctor(se::State& s)
{
    cocos2d::EaseQuarticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuarticActionOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuarticActionOut_ctor, __jsb_cocos2d_EaseQuarticActionOut_class, js_cocos2d_EaseQuarticActionOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseQuarticActionOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseQuarticActionOut)", s.nativeThisObject());
        cocos2d::EaseQuarticActionOut* cobj = (cocos2d::EaseQuarticActionOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionOut_finalize)

bool js_register_cocos2dx_EaseQuarticActionOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuarticActionOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuarticActionOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuarticActionOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuarticActionOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseQuarticActionOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuarticActionOut>(cls);

    __jsb_cocos2d_EaseQuarticActionOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuarticActionOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseQuarticActionOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseQuarticActionInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuarticActionInOut_class = nullptr;

static bool js_cocos2dx_EaseQuarticActionInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuarticActionInOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuarticActionInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuarticActionInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuarticActionInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionInOut_finalize)

static bool js_cocos2dx_EaseQuarticActionInOut_constructor(se::State& s)
{
    cocos2d::EaseQuarticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuarticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuarticActionInOut_constructor, __jsb_cocos2d_EaseQuarticActionInOut_class, js_cocos2d_EaseQuarticActionInOut_finalize)

static bool js_cocos2dx_EaseQuarticActionInOut_ctor(se::State& s)
{
    cocos2d::EaseQuarticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuarticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuarticActionInOut_ctor, __jsb_cocos2d_EaseQuarticActionInOut_class, js_cocos2d_EaseQuarticActionInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseQuarticActionInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseQuarticActionInOut)", s.nativeThisObject());
        cocos2d::EaseQuarticActionInOut* cobj = (cocos2d::EaseQuarticActionInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionInOut_finalize)

bool js_register_cocos2dx_EaseQuarticActionInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuarticActionInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuarticActionInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuarticActionInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuarticActionInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseQuarticActionInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuarticActionInOut>(cls);

    __jsb_cocos2d_EaseQuarticActionInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuarticActionInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseQuarticActionInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseQuinticActionIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuinticActionIn_class = nullptr;

static bool js_cocos2dx_EaseQuinticActionIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuinticActionIn_create : Error processing arguments");
        auto result = cocos2d::EaseQuinticActionIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuinticActionIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuinticActionIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionIn_finalize)

static bool js_cocos2dx_EaseQuinticActionIn_constructor(se::State& s)
{
    cocos2d::EaseQuinticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuinticActionIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuinticActionIn_constructor, __jsb_cocos2d_EaseQuinticActionIn_class, js_cocos2d_EaseQuinticActionIn_finalize)

static bool js_cocos2dx_EaseQuinticActionIn_ctor(se::State& s)
{
    cocos2d::EaseQuinticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuinticActionIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuinticActionIn_ctor, __jsb_cocos2d_EaseQuinticActionIn_class, js_cocos2d_EaseQuinticActionIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseQuinticActionIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseQuinticActionIn)", s.nativeThisObject());
        cocos2d::EaseQuinticActionIn* cobj = (cocos2d::EaseQuinticActionIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionIn_finalize)

bool js_register_cocos2dx_EaseQuinticActionIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuinticActionIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuinticActionIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuinticActionIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuinticActionIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseQuinticActionIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuinticActionIn>(cls);

    __jsb_cocos2d_EaseQuinticActionIn_proto = cls->getProto();
    __jsb_cocos2d_EaseQuinticActionIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseQuinticActionIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseQuinticActionOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuinticActionOut_class = nullptr;

static bool js_cocos2dx_EaseQuinticActionOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuinticActionOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuinticActionOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuinticActionOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuinticActionOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionOut_finalize)

static bool js_cocos2dx_EaseQuinticActionOut_constructor(se::State& s)
{
    cocos2d::EaseQuinticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuinticActionOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuinticActionOut_constructor, __jsb_cocos2d_EaseQuinticActionOut_class, js_cocos2d_EaseQuinticActionOut_finalize)

static bool js_cocos2dx_EaseQuinticActionOut_ctor(se::State& s)
{
    cocos2d::EaseQuinticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuinticActionOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuinticActionOut_ctor, __jsb_cocos2d_EaseQuinticActionOut_class, js_cocos2d_EaseQuinticActionOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseQuinticActionOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseQuinticActionOut)", s.nativeThisObject());
        cocos2d::EaseQuinticActionOut* cobj = (cocos2d::EaseQuinticActionOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionOut_finalize)

bool js_register_cocos2dx_EaseQuinticActionOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuinticActionOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuinticActionOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuinticActionOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuinticActionOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseQuinticActionOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuinticActionOut>(cls);

    __jsb_cocos2d_EaseQuinticActionOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuinticActionOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseQuinticActionOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseQuinticActionInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuinticActionInOut_class = nullptr;

static bool js_cocos2dx_EaseQuinticActionInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuinticActionInOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuinticActionInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuinticActionInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuinticActionInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionInOut_finalize)

static bool js_cocos2dx_EaseQuinticActionInOut_constructor(se::State& s)
{
    cocos2d::EaseQuinticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuinticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuinticActionInOut_constructor, __jsb_cocos2d_EaseQuinticActionInOut_class, js_cocos2d_EaseQuinticActionInOut_finalize)

static bool js_cocos2dx_EaseQuinticActionInOut_ctor(se::State& s)
{
    cocos2d::EaseQuinticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuinticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuinticActionInOut_ctor, __jsb_cocos2d_EaseQuinticActionInOut_class, js_cocos2d_EaseQuinticActionInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseQuinticActionInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseQuinticActionInOut)", s.nativeThisObject());
        cocos2d::EaseQuinticActionInOut* cobj = (cocos2d::EaseQuinticActionInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionInOut_finalize)

bool js_register_cocos2dx_EaseQuinticActionInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuinticActionInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuinticActionInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuinticActionInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuinticActionInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseQuinticActionInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuinticActionInOut>(cls);

    __jsb_cocos2d_EaseQuinticActionInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuinticActionInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseQuinticActionInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseCircleActionIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCircleActionIn_class = nullptr;

static bool js_cocos2dx_EaseCircleActionIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseCircleActionIn_create : Error processing arguments");
        auto result = cocos2d::EaseCircleActionIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCircleActionIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCircleActionIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCircleActionIn_finalize)

static bool js_cocos2dx_EaseCircleActionIn_constructor(se::State& s)
{
    cocos2d::EaseCircleActionIn* cobj = new (std::nothrow) cocos2d::EaseCircleActionIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCircleActionIn_constructor, __jsb_cocos2d_EaseCircleActionIn_class, js_cocos2d_EaseCircleActionIn_finalize)

static bool js_cocos2dx_EaseCircleActionIn_ctor(se::State& s)
{
    cocos2d::EaseCircleActionIn* cobj = new (std::nothrow) cocos2d::EaseCircleActionIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCircleActionIn_ctor, __jsb_cocos2d_EaseCircleActionIn_class, js_cocos2d_EaseCircleActionIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseCircleActionIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseCircleActionIn)", s.nativeThisObject());
        cocos2d::EaseCircleActionIn* cobj = (cocos2d::EaseCircleActionIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCircleActionIn_finalize)

bool js_register_cocos2dx_EaseCircleActionIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseCircleActionIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCircleActionIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCircleActionIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCircleActionIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseCircleActionIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCircleActionIn>(cls);

    __jsb_cocos2d_EaseCircleActionIn_proto = cls->getProto();
    __jsb_cocos2d_EaseCircleActionIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseCircleActionIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseCircleActionOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCircleActionOut_class = nullptr;

static bool js_cocos2dx_EaseCircleActionOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseCircleActionOut_create : Error processing arguments");
        auto result = cocos2d::EaseCircleActionOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCircleActionOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCircleActionOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCircleActionOut_finalize)

static bool js_cocos2dx_EaseCircleActionOut_constructor(se::State& s)
{
    cocos2d::EaseCircleActionOut* cobj = new (std::nothrow) cocos2d::EaseCircleActionOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCircleActionOut_constructor, __jsb_cocos2d_EaseCircleActionOut_class, js_cocos2d_EaseCircleActionOut_finalize)

static bool js_cocos2dx_EaseCircleActionOut_ctor(se::State& s)
{
    cocos2d::EaseCircleActionOut* cobj = new (std::nothrow) cocos2d::EaseCircleActionOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCircleActionOut_ctor, __jsb_cocos2d_EaseCircleActionOut_class, js_cocos2d_EaseCircleActionOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseCircleActionOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseCircleActionOut)", s.nativeThisObject());
        cocos2d::EaseCircleActionOut* cobj = (cocos2d::EaseCircleActionOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCircleActionOut_finalize)

bool js_register_cocos2dx_EaseCircleActionOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseCircleActionOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCircleActionOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCircleActionOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCircleActionOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseCircleActionOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCircleActionOut>(cls);

    __jsb_cocos2d_EaseCircleActionOut_proto = cls->getProto();
    __jsb_cocos2d_EaseCircleActionOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseCircleActionOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseCircleActionInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCircleActionInOut_class = nullptr;

static bool js_cocos2dx_EaseCircleActionInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseCircleActionInOut_create : Error processing arguments");
        auto result = cocos2d::EaseCircleActionInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCircleActionInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCircleActionInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCircleActionInOut_finalize)

static bool js_cocos2dx_EaseCircleActionInOut_constructor(se::State& s)
{
    cocos2d::EaseCircleActionInOut* cobj = new (std::nothrow) cocos2d::EaseCircleActionInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCircleActionInOut_constructor, __jsb_cocos2d_EaseCircleActionInOut_class, js_cocos2d_EaseCircleActionInOut_finalize)

static bool js_cocos2dx_EaseCircleActionInOut_ctor(se::State& s)
{
    cocos2d::EaseCircleActionInOut* cobj = new (std::nothrow) cocos2d::EaseCircleActionInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCircleActionInOut_ctor, __jsb_cocos2d_EaseCircleActionInOut_class, js_cocos2d_EaseCircleActionInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseCircleActionInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseCircleActionInOut)", s.nativeThisObject());
        cocos2d::EaseCircleActionInOut* cobj = (cocos2d::EaseCircleActionInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCircleActionInOut_finalize)

bool js_register_cocos2dx_EaseCircleActionInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseCircleActionInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCircleActionInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCircleActionInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCircleActionInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseCircleActionInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCircleActionInOut>(cls);

    __jsb_cocos2d_EaseCircleActionInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseCircleActionInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseCircleActionInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseCubicActionIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCubicActionIn_class = nullptr;

static bool js_cocos2dx_EaseCubicActionIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseCubicActionIn_create : Error processing arguments");
        auto result = cocos2d::EaseCubicActionIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCubicActionIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCubicActionIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCubicActionIn_finalize)

static bool js_cocos2dx_EaseCubicActionIn_constructor(se::State& s)
{
    cocos2d::EaseCubicActionIn* cobj = new (std::nothrow) cocos2d::EaseCubicActionIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCubicActionIn_constructor, __jsb_cocos2d_EaseCubicActionIn_class, js_cocos2d_EaseCubicActionIn_finalize)

static bool js_cocos2dx_EaseCubicActionIn_ctor(se::State& s)
{
    cocos2d::EaseCubicActionIn* cobj = new (std::nothrow) cocos2d::EaseCubicActionIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCubicActionIn_ctor, __jsb_cocos2d_EaseCubicActionIn_class, js_cocos2d_EaseCubicActionIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseCubicActionIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseCubicActionIn)", s.nativeThisObject());
        cocos2d::EaseCubicActionIn* cobj = (cocos2d::EaseCubicActionIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCubicActionIn_finalize)

bool js_register_cocos2dx_EaseCubicActionIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseCubicActionIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCubicActionIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCubicActionIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCubicActionIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseCubicActionIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCubicActionIn>(cls);

    __jsb_cocos2d_EaseCubicActionIn_proto = cls->getProto();
    __jsb_cocos2d_EaseCubicActionIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseCubicActionIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseCubicActionOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCubicActionOut_class = nullptr;

static bool js_cocos2dx_EaseCubicActionOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseCubicActionOut_create : Error processing arguments");
        auto result = cocos2d::EaseCubicActionOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCubicActionOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCubicActionOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCubicActionOut_finalize)

static bool js_cocos2dx_EaseCubicActionOut_constructor(se::State& s)
{
    cocos2d::EaseCubicActionOut* cobj = new (std::nothrow) cocos2d::EaseCubicActionOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCubicActionOut_constructor, __jsb_cocos2d_EaseCubicActionOut_class, js_cocos2d_EaseCubicActionOut_finalize)

static bool js_cocos2dx_EaseCubicActionOut_ctor(se::State& s)
{
    cocos2d::EaseCubicActionOut* cobj = new (std::nothrow) cocos2d::EaseCubicActionOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCubicActionOut_ctor, __jsb_cocos2d_EaseCubicActionOut_class, js_cocos2d_EaseCubicActionOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseCubicActionOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseCubicActionOut)", s.nativeThisObject());
        cocos2d::EaseCubicActionOut* cobj = (cocos2d::EaseCubicActionOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCubicActionOut_finalize)

bool js_register_cocos2dx_EaseCubicActionOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseCubicActionOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCubicActionOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCubicActionOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCubicActionOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseCubicActionOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCubicActionOut>(cls);

    __jsb_cocos2d_EaseCubicActionOut_proto = cls->getProto();
    __jsb_cocos2d_EaseCubicActionOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseCubicActionOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseCubicActionInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCubicActionInOut_class = nullptr;

static bool js_cocos2dx_EaseCubicActionInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseCubicActionInOut_create : Error processing arguments");
        auto result = cocos2d::EaseCubicActionInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCubicActionInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCubicActionInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCubicActionInOut_finalize)

static bool js_cocos2dx_EaseCubicActionInOut_constructor(se::State& s)
{
    cocos2d::EaseCubicActionInOut* cobj = new (std::nothrow) cocos2d::EaseCubicActionInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCubicActionInOut_constructor, __jsb_cocos2d_EaseCubicActionInOut_class, js_cocos2d_EaseCubicActionInOut_finalize)

static bool js_cocos2dx_EaseCubicActionInOut_ctor(se::State& s)
{
    cocos2d::EaseCubicActionInOut* cobj = new (std::nothrow) cocos2d::EaseCubicActionInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCubicActionInOut_ctor, __jsb_cocos2d_EaseCubicActionInOut_class, js_cocos2d_EaseCubicActionInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseCubicActionInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseCubicActionInOut)", s.nativeThisObject());
        cocos2d::EaseCubicActionInOut* cobj = (cocos2d::EaseCubicActionInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCubicActionInOut_finalize)

bool js_register_cocos2dx_EaseCubicActionInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseCubicActionInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCubicActionInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCubicActionInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCubicActionInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseCubicActionInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCubicActionInOut>(cls);

    __jsb_cocos2d_EaseCubicActionInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseCubicActionInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseCubicActionInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseIn_class = nullptr;

static bool js_cocos2dx_EaseIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseIn_create : Error processing arguments");
        auto result = cocos2d::EaseIn::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseIn_finalize)

static bool js_cocos2dx_EaseIn_constructor(se::State& s)
{
    cocos2d::EaseIn* cobj = new (std::nothrow) cocos2d::EaseIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseIn_constructor, __jsb_cocos2d_EaseIn_class, js_cocos2d_EaseIn_finalize)

static bool js_cocos2dx_EaseIn_ctor(se::State& s)
{
    cocos2d::EaseIn* cobj = new (std::nothrow) cocos2d::EaseIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseIn_ctor, __jsb_cocos2d_EaseIn_class, js_cocos2d_EaseIn_finalize)


    

extern se::Object* __jsb_cocos2d_EaseRateAction_proto;

bool js_cocos2d_EaseIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseIn)", s.nativeThisObject());
        cocos2d::EaseIn* cobj = (cocos2d::EaseIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseIn_finalize)

bool js_register_cocos2dx_EaseIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseIn", obj, __jsb_cocos2d_EaseRateAction_proto, _SE(js_cocos2dx_EaseIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseIn>(cls);

    __jsb_cocos2d_EaseIn_proto = cls->getProto();
    __jsb_cocos2d_EaseIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseOut_class = nullptr;

static bool js_cocos2dx_EaseOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseOut_create : Error processing arguments");
        auto result = cocos2d::EaseOut::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseOut_finalize)

static bool js_cocos2dx_EaseOut_constructor(se::State& s)
{
    cocos2d::EaseOut* cobj = new (std::nothrow) cocos2d::EaseOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseOut_constructor, __jsb_cocos2d_EaseOut_class, js_cocos2d_EaseOut_finalize)

static bool js_cocos2dx_EaseOut_ctor(se::State& s)
{
    cocos2d::EaseOut* cobj = new (std::nothrow) cocos2d::EaseOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseOut_ctor, __jsb_cocos2d_EaseOut_class, js_cocos2d_EaseOut_finalize)


    

extern se::Object* __jsb_cocos2d_EaseRateAction_proto;

bool js_cocos2d_EaseOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseOut)", s.nativeThisObject());
        cocos2d::EaseOut* cobj = (cocos2d::EaseOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseOut_finalize)

bool js_register_cocos2dx_EaseOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseOut", obj, __jsb_cocos2d_EaseRateAction_proto, _SE(js_cocos2dx_EaseOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseOut>(cls);

    __jsb_cocos2d_EaseOut_proto = cls->getProto();
    __jsb_cocos2d_EaseOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseInOut_class = nullptr;

static bool js_cocos2dx_EaseInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseInOut_create : Error processing arguments");
        auto result = cocos2d::EaseInOut::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseInOut_finalize)

static bool js_cocos2dx_EaseInOut_constructor(se::State& s)
{
    cocos2d::EaseInOut* cobj = new (std::nothrow) cocos2d::EaseInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseInOut_constructor, __jsb_cocos2d_EaseInOut_class, js_cocos2d_EaseInOut_finalize)

static bool js_cocos2dx_EaseInOut_ctor(se::State& s)
{
    cocos2d::EaseInOut* cobj = new (std::nothrow) cocos2d::EaseInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseInOut_ctor, __jsb_cocos2d_EaseInOut_class, js_cocos2d_EaseInOut_finalize)


    

extern se::Object* __jsb_cocos2d_EaseRateAction_proto;

bool js_cocos2d_EaseInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseInOut)", s.nativeThisObject());
        cocos2d::EaseInOut* cobj = (cocos2d::EaseInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseInOut_finalize)

bool js_register_cocos2dx_EaseInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseInOut", obj, __jsb_cocos2d_EaseRateAction_proto, _SE(js_cocos2dx_EaseInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseInOut>(cls);

    __jsb_cocos2d_EaseInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseElastic_proto = nullptr;
se::Class* __jsb_cocos2d_EaseElastic_class = nullptr;

static bool js_cocos2dx_EaseElastic_setPeriod(se::State& s)
{
    cocos2d::EaseElastic* cobj = (cocos2d::EaseElastic*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EaseElastic_setPeriod : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_setPeriod : Error processing arguments");
        cobj->setPeriod(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElastic_setPeriod)

static bool js_cocos2dx_EaseElastic_initWithAction(se::State& s)
{
    cocos2d::EaseElastic* cobj = (cocos2d::EaseElastic*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EaseElastic_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_initWithAction : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElastic_initWithAction)

static bool js_cocos2dx_EaseElastic_getPeriod(se::State& s)
{
    cocos2d::EaseElastic* cobj = (cocos2d::EaseElastic*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EaseElastic_getPeriod : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getPeriod();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_getPeriod : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElastic_getPeriod)


extern se::Object* __jsb_cocos2d_ActionEase_proto;


bool js_register_cocos2dx_EaseElastic(se::Object* obj)
{
    auto cls = se::Class::create("EaseElastic", obj, __jsb_cocos2d_ActionEase_proto, nullptr);

    cls->defineFunction("setPeriod", _SE(js_cocos2dx_EaseElastic_setPeriod));
    cls->defineFunction("initWithAction", _SE(js_cocos2dx_EaseElastic_initWithAction));
    cls->defineFunction("getPeriod", _SE(js_cocos2dx_EaseElastic_getPeriod));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseElastic>(cls);

    __jsb_cocos2d_EaseElastic_proto = cls->getProto();
    __jsb_cocos2d_EaseElastic_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_EaseElasticIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseElasticIn_class = nullptr;

static bool js_cocos2dx_EaseElasticIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticIn_create : Error processing arguments");
        auto result = cocos2d::EaseElasticIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseElasticIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticIn_create : Error processing arguments");
        auto result = cocos2d::EaseElasticIn::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseElasticIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElasticIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseElasticIn_finalize)

static bool js_cocos2dx_EaseElasticIn_constructor(se::State& s)
{
    cocos2d::EaseElasticIn* cobj = new (std::nothrow) cocos2d::EaseElasticIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseElasticIn_constructor, __jsb_cocos2d_EaseElasticIn_class, js_cocos2d_EaseElasticIn_finalize)

static bool js_cocos2dx_EaseElasticIn_ctor(se::State& s)
{
    cocos2d::EaseElasticIn* cobj = new (std::nothrow) cocos2d::EaseElasticIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseElasticIn_ctor, __jsb_cocos2d_EaseElasticIn_class, js_cocos2d_EaseElasticIn_finalize)


    

extern se::Object* __jsb_cocos2d_EaseElastic_proto;

bool js_cocos2d_EaseElasticIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseElasticIn)", s.nativeThisObject());
        cocos2d::EaseElasticIn* cobj = (cocos2d::EaseElasticIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseElasticIn_finalize)

bool js_register_cocos2dx_EaseElasticIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseElasticIn", obj, __jsb_cocos2d_EaseElastic_proto, _SE(js_cocos2dx_EaseElasticIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseElasticIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseElasticIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseElasticIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseElasticIn>(cls);

    __jsb_cocos2d_EaseElasticIn_proto = cls->getProto();
    __jsb_cocos2d_EaseElasticIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseElasticIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseElasticOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseElasticOut_class = nullptr;

static bool js_cocos2dx_EaseElasticOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticOut_create : Error processing arguments");
        auto result = cocos2d::EaseElasticOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseElasticOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticOut_create : Error processing arguments");
        auto result = cocos2d::EaseElasticOut::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseElasticOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElasticOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseElasticOut_finalize)

static bool js_cocos2dx_EaseElasticOut_constructor(se::State& s)
{
    cocos2d::EaseElasticOut* cobj = new (std::nothrow) cocos2d::EaseElasticOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseElasticOut_constructor, __jsb_cocos2d_EaseElasticOut_class, js_cocos2d_EaseElasticOut_finalize)

static bool js_cocos2dx_EaseElasticOut_ctor(se::State& s)
{
    cocos2d::EaseElasticOut* cobj = new (std::nothrow) cocos2d::EaseElasticOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseElasticOut_ctor, __jsb_cocos2d_EaseElasticOut_class, js_cocos2d_EaseElasticOut_finalize)


    

extern se::Object* __jsb_cocos2d_EaseElastic_proto;

bool js_cocos2d_EaseElasticOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseElasticOut)", s.nativeThisObject());
        cocos2d::EaseElasticOut* cobj = (cocos2d::EaseElasticOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseElasticOut_finalize)

bool js_register_cocos2dx_EaseElasticOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseElasticOut", obj, __jsb_cocos2d_EaseElastic_proto, _SE(js_cocos2dx_EaseElasticOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseElasticOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseElasticOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseElasticOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseElasticOut>(cls);

    __jsb_cocos2d_EaseElasticOut_proto = cls->getProto();
    __jsb_cocos2d_EaseElasticOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseElasticOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseElasticInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseElasticInOut_class = nullptr;

static bool js_cocos2dx_EaseElasticInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticInOut_create : Error processing arguments");
        auto result = cocos2d::EaseElasticInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseElasticInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticInOut_create : Error processing arguments");
        auto result = cocos2d::EaseElasticInOut::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseElasticInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElasticInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseElasticInOut_finalize)

static bool js_cocos2dx_EaseElasticInOut_constructor(se::State& s)
{
    cocos2d::EaseElasticInOut* cobj = new (std::nothrow) cocos2d::EaseElasticInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseElasticInOut_constructor, __jsb_cocos2d_EaseElasticInOut_class, js_cocos2d_EaseElasticInOut_finalize)

static bool js_cocos2dx_EaseElasticInOut_ctor(se::State& s)
{
    cocos2d::EaseElasticInOut* cobj = new (std::nothrow) cocos2d::EaseElasticInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseElasticInOut_ctor, __jsb_cocos2d_EaseElasticInOut_class, js_cocos2d_EaseElasticInOut_finalize)


    

extern se::Object* __jsb_cocos2d_EaseElastic_proto;

bool js_cocos2d_EaseElasticInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseElasticInOut)", s.nativeThisObject());
        cocos2d::EaseElasticInOut* cobj = (cocos2d::EaseElasticInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseElasticInOut_finalize)

bool js_register_cocos2dx_EaseElasticInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseElasticInOut", obj, __jsb_cocos2d_EaseElastic_proto, _SE(js_cocos2dx_EaseElasticInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseElasticInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseElasticInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseElasticInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseElasticInOut>(cls);

    __jsb_cocos2d_EaseElasticInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseElasticInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseElasticInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_EaseBezierAction_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBezierAction_class = nullptr;

static bool js_cocos2dx_EaseBezierAction_setBezierParamer(se::State& s)
{
    cocos2d::EaseBezierAction* cobj = (cocos2d::EaseBezierAction*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_EaseBezierAction_setBezierParamer : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseBezierAction_setBezierParamer : Error processing arguments");
        cobj->setBezierParamer(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBezierAction_setBezierParamer)

static bool js_cocos2dx_EaseBezierAction_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_EaseBezierAction_create : Error processing arguments");
        auto result = cocos2d::EaseBezierAction::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBezierAction_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBezierAction_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBezierAction_finalize)

static bool js_cocos2dx_EaseBezierAction_constructor(se::State& s)
{
    cocos2d::EaseBezierAction* cobj = new (std::nothrow) cocos2d::EaseBezierAction();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBezierAction_constructor, __jsb_cocos2d_EaseBezierAction_class, js_cocos2d_EaseBezierAction_finalize)

static bool js_cocos2dx_EaseBezierAction_ctor(se::State& s)
{
    cocos2d::EaseBezierAction* cobj = new (std::nothrow) cocos2d::EaseBezierAction();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBezierAction_ctor, __jsb_cocos2d_EaseBezierAction_class, js_cocos2d_EaseBezierAction_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

bool js_cocos2d_EaseBezierAction_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::EaseBezierAction)", s.nativeThisObject());
        cocos2d::EaseBezierAction* cobj = (cocos2d::EaseBezierAction*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBezierAction_finalize)

bool js_register_cocos2dx_EaseBezierAction(se::Object* obj)
{
    auto cls = se::Class::create("EaseBezierAction", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseBezierAction_constructor));

    cls->defineFunction("setBezierParamer", _SE(js_cocos2dx_EaseBezierAction_setBezierParamer));
    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBezierAction_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBezierAction_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_EaseBezierAction_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBezierAction>(cls);

    __jsb_cocos2d_EaseBezierAction_proto = cls->getProto();
    __jsb_cocos2d_EaseBezierAction_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.EaseBezierAction.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ActionInstant_proto = nullptr;
se::Class* __jsb_cocos2d_ActionInstant_class = nullptr;


extern se::Object* __jsb_cocos2d_FiniteTimeAction_proto;


bool js_register_cocos2dx_ActionInstant(se::Object* obj)
{
    auto cls = se::Class::create("ActionInstant", obj, __jsb_cocos2d_FiniteTimeAction_proto, nullptr);

    cls->install();
    JSBClassType::registerClass<cocos2d::ActionInstant>(cls);

    __jsb_cocos2d_ActionInstant_proto = cls->getProto();
    __jsb_cocos2d_ActionInstant_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Show_proto = nullptr;
se::Class* __jsb_cocos2d_Show_class = nullptr;

static bool js_cocos2dx_Show_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Show::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Show_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Show_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Show_finalize)

static bool js_cocos2dx_Show_constructor(se::State& s)
{
    cocos2d::Show* cobj = new (std::nothrow) cocos2d::Show();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Show_constructor, __jsb_cocos2d_Show_class, js_cocos2d_Show_finalize)

static bool js_cocos2dx_Show_ctor(se::State& s)
{
    cocos2d::Show* cobj = new (std::nothrow) cocos2d::Show();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Show_ctor, __jsb_cocos2d_Show_class, js_cocos2d_Show_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

bool js_cocos2d_Show_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Show)", s.nativeThisObject());
        cocos2d::Show* cobj = (cocos2d::Show*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Show_finalize)

bool js_register_cocos2dx_Show(se::Object* obj)
{
    auto cls = se::Class::create("Show", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_Show_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_Show_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Show_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Show_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Show>(cls);

    __jsb_cocos2d_Show_proto = cls->getProto();
    __jsb_cocos2d_Show_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Show.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Hide_proto = nullptr;
se::Class* __jsb_cocos2d_Hide_class = nullptr;

static bool js_cocos2dx_Hide_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Hide::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Hide_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Hide_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Hide_finalize)

static bool js_cocos2dx_Hide_constructor(se::State& s)
{
    cocos2d::Hide* cobj = new (std::nothrow) cocos2d::Hide();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Hide_constructor, __jsb_cocos2d_Hide_class, js_cocos2d_Hide_finalize)

static bool js_cocos2dx_Hide_ctor(se::State& s)
{
    cocos2d::Hide* cobj = new (std::nothrow) cocos2d::Hide();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Hide_ctor, __jsb_cocos2d_Hide_class, js_cocos2d_Hide_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

bool js_cocos2d_Hide_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Hide)", s.nativeThisObject());
        cocos2d::Hide* cobj = (cocos2d::Hide*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Hide_finalize)

bool js_register_cocos2dx_Hide(se::Object* obj)
{
    auto cls = se::Class::create("Hide", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_Hide_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_Hide_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Hide_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Hide_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Hide>(cls);

    __jsb_cocos2d_Hide_proto = cls->getProto();
    __jsb_cocos2d_Hide_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Hide.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ToggleVisibility_proto = nullptr;
se::Class* __jsb_cocos2d_ToggleVisibility_class = nullptr;

static bool js_cocos2dx_ToggleVisibility_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ToggleVisibility::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ToggleVisibility_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ToggleVisibility_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ToggleVisibility_finalize)

static bool js_cocos2dx_ToggleVisibility_constructor(se::State& s)
{
    cocos2d::ToggleVisibility* cobj = new (std::nothrow) cocos2d::ToggleVisibility();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ToggleVisibility_constructor, __jsb_cocos2d_ToggleVisibility_class, js_cocos2d_ToggleVisibility_finalize)



extern se::Object* __jsb_cocos2d_ActionInstant_proto;

bool js_cocos2d_ToggleVisibility_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ToggleVisibility)", s.nativeThisObject());
        cocos2d::ToggleVisibility* cobj = (cocos2d::ToggleVisibility*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ToggleVisibility_finalize)

bool js_register_cocos2dx_ToggleVisibility(se::Object* obj)
{
    auto cls = se::Class::create("ToggleVisibility", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_ToggleVisibility_constructor));

    cls->defineStaticFunction("create", _SE(js_cocos2dx_ToggleVisibility_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ToggleVisibility_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ToggleVisibility>(cls);

    __jsb_cocos2d_ToggleVisibility_proto = cls->getProto();
    __jsb_cocos2d_ToggleVisibility_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_RemoveSelf_proto = nullptr;
se::Class* __jsb_cocos2d_RemoveSelf_class = nullptr;

static bool js_cocos2dx_RemoveSelf_init(se::State& s)
{
    cocos2d::RemoveSelf* cobj = (cocos2d::RemoveSelf*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RemoveSelf_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RemoveSelf_init : Error processing arguments");
        bool result = cobj->init(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RemoveSelf_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RemoveSelf_init)

static bool js_cocos2dx_RemoveSelf_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::RemoveSelf::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_RemoveSelf_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RemoveSelf_create : Error processing arguments");
        auto result = cocos2d::RemoveSelf::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_RemoveSelf_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RemoveSelf_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_RemoveSelf_finalize)

static bool js_cocos2dx_RemoveSelf_constructor(se::State& s)
{
    cocos2d::RemoveSelf* cobj = new (std::nothrow) cocos2d::RemoveSelf();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_RemoveSelf_constructor, __jsb_cocos2d_RemoveSelf_class, js_cocos2d_RemoveSelf_finalize)



extern se::Object* __jsb_cocos2d_ActionInstant_proto;

bool js_cocos2d_RemoveSelf_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::RemoveSelf)", s.nativeThisObject());
        cocos2d::RemoveSelf* cobj = (cocos2d::RemoveSelf*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_RemoveSelf_finalize)

bool js_register_cocos2dx_RemoveSelf(se::Object* obj)
{
    auto cls = se::Class::create("RemoveSelf", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_RemoveSelf_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_RemoveSelf_init));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_RemoveSelf_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_RemoveSelf_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::RemoveSelf>(cls);

    __jsb_cocos2d_RemoveSelf_proto = cls->getProto();
    __jsb_cocos2d_RemoveSelf_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_FlipX_proto = nullptr;
se::Class* __jsb_cocos2d_FlipX_class = nullptr;

static bool js_cocos2dx_FlipX_initWithFlipX(se::State& s)
{
    cocos2d::FlipX* cobj = (cocos2d::FlipX*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FlipX_initWithFlipX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipX_initWithFlipX : Error processing arguments");
        bool result = cobj->initWithFlipX(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipX_initWithFlipX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipX_initWithFlipX)

static bool js_cocos2dx_FlipX_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipX_create : Error processing arguments");
        auto result = cocos2d::FlipX::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FlipX_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipX_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FlipX_finalize)

static bool js_cocos2dx_FlipX_constructor(se::State& s)
{
    cocos2d::FlipX* cobj = new (std::nothrow) cocos2d::FlipX();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FlipX_constructor, __jsb_cocos2d_FlipX_class, js_cocos2d_FlipX_finalize)

static bool js_cocos2dx_FlipX_ctor(se::State& s)
{
    cocos2d::FlipX* cobj = new (std::nothrow) cocos2d::FlipX();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FlipX_ctor, __jsb_cocos2d_FlipX_class, js_cocos2d_FlipX_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

bool js_cocos2d_FlipX_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::FlipX)", s.nativeThisObject());
        cocos2d::FlipX* cobj = (cocos2d::FlipX*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FlipX_finalize)

bool js_register_cocos2dx_FlipX(se::Object* obj)
{
    auto cls = se::Class::create("FlipX", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_FlipX_constructor));

    cls->defineFunction("initWithFlipX", _SE(js_cocos2dx_FlipX_initWithFlipX));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FlipX_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FlipX_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_FlipX_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FlipX>(cls);

    __jsb_cocos2d_FlipX_proto = cls->getProto();
    __jsb_cocos2d_FlipX_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.FlipX.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_FlipY_proto = nullptr;
se::Class* __jsb_cocos2d_FlipY_class = nullptr;

static bool js_cocos2dx_FlipY_initWithFlipY(se::State& s)
{
    cocos2d::FlipY* cobj = (cocos2d::FlipY*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FlipY_initWithFlipY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipY_initWithFlipY : Error processing arguments");
        bool result = cobj->initWithFlipY(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipY_initWithFlipY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipY_initWithFlipY)

static bool js_cocos2dx_FlipY_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipY_create : Error processing arguments");
        auto result = cocos2d::FlipY::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FlipY_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipY_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FlipY_finalize)

static bool js_cocos2dx_FlipY_constructor(se::State& s)
{
    cocos2d::FlipY* cobj = new (std::nothrow) cocos2d::FlipY();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FlipY_constructor, __jsb_cocos2d_FlipY_class, js_cocos2d_FlipY_finalize)

static bool js_cocos2dx_FlipY_ctor(se::State& s)
{
    cocos2d::FlipY* cobj = new (std::nothrow) cocos2d::FlipY();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FlipY_ctor, __jsb_cocos2d_FlipY_class, js_cocos2d_FlipY_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

bool js_cocos2d_FlipY_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::FlipY)", s.nativeThisObject());
        cocos2d::FlipY* cobj = (cocos2d::FlipY*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FlipY_finalize)

bool js_register_cocos2dx_FlipY(se::Object* obj)
{
    auto cls = se::Class::create("FlipY", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_FlipY_constructor));

    cls->defineFunction("initWithFlipY", _SE(js_cocos2dx_FlipY_initWithFlipY));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FlipY_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FlipY_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_FlipY_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FlipY>(cls);

    __jsb_cocos2d_FlipY_proto = cls->getProto();
    __jsb_cocos2d_FlipY_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.FlipY.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Place_proto = nullptr;
se::Class* __jsb_cocos2d_Place_class = nullptr;

static bool js_cocos2dx_Place_initWithPosition(se::State& s)
{
    cocos2d::Place* cobj = (cocos2d::Place*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Place_initWithPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Place_initWithPosition : Error processing arguments");
        bool result = cobj->initWithPosition(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Place_initWithPosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Place_initWithPosition)

static bool js_cocos2dx_Place_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Place_create : Error processing arguments");
        auto result = cocos2d::Place::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Place_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Place_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Place_finalize)

static bool js_cocos2dx_Place_constructor(se::State& s)
{
    cocos2d::Place* cobj = new (std::nothrow) cocos2d::Place();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Place_constructor, __jsb_cocos2d_Place_class, js_cocos2d_Place_finalize)

static bool js_cocos2dx_Place_ctor(se::State& s)
{
    cocos2d::Place* cobj = new (std::nothrow) cocos2d::Place();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Place_ctor, __jsb_cocos2d_Place_class, js_cocos2d_Place_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

bool js_cocos2d_Place_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Place)", s.nativeThisObject());
        cocos2d::Place* cobj = (cocos2d::Place*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Place_finalize)

bool js_register_cocos2dx_Place(se::Object* obj)
{
    auto cls = se::Class::create("Place", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_Place_constructor));

    cls->defineFunction("initWithPosition", _SE(js_cocos2dx_Place_initWithPosition));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Place_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Place_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Place_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Place>(cls);

    __jsb_cocos2d_Place_proto = cls->getProto();
    __jsb_cocos2d_Place_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Place.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_CallFunc_proto = nullptr;
se::Class* __jsb_cocos2d_CallFunc_class = nullptr;

static bool js_cocos2dx_CallFunc_execute(se::State& s)
{
    cocos2d::CallFunc* cobj = (cocos2d::CallFunc*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CallFunc_execute : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->execute();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CallFunc_execute)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CallFunc_finalize)

static bool js_cocos2dx_CallFunc_constructor(se::State& s)
{
    cocos2d::CallFunc* cobj = new (std::nothrow) cocos2d::CallFunc();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CallFunc_constructor, __jsb_cocos2d_CallFunc_class, js_cocos2d_CallFunc_finalize)

static bool js_cocos2dx_CallFunc_ctor(se::State& s)
{
    cocos2d::CallFunc* cobj = new (std::nothrow) cocos2d::CallFunc();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_CallFunc_ctor, __jsb_cocos2d_CallFunc_class, js_cocos2d_CallFunc_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

bool js_cocos2d_CallFunc_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::CallFunc)", s.nativeThisObject());
        cocos2d::CallFunc* cobj = (cocos2d::CallFunc*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CallFunc_finalize)

bool js_register_cocos2dx_CallFunc(se::Object* obj)
{
    auto cls = se::Class::create("_CallFunc", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_CallFunc_constructor));

    cls->defineFunction("execute", _SE(js_cocos2dx_CallFunc_execute));
    cls->defineFunction("ctor", _SE(js_cocos2dx_CallFunc_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_CallFunc_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CallFunc>(cls);

    __jsb_cocos2d_CallFunc_proto = cls->getProto();
    __jsb_cocos2d_CallFunc_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc._CallFunc.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_CallFuncN_proto = nullptr;
se::Class* __jsb_cocos2d_CallFuncN_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CallFuncN_finalize)

static bool js_cocos2dx_CallFuncN_constructor(se::State& s)
{
    cocos2d::CallFuncN* cobj = new (std::nothrow) cocos2d::CallFuncN();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CallFuncN_constructor, __jsb_cocos2d_CallFuncN_class, js_cocos2d_CallFuncN_finalize)

static bool js_cocos2dx_CallFuncN_ctor(se::State& s)
{
    cocos2d::CallFuncN* cobj = new (std::nothrow) cocos2d::CallFuncN();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_CallFuncN_ctor, __jsb_cocos2d_CallFuncN_class, js_cocos2d_CallFuncN_finalize)


    

extern se::Object* __jsb_cocos2d_CallFunc_proto;

bool js_cocos2d_CallFuncN_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::CallFuncN)", s.nativeThisObject());
        cocos2d::CallFuncN* cobj = (cocos2d::CallFuncN*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CallFuncN_finalize)

bool js_register_cocos2dx_CallFuncN(se::Object* obj)
{
    auto cls = se::Class::create("CallFunc", obj, __jsb_cocos2d_CallFunc_proto, _SE(js_cocos2dx_CallFuncN_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_CallFuncN_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_CallFuncN_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CallFuncN>(cls);

    __jsb_cocos2d_CallFuncN_proto = cls->getProto();
    __jsb_cocos2d_CallFuncN_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.CallFunc.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_GridAction_proto = nullptr;
se::Class* __jsb_cocos2d_GridAction_class = nullptr;

static bool js_cocos2dx_GridAction_getGrid(se::State& s)
{
    cocos2d::GridAction* cobj = (cocos2d::GridAction*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridAction_getGrid : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GridBase* result = cobj->getGrid();
        ok &= native_ptr_to_seval<cocos2d::GridBase>((cocos2d::GridBase*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridAction_getGrid : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridAction_getGrid)

static bool js_cocos2dx_GridAction_initWithDuration(se::State& s)
{
    cocos2d::GridAction* cobj = (cocos2d::GridAction*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridAction_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Size arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridAction_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridAction_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridAction_initWithDuration)


extern se::Object* __jsb_cocos2d_ActionInterval_proto;


bool js_register_cocos2dx_GridAction(se::Object* obj)
{
    auto cls = se::Class::create("GridAction", obj, __jsb_cocos2d_ActionInterval_proto, nullptr);

    cls->defineFunction("getGrid", _SE(js_cocos2dx_GridAction_getGrid));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_GridAction_initWithDuration));
    cls->install();
    JSBClassType::registerClass<cocos2d::GridAction>(cls);

    __jsb_cocos2d_GridAction_proto = cls->getProto();
    __jsb_cocos2d_GridAction_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Grid3DAction_proto = nullptr;
se::Class* __jsb_cocos2d_Grid3DAction_class = nullptr;

static bool js_cocos2dx_Grid3DAction_getGridRect(se::State& s)
{
    cocos2d::Grid3DAction* cobj = (cocos2d::Grid3DAction*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Grid3DAction_getGridRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->getGridRect();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Grid3DAction_getGridRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Grid3DAction_getGridRect)


extern se::Object* __jsb_cocos2d_GridAction_proto;


bool js_register_cocos2dx_Grid3DAction(se::Object* obj)
{
    auto cls = se::Class::create("Grid3DAction", obj, __jsb_cocos2d_GridAction_proto, nullptr);

    cls->defineFunction("getGridRect", _SE(js_cocos2dx_Grid3DAction_getGridRect));
    cls->install();
    JSBClassType::registerClass<cocos2d::Grid3DAction>(cls);

    __jsb_cocos2d_Grid3DAction_proto = cls->getProto();
    __jsb_cocos2d_Grid3DAction_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_TiledGrid3DAction_proto = nullptr;
se::Class* __jsb_cocos2d_TiledGrid3DAction_class = nullptr;


extern se::Object* __jsb_cocos2d_GridAction_proto;


bool js_register_cocos2dx_TiledGrid3DAction(se::Object* obj)
{
    auto cls = se::Class::create("TiledGrid3DAction", obj, __jsb_cocos2d_GridAction_proto, nullptr);

    cls->install();
    JSBClassType::registerClass<cocos2d::TiledGrid3DAction>(cls);

    __jsb_cocos2d_TiledGrid3DAction_proto = cls->getProto();
    __jsb_cocos2d_TiledGrid3DAction_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_StopGrid_proto = nullptr;
se::Class* __jsb_cocos2d_StopGrid_class = nullptr;

static bool js_cocos2dx_StopGrid_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::StopGrid::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_StopGrid_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_StopGrid_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_StopGrid_finalize)

static bool js_cocos2dx_StopGrid_constructor(se::State& s)
{
    cocos2d::StopGrid* cobj = new (std::nothrow) cocos2d::StopGrid();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_StopGrid_constructor, __jsb_cocos2d_StopGrid_class, js_cocos2d_StopGrid_finalize)



extern se::Object* __jsb_cocos2d_ActionInstant_proto;

bool js_cocos2d_StopGrid_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::StopGrid)", s.nativeThisObject());
        cocos2d::StopGrid* cobj = (cocos2d::StopGrid*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_StopGrid_finalize)

bool js_register_cocos2dx_StopGrid(se::Object* obj)
{
    auto cls = se::Class::create("StopGrid", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_StopGrid_constructor));

    cls->defineStaticFunction("create", _SE(js_cocos2dx_StopGrid_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_StopGrid_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::StopGrid>(cls);

    __jsb_cocos2d_StopGrid_proto = cls->getProto();
    __jsb_cocos2d_StopGrid_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ReuseGrid_proto = nullptr;
se::Class* __jsb_cocos2d_ReuseGrid_class = nullptr;

static bool js_cocos2dx_ReuseGrid_initWithTimes(se::State& s)
{
    cocos2d::ReuseGrid* cobj = (cocos2d::ReuseGrid*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ReuseGrid_initWithTimes : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ReuseGrid_initWithTimes : Error processing arguments");
        bool result = cobj->initWithTimes(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ReuseGrid_initWithTimes : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ReuseGrid_initWithTimes)

static bool js_cocos2dx_ReuseGrid_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ReuseGrid_create : Error processing arguments");
        auto result = cocos2d::ReuseGrid::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ReuseGrid_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ReuseGrid_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ReuseGrid_finalize)

static bool js_cocos2dx_ReuseGrid_constructor(se::State& s)
{
    cocos2d::ReuseGrid* cobj = new (std::nothrow) cocos2d::ReuseGrid();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ReuseGrid_constructor, __jsb_cocos2d_ReuseGrid_class, js_cocos2d_ReuseGrid_finalize)



extern se::Object* __jsb_cocos2d_ActionInstant_proto;

bool js_cocos2d_ReuseGrid_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ReuseGrid)", s.nativeThisObject());
        cocos2d::ReuseGrid* cobj = (cocos2d::ReuseGrid*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ReuseGrid_finalize)

bool js_register_cocos2dx_ReuseGrid(se::Object* obj)
{
    auto cls = se::Class::create("ReuseGrid", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_ReuseGrid_constructor));

    cls->defineFunction("initWithTimes", _SE(js_cocos2dx_ReuseGrid_initWithTimes));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ReuseGrid_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ReuseGrid_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ReuseGrid>(cls);

    __jsb_cocos2d_ReuseGrid_proto = cls->getProto();
    __jsb_cocos2d_ReuseGrid_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Waves3D_proto = nullptr;
se::Class* __jsb_cocos2d_Waves3D_class = nullptr;

static bool js_cocos2dx_Waves3D_setAmplitudeRate(se::State& s)
{
    cocos2d::Waves3D* cobj = (cocos2d::Waves3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Waves3D_setAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves3D_setAmplitudeRate : Error processing arguments");
        cobj->setAmplitudeRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves3D_setAmplitudeRate)

static bool js_cocos2dx_Waves3D_initWithDuration(se::State& s)
{
    cocos2d::Waves3D* cobj = (cocos2d::Waves3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Waves3D_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves3D_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves3D_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves3D_initWithDuration)

static bool js_cocos2dx_Waves3D_getAmplitude(se::State& s)
{
    cocos2d::Waves3D* cobj = (cocos2d::Waves3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Waves3D_getAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitude();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves3D_getAmplitude : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves3D_getAmplitude)

static bool js_cocos2dx_Waves3D_getAmplitudeRate(se::State& s)
{
    cocos2d::Waves3D* cobj = (cocos2d::Waves3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Waves3D_getAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitudeRate();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves3D_getAmplitudeRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves3D_getAmplitudeRate)

static bool js_cocos2dx_Waves3D_setAmplitude(se::State& s)
{
    cocos2d::Waves3D* cobj = (cocos2d::Waves3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Waves3D_setAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves3D_setAmplitude : Error processing arguments");
        cobj->setAmplitude(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves3D_setAmplitude)

static bool js_cocos2dx_Waves3D_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves3D_create : Error processing arguments");
        auto result = cocos2d::Waves3D::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Waves3D_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Waves3D_finalize)

static bool js_cocos2dx_Waves3D_constructor(se::State& s)
{
    cocos2d::Waves3D* cobj = new (std::nothrow) cocos2d::Waves3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Waves3D_constructor, __jsb_cocos2d_Waves3D_class, js_cocos2d_Waves3D_finalize)



extern se::Object* __jsb_cocos2d_Grid3DAction_proto;

bool js_cocos2d_Waves3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Waves3D)", s.nativeThisObject());
        cocos2d::Waves3D* cobj = (cocos2d::Waves3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Waves3D_finalize)

bool js_register_cocos2dx_Waves3D(se::Object* obj)
{
    auto cls = se::Class::create("Waves3D", obj, __jsb_cocos2d_Grid3DAction_proto, _SE(js_cocos2dx_Waves3D_constructor));

    cls->defineFunction("setAmplitudeRate", _SE(js_cocos2dx_Waves3D_setAmplitudeRate));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_Waves3D_initWithDuration));
    cls->defineFunction("getAmplitude", _SE(js_cocos2dx_Waves3D_getAmplitude));
    cls->defineFunction("getAmplitudeRate", _SE(js_cocos2dx_Waves3D_getAmplitudeRate));
    cls->defineFunction("setAmplitude", _SE(js_cocos2dx_Waves3D_setAmplitude));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Waves3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Waves3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Waves3D>(cls);

    __jsb_cocos2d_Waves3D_proto = cls->getProto();
    __jsb_cocos2d_Waves3D_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_FlipX3D_proto = nullptr;
se::Class* __jsb_cocos2d_FlipX3D_class = nullptr;

static bool js_cocos2dx_FlipX3D_initWithSize(se::State& s)
{
    cocos2d::FlipX3D* cobj = (cocos2d::FlipX3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FlipX3D_initWithSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Size arg0;
        float arg1 = 0;
        ok &= seval_to_Size(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipX3D_initWithSize : Error processing arguments");
        bool result = cobj->initWithSize(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipX3D_initWithSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipX3D_initWithSize)

static bool js_cocos2dx_FlipX3D_initWithDuration(se::State& s)
{
    cocos2d::FlipX3D* cobj = (cocos2d::FlipX3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FlipX3D_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipX3D_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipX3D_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipX3D_initWithDuration)

static bool js_cocos2dx_FlipX3D_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipX3D_create : Error processing arguments");
        auto result = cocos2d::FlipX3D::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FlipX3D_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipX3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FlipX3D_finalize)

static bool js_cocos2dx_FlipX3D_constructor(se::State& s)
{
    cocos2d::FlipX3D* cobj = new (std::nothrow) cocos2d::FlipX3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FlipX3D_constructor, __jsb_cocos2d_FlipX3D_class, js_cocos2d_FlipX3D_finalize)

static bool js_cocos2dx_FlipX3D_ctor(se::State& s)
{
    cocos2d::FlipX3D* cobj = new (std::nothrow) cocos2d::FlipX3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FlipX3D_ctor, __jsb_cocos2d_FlipX3D_class, js_cocos2d_FlipX3D_finalize)


    

extern se::Object* __jsb_cocos2d_Grid3DAction_proto;

bool js_cocos2d_FlipX3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::FlipX3D)", s.nativeThisObject());
        cocos2d::FlipX3D* cobj = (cocos2d::FlipX3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FlipX3D_finalize)

bool js_register_cocos2dx_FlipX3D(se::Object* obj)
{
    auto cls = se::Class::create("FlipX3D", obj, __jsb_cocos2d_Grid3DAction_proto, _SE(js_cocos2dx_FlipX3D_constructor));

    cls->defineFunction("initWithSize", _SE(js_cocos2dx_FlipX3D_initWithSize));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_FlipX3D_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FlipX3D_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FlipX3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_FlipX3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FlipX3D>(cls);

    __jsb_cocos2d_FlipX3D_proto = cls->getProto();
    __jsb_cocos2d_FlipX3D_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.FlipX3D.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_FlipY3D_proto = nullptr;
se::Class* __jsb_cocos2d_FlipY3D_class = nullptr;

static bool js_cocos2dx_FlipY3D_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FlipY3D_create : Error processing arguments");
        auto result = cocos2d::FlipY3D::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FlipY3D_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipY3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FlipY3D_finalize)

static bool js_cocos2dx_FlipY3D_constructor(se::State& s)
{
    cocos2d::FlipY3D* cobj = new (std::nothrow) cocos2d::FlipY3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FlipY3D_constructor, __jsb_cocos2d_FlipY3D_class, js_cocos2d_FlipY3D_finalize)

static bool js_cocos2dx_FlipY3D_ctor(se::State& s)
{
    cocos2d::FlipY3D* cobj = new (std::nothrow) cocos2d::FlipY3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FlipY3D_ctor, __jsb_cocos2d_FlipY3D_class, js_cocos2d_FlipY3D_finalize)


    

extern se::Object* __jsb_cocos2d_FlipX3D_proto;

bool js_cocos2d_FlipY3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::FlipY3D)", s.nativeThisObject());
        cocos2d::FlipY3D* cobj = (cocos2d::FlipY3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FlipY3D_finalize)

bool js_register_cocos2dx_FlipY3D(se::Object* obj)
{
    auto cls = se::Class::create("FlipY3D", obj, __jsb_cocos2d_FlipX3D_proto, _SE(js_cocos2dx_FlipY3D_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_FlipY3D_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FlipY3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_FlipY3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FlipY3D>(cls);

    __jsb_cocos2d_FlipY3D_proto = cls->getProto();
    __jsb_cocos2d_FlipY3D_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.FlipY3D.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Lens3D_proto = nullptr;
se::Class* __jsb_cocos2d_Lens3D_class = nullptr;

static bool js_cocos2dx_Lens3D_setConcave(se::State& s)
{
    cocos2d::Lens3D* cobj = (cocos2d::Lens3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Lens3D_setConcave : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Lens3D_setConcave : Error processing arguments");
        cobj->setConcave(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Lens3D_setConcave)

static bool js_cocos2dx_Lens3D_initWithDuration(se::State& s)
{
    cocos2d::Lens3D* cobj = (cocos2d::Lens3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Lens3D_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        cocos2d::Vec2 arg2;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Lens3D_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Lens3D_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Lens3D_initWithDuration)

static bool js_cocos2dx_Lens3D_setLensEffect(se::State& s)
{
    cocos2d::Lens3D* cobj = (cocos2d::Lens3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Lens3D_setLensEffect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Lens3D_setLensEffect : Error processing arguments");
        cobj->setLensEffect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Lens3D_setLensEffect)

static bool js_cocos2dx_Lens3D_getLensEffect(se::State& s)
{
    cocos2d::Lens3D* cobj = (cocos2d::Lens3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Lens3D_getLensEffect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getLensEffect();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Lens3D_getLensEffect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Lens3D_getLensEffect)

static bool js_cocos2dx_Lens3D_setPosition(se::State& s)
{
    cocos2d::Lens3D* cobj = (cocos2d::Lens3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Lens3D_setPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Lens3D_setPosition : Error processing arguments");
        cobj->setPosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Lens3D_setPosition)

static bool js_cocos2dx_Lens3D_getPosition(se::State& s)
{
    cocos2d::Lens3D* cobj = (cocos2d::Lens3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Lens3D_getPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getPosition();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Lens3D_getPosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Lens3D_getPosition)

static bool js_cocos2dx_Lens3D_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        cocos2d::Vec2 arg2;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Lens3D_create : Error processing arguments");
        auto result = cocos2d::Lens3D::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Lens3D_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Lens3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Lens3D_finalize)

static bool js_cocos2dx_Lens3D_constructor(se::State& s)
{
    cocos2d::Lens3D* cobj = new (std::nothrow) cocos2d::Lens3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Lens3D_constructor, __jsb_cocos2d_Lens3D_class, js_cocos2d_Lens3D_finalize)



extern se::Object* __jsb_cocos2d_Grid3DAction_proto;

bool js_cocos2d_Lens3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Lens3D)", s.nativeThisObject());
        cocos2d::Lens3D* cobj = (cocos2d::Lens3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Lens3D_finalize)

bool js_register_cocos2dx_Lens3D(se::Object* obj)
{
    auto cls = se::Class::create("Lens3D", obj, __jsb_cocos2d_Grid3DAction_proto, _SE(js_cocos2dx_Lens3D_constructor));

    cls->defineFunction("setConcave", _SE(js_cocos2dx_Lens3D_setConcave));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_Lens3D_initWithDuration));
    cls->defineFunction("setLensEffect", _SE(js_cocos2dx_Lens3D_setLensEffect));
    cls->defineFunction("getLensEffect", _SE(js_cocos2dx_Lens3D_getLensEffect));
    cls->defineFunction("setPosition", _SE(js_cocos2dx_Lens3D_setPosition));
    cls->defineFunction("getPosition", _SE(js_cocos2dx_Lens3D_getPosition));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Lens3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Lens3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Lens3D>(cls);

    __jsb_cocos2d_Lens3D_proto = cls->getProto();
    __jsb_cocos2d_Lens3D_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Ripple3D_proto = nullptr;
se::Class* __jsb_cocos2d_Ripple3D_class = nullptr;

static bool js_cocos2dx_Ripple3D_setAmplitudeRate(se::State& s)
{
    cocos2d::Ripple3D* cobj = (cocos2d::Ripple3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Ripple3D_setAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Ripple3D_setAmplitudeRate : Error processing arguments");
        cobj->setAmplitudeRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Ripple3D_setAmplitudeRate)

static bool js_cocos2dx_Ripple3D_initWithDuration(se::State& s)
{
    cocos2d::Ripple3D* cobj = (cocos2d::Ripple3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Ripple3D_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 6) {
        float arg0 = 0;
        cocos2d::Size arg1;
        cocos2d::Vec2 arg2;
        float arg3 = 0;
        unsigned int arg4 = 0;
        float arg5 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        ok &= seval_to_uint32(args[4], &arg4);
        ok &= seval_to_float(args[5], &arg5);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Ripple3D_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3, arg4, arg5);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Ripple3D_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Ripple3D_initWithDuration)

static bool js_cocos2dx_Ripple3D_getAmplitudeRate(se::State& s)
{
    cocos2d::Ripple3D* cobj = (cocos2d::Ripple3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Ripple3D_getAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitudeRate();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Ripple3D_getAmplitudeRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Ripple3D_getAmplitudeRate)

static bool js_cocos2dx_Ripple3D_setAmplitude(se::State& s)
{
    cocos2d::Ripple3D* cobj = (cocos2d::Ripple3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Ripple3D_setAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Ripple3D_setAmplitude : Error processing arguments");
        cobj->setAmplitude(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Ripple3D_setAmplitude)

static bool js_cocos2dx_Ripple3D_getAmplitude(se::State& s)
{
    cocos2d::Ripple3D* cobj = (cocos2d::Ripple3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Ripple3D_getAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitude();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Ripple3D_getAmplitude : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Ripple3D_getAmplitude)

static bool js_cocos2dx_Ripple3D_setPosition(se::State& s)
{
    cocos2d::Ripple3D* cobj = (cocos2d::Ripple3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Ripple3D_setPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Ripple3D_setPosition : Error processing arguments");
        cobj->setPosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Ripple3D_setPosition)

static bool js_cocos2dx_Ripple3D_getPosition(se::State& s)
{
    cocos2d::Ripple3D* cobj = (cocos2d::Ripple3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Ripple3D_getPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getPosition();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Ripple3D_getPosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Ripple3D_getPosition)

static bool js_cocos2dx_Ripple3D_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 6) {
        float arg0 = 0;
        cocos2d::Size arg1;
        cocos2d::Vec2 arg2;
        float arg3 = 0;
        unsigned int arg4 = 0;
        float arg5 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        ok &= seval_to_uint32(args[4], &arg4);
        ok &= seval_to_float(args[5], &arg5);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Ripple3D_create : Error processing arguments");
        auto result = cocos2d::Ripple3D::create(arg0, arg1, arg2, arg3, arg4, arg5);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Ripple3D_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Ripple3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Ripple3D_finalize)

static bool js_cocos2dx_Ripple3D_constructor(se::State& s)
{
    cocos2d::Ripple3D* cobj = new (std::nothrow) cocos2d::Ripple3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Ripple3D_constructor, __jsb_cocos2d_Ripple3D_class, js_cocos2d_Ripple3D_finalize)



extern se::Object* __jsb_cocos2d_Grid3DAction_proto;

bool js_cocos2d_Ripple3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Ripple3D)", s.nativeThisObject());
        cocos2d::Ripple3D* cobj = (cocos2d::Ripple3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Ripple3D_finalize)

bool js_register_cocos2dx_Ripple3D(se::Object* obj)
{
    auto cls = se::Class::create("Ripple3D", obj, __jsb_cocos2d_Grid3DAction_proto, _SE(js_cocos2dx_Ripple3D_constructor));

    cls->defineFunction("setAmplitudeRate", _SE(js_cocos2dx_Ripple3D_setAmplitudeRate));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_Ripple3D_initWithDuration));
    cls->defineFunction("getAmplitudeRate", _SE(js_cocos2dx_Ripple3D_getAmplitudeRate));
    cls->defineFunction("setAmplitude", _SE(js_cocos2dx_Ripple3D_setAmplitude));
    cls->defineFunction("getAmplitude", _SE(js_cocos2dx_Ripple3D_getAmplitude));
    cls->defineFunction("setPosition", _SE(js_cocos2dx_Ripple3D_setPosition));
    cls->defineFunction("getPosition", _SE(js_cocos2dx_Ripple3D_getPosition));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Ripple3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Ripple3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Ripple3D>(cls);

    __jsb_cocos2d_Ripple3D_proto = cls->getProto();
    __jsb_cocos2d_Ripple3D_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Shaky3D_proto = nullptr;
se::Class* __jsb_cocos2d_Shaky3D_class = nullptr;

static bool js_cocos2dx_Shaky3D_initWithDuration(se::State& s)
{
    cocos2d::Shaky3D* cobj = (cocos2d::Shaky3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Shaky3D_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        int arg2 = 0;
        bool arg3;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_boolean(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Shaky3D_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Shaky3D_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Shaky3D_initWithDuration)

static bool js_cocos2dx_Shaky3D_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        int arg2 = 0;
        bool arg3;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_boolean(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Shaky3D_create : Error processing arguments");
        auto result = cocos2d::Shaky3D::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Shaky3D_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Shaky3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Shaky3D_finalize)

static bool js_cocos2dx_Shaky3D_constructor(se::State& s)
{
    cocos2d::Shaky3D* cobj = new (std::nothrow) cocos2d::Shaky3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Shaky3D_constructor, __jsb_cocos2d_Shaky3D_class, js_cocos2d_Shaky3D_finalize)



extern se::Object* __jsb_cocos2d_Grid3DAction_proto;

bool js_cocos2d_Shaky3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Shaky3D)", s.nativeThisObject());
        cocos2d::Shaky3D* cobj = (cocos2d::Shaky3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Shaky3D_finalize)

bool js_register_cocos2dx_Shaky3D(se::Object* obj)
{
    auto cls = se::Class::create("Shaky3D", obj, __jsb_cocos2d_Grid3DAction_proto, _SE(js_cocos2dx_Shaky3D_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_Shaky3D_initWithDuration));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Shaky3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Shaky3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Shaky3D>(cls);

    __jsb_cocos2d_Shaky3D_proto = cls->getProto();
    __jsb_cocos2d_Shaky3D_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Liquid_proto = nullptr;
se::Class* __jsb_cocos2d_Liquid_class = nullptr;

static bool js_cocos2dx_Liquid_setAmplitudeRate(se::State& s)
{
    cocos2d::Liquid* cobj = (cocos2d::Liquid*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Liquid_setAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Liquid_setAmplitudeRate : Error processing arguments");
        cobj->setAmplitudeRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Liquid_setAmplitudeRate)

static bool js_cocos2dx_Liquid_initWithDuration(se::State& s)
{
    cocos2d::Liquid* cobj = (cocos2d::Liquid*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Liquid_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Liquid_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Liquid_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Liquid_initWithDuration)

static bool js_cocos2dx_Liquid_getAmplitude(se::State& s)
{
    cocos2d::Liquid* cobj = (cocos2d::Liquid*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Liquid_getAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitude();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Liquid_getAmplitude : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Liquid_getAmplitude)

static bool js_cocos2dx_Liquid_getAmplitudeRate(se::State& s)
{
    cocos2d::Liquid* cobj = (cocos2d::Liquid*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Liquid_getAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitudeRate();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Liquid_getAmplitudeRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Liquid_getAmplitudeRate)

static bool js_cocos2dx_Liquid_setAmplitude(se::State& s)
{
    cocos2d::Liquid* cobj = (cocos2d::Liquid*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Liquid_setAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Liquid_setAmplitude : Error processing arguments");
        cobj->setAmplitude(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Liquid_setAmplitude)

static bool js_cocos2dx_Liquid_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Liquid_create : Error processing arguments");
        auto result = cocos2d::Liquid::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Liquid_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Liquid_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Liquid_finalize)

static bool js_cocos2dx_Liquid_constructor(se::State& s)
{
    cocos2d::Liquid* cobj = new (std::nothrow) cocos2d::Liquid();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Liquid_constructor, __jsb_cocos2d_Liquid_class, js_cocos2d_Liquid_finalize)



extern se::Object* __jsb_cocos2d_Grid3DAction_proto;

bool js_cocos2d_Liquid_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Liquid)", s.nativeThisObject());
        cocos2d::Liquid* cobj = (cocos2d::Liquid*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Liquid_finalize)

bool js_register_cocos2dx_Liquid(se::Object* obj)
{
    auto cls = se::Class::create("Liquid", obj, __jsb_cocos2d_Grid3DAction_proto, _SE(js_cocos2dx_Liquid_constructor));

    cls->defineFunction("setAmplitudeRate", _SE(js_cocos2dx_Liquid_setAmplitudeRate));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_Liquid_initWithDuration));
    cls->defineFunction("getAmplitude", _SE(js_cocos2dx_Liquid_getAmplitude));
    cls->defineFunction("getAmplitudeRate", _SE(js_cocos2dx_Liquid_getAmplitudeRate));
    cls->defineFunction("setAmplitude", _SE(js_cocos2dx_Liquid_setAmplitude));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Liquid_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Liquid_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Liquid>(cls);

    __jsb_cocos2d_Liquid_proto = cls->getProto();
    __jsb_cocos2d_Liquid_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Waves_proto = nullptr;
se::Class* __jsb_cocos2d_Waves_class = nullptr;

static bool js_cocos2dx_Waves_setAmplitudeRate(se::State& s)
{
    cocos2d::Waves* cobj = (cocos2d::Waves*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Waves_setAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves_setAmplitudeRate : Error processing arguments");
        cobj->setAmplitudeRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves_setAmplitudeRate)

static bool js_cocos2dx_Waves_initWithDuration(se::State& s)
{
    cocos2d::Waves* cobj = (cocos2d::Waves*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Waves_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 6) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        float arg3 = 0;
        bool arg4;
        bool arg5;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        ok &= seval_to_boolean(args[4], &arg4);
        ok &= seval_to_boolean(args[5], &arg5);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3, arg4, arg5);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves_initWithDuration)

static bool js_cocos2dx_Waves_getAmplitude(se::State& s)
{
    cocos2d::Waves* cobj = (cocos2d::Waves*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Waves_getAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitude();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves_getAmplitude : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves_getAmplitude)

static bool js_cocos2dx_Waves_getAmplitudeRate(se::State& s)
{
    cocos2d::Waves* cobj = (cocos2d::Waves*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Waves_getAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitudeRate();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves_getAmplitudeRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves_getAmplitudeRate)

static bool js_cocos2dx_Waves_setAmplitude(se::State& s)
{
    cocos2d::Waves* cobj = (cocos2d::Waves*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Waves_setAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves_setAmplitude : Error processing arguments");
        cobj->setAmplitude(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves_setAmplitude)

static bool js_cocos2dx_Waves_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 6) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        float arg3 = 0;
        bool arg4;
        bool arg5;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        ok &= seval_to_boolean(args[4], &arg4);
        ok &= seval_to_boolean(args[5], &arg5);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Waves_create : Error processing arguments");
        auto result = cocos2d::Waves::create(arg0, arg1, arg2, arg3, arg4, arg5);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Waves_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Waves_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Waves_finalize)

static bool js_cocos2dx_Waves_constructor(se::State& s)
{
    cocos2d::Waves* cobj = new (std::nothrow) cocos2d::Waves();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Waves_constructor, __jsb_cocos2d_Waves_class, js_cocos2d_Waves_finalize)



extern se::Object* __jsb_cocos2d_Grid3DAction_proto;

bool js_cocos2d_Waves_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Waves)", s.nativeThisObject());
        cocos2d::Waves* cobj = (cocos2d::Waves*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Waves_finalize)

bool js_register_cocos2dx_Waves(se::Object* obj)
{
    auto cls = se::Class::create("Waves", obj, __jsb_cocos2d_Grid3DAction_proto, _SE(js_cocos2dx_Waves_constructor));

    cls->defineFunction("setAmplitudeRate", _SE(js_cocos2dx_Waves_setAmplitudeRate));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_Waves_initWithDuration));
    cls->defineFunction("getAmplitude", _SE(js_cocos2dx_Waves_getAmplitude));
    cls->defineFunction("getAmplitudeRate", _SE(js_cocos2dx_Waves_getAmplitudeRate));
    cls->defineFunction("setAmplitude", _SE(js_cocos2dx_Waves_setAmplitude));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Waves_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Waves_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Waves>(cls);

    __jsb_cocos2d_Waves_proto = cls->getProto();
    __jsb_cocos2d_Waves_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Twirl_proto = nullptr;
se::Class* __jsb_cocos2d_Twirl_class = nullptr;

static bool js_cocos2dx_Twirl_setAmplitudeRate(se::State& s)
{
    cocos2d::Twirl* cobj = (cocos2d::Twirl*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Twirl_setAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Twirl_setAmplitudeRate : Error processing arguments");
        cobj->setAmplitudeRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Twirl_setAmplitudeRate)

static bool js_cocos2dx_Twirl_initWithDuration(se::State& s)
{
    cocos2d::Twirl* cobj = (cocos2d::Twirl*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Twirl_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 5) {
        float arg0 = 0;
        cocos2d::Size arg1;
        cocos2d::Vec2 arg2;
        unsigned int arg3 = 0;
        float arg4 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_uint32(args[3], &arg3);
        ok &= seval_to_float(args[4], &arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Twirl_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3, arg4);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Twirl_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Twirl_initWithDuration)

static bool js_cocos2dx_Twirl_getAmplitudeRate(se::State& s)
{
    cocos2d::Twirl* cobj = (cocos2d::Twirl*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Twirl_getAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitudeRate();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Twirl_getAmplitudeRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Twirl_getAmplitudeRate)

static bool js_cocos2dx_Twirl_setAmplitude(se::State& s)
{
    cocos2d::Twirl* cobj = (cocos2d::Twirl*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Twirl_setAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Twirl_setAmplitude : Error processing arguments");
        cobj->setAmplitude(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Twirl_setAmplitude)

static bool js_cocos2dx_Twirl_getAmplitude(se::State& s)
{
    cocos2d::Twirl* cobj = (cocos2d::Twirl*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Twirl_getAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitude();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Twirl_getAmplitude : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Twirl_getAmplitude)

static bool js_cocos2dx_Twirl_setPosition(se::State& s)
{
    cocos2d::Twirl* cobj = (cocos2d::Twirl*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Twirl_setPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Twirl_setPosition : Error processing arguments");
        cobj->setPosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Twirl_setPosition)

static bool js_cocos2dx_Twirl_getPosition(se::State& s)
{
    cocos2d::Twirl* cobj = (cocos2d::Twirl*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Twirl_getPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getPosition();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Twirl_getPosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Twirl_getPosition)

static bool js_cocos2dx_Twirl_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 5) {
        float arg0 = 0;
        cocos2d::Size arg1;
        cocos2d::Vec2 arg2;
        unsigned int arg3 = 0;
        float arg4 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_uint32(args[3], &arg3);
        ok &= seval_to_float(args[4], &arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Twirl_create : Error processing arguments");
        auto result = cocos2d::Twirl::create(arg0, arg1, arg2, arg3, arg4);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Twirl_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Twirl_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Twirl_finalize)

static bool js_cocos2dx_Twirl_constructor(se::State& s)
{
    cocos2d::Twirl* cobj = new (std::nothrow) cocos2d::Twirl();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Twirl_constructor, __jsb_cocos2d_Twirl_class, js_cocos2d_Twirl_finalize)



extern se::Object* __jsb_cocos2d_Grid3DAction_proto;

bool js_cocos2d_Twirl_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Twirl)", s.nativeThisObject());
        cocos2d::Twirl* cobj = (cocos2d::Twirl*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Twirl_finalize)

bool js_register_cocos2dx_Twirl(se::Object* obj)
{
    auto cls = se::Class::create("Twirl", obj, __jsb_cocos2d_Grid3DAction_proto, _SE(js_cocos2dx_Twirl_constructor));

    cls->defineFunction("setAmplitudeRate", _SE(js_cocos2dx_Twirl_setAmplitudeRate));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_Twirl_initWithDuration));
    cls->defineFunction("getAmplitudeRate", _SE(js_cocos2dx_Twirl_getAmplitudeRate));
    cls->defineFunction("setAmplitude", _SE(js_cocos2dx_Twirl_setAmplitude));
    cls->defineFunction("getAmplitude", _SE(js_cocos2dx_Twirl_getAmplitude));
    cls->defineFunction("setPosition", _SE(js_cocos2dx_Twirl_setPosition));
    cls->defineFunction("getPosition", _SE(js_cocos2dx_Twirl_getPosition));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Twirl_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Twirl_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Twirl>(cls);

    __jsb_cocos2d_Twirl_proto = cls->getProto();
    __jsb_cocos2d_Twirl_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ActionManager_proto = nullptr;
se::Class* __jsb_cocos2d_ActionManager_class = nullptr;

static bool js_cocos2dx_ActionManager_getActionByTag(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_getActionByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        int arg0 = 0;
        const cocos2d::Node* arg1 = nullptr;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_getActionByTag : Error processing arguments");
        cocos2d::Action* result = cobj->getActionByTag(arg0, arg1);
        ok &= native_ptr_to_seval<cocos2d::Action>((cocos2d::Action*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_getActionByTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_getActionByTag)

static bool js_cocos2dx_ActionManager_removeActionByTag(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeActionByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        int arg0 = 0;
        cocos2d::Node* arg1 = nullptr;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_removeActionByTag : Error processing arguments");
        cobj->removeActionByTag(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeActionByTag)

static bool js_cocos2dx_ActionManager_removeActionsByFlags(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeActionsByFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        unsigned int arg0 = 0;
        cocos2d::Node* arg1 = nullptr;
        ok &= seval_to_uint32(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_removeActionsByFlags : Error processing arguments");
        cobj->removeActionsByFlags(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeActionsByFlags)

static bool js_cocos2dx_ActionManager_removeAllActions(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeAllActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllActions();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeAllActions)

static bool js_cocos2dx_ActionManager_addAction(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_addAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Action* arg0 = nullptr;
        cocos2d::Node* arg1 = nullptr;
        bool arg2;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_boolean(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_addAction : Error processing arguments");
        cobj->addAction(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_addAction)

static bool js_cocos2dx_ActionManager_resumeTarget(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_resumeTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_resumeTarget : Error processing arguments");
        cobj->resumeTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_resumeTarget)

static bool js_cocos2dx_ActionManager_update(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_update : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_update : Error processing arguments");
        cobj->update(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_update)

static bool js_cocos2dx_ActionManager_pauseTarget(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_pauseTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_pauseTarget : Error processing arguments");
        cobj->pauseTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_pauseTarget)

static bool js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget : Error processing arguments");
        ssize_t result = cobj->getNumberOfRunningActionsInTarget(arg0);
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget)

static bool js_cocos2dx_ActionManager_removeAllActionsFromTarget(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeAllActionsFromTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_removeAllActionsFromTarget : Error processing arguments");
        cobj->removeAllActionsFromTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeAllActionsFromTarget)

static bool js_cocos2dx_ActionManager_resumeTargets(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_resumeTargets : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::Node *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_resumeTargets : Error processing arguments");
        cobj->resumeTargets(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_resumeTargets)

static bool js_cocos2dx_ActionManager_removeAction(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Action* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_removeAction : Error processing arguments");
        cobj->removeAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeAction)

static bool js_cocos2dx_ActionManager_pauseAllRunningActions(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_pauseAllRunningActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vector<cocos2d::Node *> result = cobj->pauseAllRunningActions();
        ok &= Vector_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_pauseAllRunningActions : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_pauseAllRunningActions)

static bool js_cocos2dx_ActionManager_removeAllActionsByTag(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeAllActionsByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        int arg0 = 0;
        cocos2d::Node* arg1 = nullptr;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_removeAllActionsByTag : Error processing arguments");
        cobj->removeAllActionsByTag(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeAllActionsByTag)

static bool js_cocos2dx_ActionManager_getNumberOfRunningActionsInTargetByTag(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_getNumberOfRunningActionsInTargetByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const cocos2d::Node* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_getNumberOfRunningActionsInTargetByTag : Error processing arguments");
        unsigned long result = cobj->getNumberOfRunningActionsInTargetByTag(arg0, arg1);
        ok &= ulong_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_getNumberOfRunningActionsInTargetByTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_getNumberOfRunningActionsInTargetByTag)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ActionManager_finalize)

static bool js_cocos2dx_ActionManager_constructor(se::State& s)
{
    cocos2d::ActionManager* cobj = new (std::nothrow) cocos2d::ActionManager();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ActionManager_constructor, __jsb_cocos2d_ActionManager_class, js_cocos2d_ActionManager_finalize)

static bool js_cocos2dx_ActionManager_ctor(se::State& s)
{
    cocos2d::ActionManager* cobj = new (std::nothrow) cocos2d::ActionManager();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ActionManager_ctor, __jsb_cocos2d_ActionManager_class, js_cocos2d_ActionManager_finalize)


    


bool js_cocos2d_ActionManager_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ActionManager)", s.nativeThisObject());
        cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ActionManager_finalize)

bool js_register_cocos2dx_ActionManager(se::Object* obj)
{
    auto cls = se::Class::create("ActionManager", obj, nullptr, _SE(js_cocos2dx_ActionManager_constructor));

    cls->defineFunction("getActionByTag", _SE(js_cocos2dx_ActionManager_getActionByTag));
    cls->defineFunction("removeActionByTag", _SE(js_cocos2dx_ActionManager_removeActionByTag));
    cls->defineFunction("removeActionsByFlags", _SE(js_cocos2dx_ActionManager_removeActionsByFlags));
    cls->defineFunction("removeAllActions", _SE(js_cocos2dx_ActionManager_removeAllActions));
    cls->defineFunction("addAction", _SE(js_cocos2dx_ActionManager_addAction));
    cls->defineFunction("resumeTarget", _SE(js_cocos2dx_ActionManager_resumeTarget));
    cls->defineFunction("update", _SE(js_cocos2dx_ActionManager_update));
    cls->defineFunction("pauseTarget", _SE(js_cocos2dx_ActionManager_pauseTarget));
    cls->defineFunction("getNumberOfRunningActionsInTarget", _SE(js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget));
    cls->defineFunction("removeAllActionsFromTarget", _SE(js_cocos2dx_ActionManager_removeAllActionsFromTarget));
    cls->defineFunction("resumeTargets", _SE(js_cocos2dx_ActionManager_resumeTargets));
    cls->defineFunction("removeAction", _SE(js_cocos2dx_ActionManager_removeAction));
    cls->defineFunction("pauseAllRunningActions", _SE(js_cocos2dx_ActionManager_pauseAllRunningActions));
    cls->defineFunction("removeAllActionsByTag", _SE(js_cocos2dx_ActionManager_removeAllActionsByTag));
    cls->defineFunction("getNumberOfRunningActionsInTargetByTag", _SE(js_cocos2dx_ActionManager_getNumberOfRunningActionsInTargetByTag));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ActionManager_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ActionManager_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ActionManager>(cls);

    __jsb_cocos2d_ActionManager_proto = cls->getProto();
    __jsb_cocos2d_ActionManager_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ActionManager.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_PageTurn3D_proto = nullptr;
se::Class* __jsb_cocos2d_PageTurn3D_class = nullptr;

static bool js_cocos2dx_PageTurn3D_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Size arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_PageTurn3D_create : Error processing arguments");
        auto result = cocos2d::PageTurn3D::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_PageTurn3D_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_PageTurn3D_create)


extern se::Object* __jsb_cocos2d_Grid3DAction_proto;


bool js_register_cocos2dx_PageTurn3D(se::Object* obj)
{
    auto cls = se::Class::create("PageTurn3D", obj, __jsb_cocos2d_Grid3DAction_proto, nullptr);

    cls->defineStaticFunction("create", _SE(js_cocos2dx_PageTurn3D_create));
    cls->install();
    JSBClassType::registerClass<cocos2d::PageTurn3D>(cls);

    __jsb_cocos2d_PageTurn3D_proto = cls->getProto();
    __jsb_cocos2d_PageTurn3D_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ProgressTo_proto = nullptr;
se::Class* __jsb_cocos2d_ProgressTo_class = nullptr;

static bool js_cocos2dx_ProgressTo_initWithDuration(se::State& s)
{
    cocos2d::ProgressTo* cobj = (cocos2d::ProgressTo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTo_initWithDuration)

static bool js_cocos2dx_ProgressTo_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTo_create : Error processing arguments");
        auto result = cocos2d::ProgressTo::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ProgressTo_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ProgressTo_finalize)

static bool js_cocos2dx_ProgressTo_constructor(se::State& s)
{
    cocos2d::ProgressTo* cobj = new (std::nothrow) cocos2d::ProgressTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ProgressTo_constructor, __jsb_cocos2d_ProgressTo_class, js_cocos2d_ProgressTo_finalize)

static bool js_cocos2dx_ProgressTo_ctor(se::State& s)
{
    cocos2d::ProgressTo* cobj = new (std::nothrow) cocos2d::ProgressTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ProgressTo_ctor, __jsb_cocos2d_ProgressTo_class, js_cocos2d_ProgressTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_ProgressTo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ProgressTo)", s.nativeThisObject());
        cocos2d::ProgressTo* cobj = (cocos2d::ProgressTo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ProgressTo_finalize)

bool js_register_cocos2dx_ProgressTo(se::Object* obj)
{
    auto cls = se::Class::create("ProgressTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_ProgressTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_ProgressTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ProgressTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ProgressTo_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ProgressTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ProgressTo>(cls);

    __jsb_cocos2d_ProgressTo_proto = cls->getProto();
    __jsb_cocos2d_ProgressTo_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ProgressTo.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ProgressFromTo_proto = nullptr;
se::Class* __jsb_cocos2d_ProgressFromTo_class = nullptr;

static bool js_cocos2dx_ProgressFromTo_initWithDuration(se::State& s)
{
    cocos2d::ProgressFromTo* cobj = (cocos2d::ProgressFromTo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressFromTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressFromTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressFromTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressFromTo_initWithDuration)

static bool js_cocos2dx_ProgressFromTo_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressFromTo_create : Error processing arguments");
        auto result = cocos2d::ProgressFromTo::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ProgressFromTo_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressFromTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ProgressFromTo_finalize)

static bool js_cocos2dx_ProgressFromTo_constructor(se::State& s)
{
    cocos2d::ProgressFromTo* cobj = new (std::nothrow) cocos2d::ProgressFromTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ProgressFromTo_constructor, __jsb_cocos2d_ProgressFromTo_class, js_cocos2d_ProgressFromTo_finalize)

static bool js_cocos2dx_ProgressFromTo_ctor(se::State& s)
{
    cocos2d::ProgressFromTo* cobj = new (std::nothrow) cocos2d::ProgressFromTo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ProgressFromTo_ctor, __jsb_cocos2d_ProgressFromTo_class, js_cocos2d_ProgressFromTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

bool js_cocos2d_ProgressFromTo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ProgressFromTo)", s.nativeThisObject());
        cocos2d::ProgressFromTo* cobj = (cocos2d::ProgressFromTo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ProgressFromTo_finalize)

bool js_register_cocos2dx_ProgressFromTo(se::Object* obj)
{
    auto cls = se::Class::create("ProgressFromTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_ProgressFromTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_ProgressFromTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ProgressFromTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ProgressFromTo_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ProgressFromTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ProgressFromTo>(cls);

    __jsb_cocos2d_ProgressFromTo_proto = cls->getProto();
    __jsb_cocos2d_ProgressFromTo_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ProgressFromTo.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ShakyTiles3D_proto = nullptr;
se::Class* __jsb_cocos2d_ShakyTiles3D_class = nullptr;

static bool js_cocos2dx_ShakyTiles3D_initWithDuration(se::State& s)
{
    cocos2d::ShakyTiles3D* cobj = (cocos2d::ShakyTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ShakyTiles3D_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        int arg2 = 0;
        bool arg3;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_boolean(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShakyTiles3D_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShakyTiles3D_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ShakyTiles3D_initWithDuration)

static bool js_cocos2dx_ShakyTiles3D_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        int arg2 = 0;
        bool arg3;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_boolean(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShakyTiles3D_create : Error processing arguments");
        auto result = cocos2d::ShakyTiles3D::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ShakyTiles3D_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ShakyTiles3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ShakyTiles3D_finalize)

static bool js_cocos2dx_ShakyTiles3D_constructor(se::State& s)
{
    cocos2d::ShakyTiles3D* cobj = new (std::nothrow) cocos2d::ShakyTiles3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ShakyTiles3D_constructor, __jsb_cocos2d_ShakyTiles3D_class, js_cocos2d_ShakyTiles3D_finalize)



extern se::Object* __jsb_cocos2d_TiledGrid3DAction_proto;

bool js_cocos2d_ShakyTiles3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ShakyTiles3D)", s.nativeThisObject());
        cocos2d::ShakyTiles3D* cobj = (cocos2d::ShakyTiles3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ShakyTiles3D_finalize)

bool js_register_cocos2dx_ShakyTiles3D(se::Object* obj)
{
    auto cls = se::Class::create("ShakyTiles3D", obj, __jsb_cocos2d_TiledGrid3DAction_proto, _SE(js_cocos2dx_ShakyTiles3D_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_ShakyTiles3D_initWithDuration));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ShakyTiles3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ShakyTiles3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ShakyTiles3D>(cls);

    __jsb_cocos2d_ShakyTiles3D_proto = cls->getProto();
    __jsb_cocos2d_ShakyTiles3D_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ShatteredTiles3D_proto = nullptr;
se::Class* __jsb_cocos2d_ShatteredTiles3D_class = nullptr;

static bool js_cocos2dx_ShatteredTiles3D_initWithDuration(se::State& s)
{
    cocos2d::ShatteredTiles3D* cobj = (cocos2d::ShatteredTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ShatteredTiles3D_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        int arg2 = 0;
        bool arg3;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_boolean(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShatteredTiles3D_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShatteredTiles3D_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ShatteredTiles3D_initWithDuration)

static bool js_cocos2dx_ShatteredTiles3D_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        int arg2 = 0;
        bool arg3;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_boolean(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShatteredTiles3D_create : Error processing arguments");
        auto result = cocos2d::ShatteredTiles3D::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ShatteredTiles3D_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ShatteredTiles3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ShatteredTiles3D_finalize)

static bool js_cocos2dx_ShatteredTiles3D_constructor(se::State& s)
{
    cocos2d::ShatteredTiles3D* cobj = new (std::nothrow) cocos2d::ShatteredTiles3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ShatteredTiles3D_constructor, __jsb_cocos2d_ShatteredTiles3D_class, js_cocos2d_ShatteredTiles3D_finalize)



extern se::Object* __jsb_cocos2d_TiledGrid3DAction_proto;

bool js_cocos2d_ShatteredTiles3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ShatteredTiles3D)", s.nativeThisObject());
        cocos2d::ShatteredTiles3D* cobj = (cocos2d::ShatteredTiles3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ShatteredTiles3D_finalize)

bool js_register_cocos2dx_ShatteredTiles3D(se::Object* obj)
{
    auto cls = se::Class::create("ShatteredTiles3D", obj, __jsb_cocos2d_TiledGrid3DAction_proto, _SE(js_cocos2dx_ShatteredTiles3D_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_ShatteredTiles3D_initWithDuration));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ShatteredTiles3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ShatteredTiles3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ShatteredTiles3D>(cls);

    __jsb_cocos2d_ShatteredTiles3D_proto = cls->getProto();
    __jsb_cocos2d_ShatteredTiles3D_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ShuffleTiles_proto = nullptr;
se::Class* __jsb_cocos2d_ShuffleTiles_class = nullptr;

static bool js_cocos2dx_ShuffleTiles_placeTile(se::State& s)
{
    cocos2d::ShuffleTiles* cobj = (cocos2d::ShuffleTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ShuffleTiles_placeTile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Vec2 arg0;
        cocos2d::Tile* arg1 = nullptr;
        ok &= seval_to_Vec2(args[0], &arg0);
        #pragma warning NO CONVERSION TO NATIVE FOR Tile*
		ok = false;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShuffleTiles_placeTile : Error processing arguments");
        cobj->placeTile(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ShuffleTiles_placeTile)

static bool js_cocos2dx_ShuffleTiles_shuffle(se::State& s)
{
    cocos2d::ShuffleTiles* cobj = (cocos2d::ShuffleTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ShuffleTiles_shuffle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        unsigned int* arg0 = 0;
        unsigned int arg1 = 0;
        #pragma warning NO CONVERSION TO NATIVE FOR unsigned int*
		ok = false;
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShuffleTiles_shuffle : Error processing arguments");
        cobj->shuffle(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ShuffleTiles_shuffle)

static bool js_cocos2dx_ShuffleTiles_initWithDuration(se::State& s)
{
    cocos2d::ShuffleTiles* cobj = (cocos2d::ShuffleTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ShuffleTiles_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShuffleTiles_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShuffleTiles_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ShuffleTiles_initWithDuration)

static bool js_cocos2dx_ShuffleTiles_getDelta(se::State& s)
{
    cocos2d::ShuffleTiles* cobj = (cocos2d::ShuffleTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ShuffleTiles_getDelta : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShuffleTiles_getDelta : Error processing arguments");
        cocos2d::Size result = cobj->getDelta(arg0);
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShuffleTiles_getDelta : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ShuffleTiles_getDelta)

static bool js_cocos2dx_ShuffleTiles_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ShuffleTiles_create : Error processing arguments");
        auto result = cocos2d::ShuffleTiles::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ShuffleTiles_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ShuffleTiles_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ShuffleTiles_finalize)

static bool js_cocos2dx_ShuffleTiles_constructor(se::State& s)
{
    cocos2d::ShuffleTiles* cobj = new (std::nothrow) cocos2d::ShuffleTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ShuffleTiles_constructor, __jsb_cocos2d_ShuffleTiles_class, js_cocos2d_ShuffleTiles_finalize)



extern se::Object* __jsb_cocos2d_TiledGrid3DAction_proto;

bool js_cocos2d_ShuffleTiles_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ShuffleTiles)", s.nativeThisObject());
        cocos2d::ShuffleTiles* cobj = (cocos2d::ShuffleTiles*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ShuffleTiles_finalize)

bool js_register_cocos2dx_ShuffleTiles(se::Object* obj)
{
    auto cls = se::Class::create("ShuffleTiles", obj, __jsb_cocos2d_TiledGrid3DAction_proto, _SE(js_cocos2dx_ShuffleTiles_constructor));

    cls->defineFunction("placeTile", _SE(js_cocos2dx_ShuffleTiles_placeTile));
    cls->defineFunction("shuffle", _SE(js_cocos2dx_ShuffleTiles_shuffle));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_ShuffleTiles_initWithDuration));
    cls->defineFunction("getDelta", _SE(js_cocos2dx_ShuffleTiles_getDelta));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ShuffleTiles_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ShuffleTiles_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ShuffleTiles>(cls);

    __jsb_cocos2d_ShuffleTiles_proto = cls->getProto();
    __jsb_cocos2d_ShuffleTiles_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_FadeOutTRTiles_proto = nullptr;
se::Class* __jsb_cocos2d_FadeOutTRTiles_class = nullptr;

static bool js_cocos2dx_FadeOutTRTiles_turnOnTile(se::State& s)
{
    cocos2d::FadeOutTRTiles* cobj = (cocos2d::FadeOutTRTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FadeOutTRTiles_turnOnTile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeOutTRTiles_turnOnTile : Error processing arguments");
        cobj->turnOnTile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOutTRTiles_turnOnTile)

static bool js_cocos2dx_FadeOutTRTiles_turnOffTile(se::State& s)
{
    cocos2d::FadeOutTRTiles* cobj = (cocos2d::FadeOutTRTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FadeOutTRTiles_turnOffTile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeOutTRTiles_turnOffTile : Error processing arguments");
        cobj->turnOffTile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOutTRTiles_turnOffTile)

static bool js_cocos2dx_FadeOutTRTiles_transformTile(se::State& s)
{
    cocos2d::FadeOutTRTiles* cobj = (cocos2d::FadeOutTRTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FadeOutTRTiles_transformTile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Vec2 arg0;
        float arg1 = 0;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeOutTRTiles_transformTile : Error processing arguments");
        cobj->transformTile(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOutTRTiles_transformTile)

static bool js_cocos2dx_FadeOutTRTiles_testFunc(se::State& s)
{
    cocos2d::FadeOutTRTiles* cobj = (cocos2d::FadeOutTRTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_FadeOutTRTiles_testFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Size arg0;
        float arg1 = 0;
        ok &= seval_to_Size(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeOutTRTiles_testFunc : Error processing arguments");
        float result = cobj->testFunc(arg0, arg1);
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeOutTRTiles_testFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOutTRTiles_testFunc)

static bool js_cocos2dx_FadeOutTRTiles_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Size arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeOutTRTiles_create : Error processing arguments");
        auto result = cocos2d::FadeOutTRTiles::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FadeOutTRTiles_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOutTRTiles_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FadeOutTRTiles_finalize)

static bool js_cocos2dx_FadeOutTRTiles_constructor(se::State& s)
{
    cocos2d::FadeOutTRTiles* cobj = new (std::nothrow) cocos2d::FadeOutTRTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FadeOutTRTiles_constructor, __jsb_cocos2d_FadeOutTRTiles_class, js_cocos2d_FadeOutTRTiles_finalize)

static bool js_cocos2dx_FadeOutTRTiles_ctor(se::State& s)
{
    cocos2d::FadeOutTRTiles* cobj = new (std::nothrow) cocos2d::FadeOutTRTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FadeOutTRTiles_ctor, __jsb_cocos2d_FadeOutTRTiles_class, js_cocos2d_FadeOutTRTiles_finalize)


    

extern se::Object* __jsb_cocos2d_TiledGrid3DAction_proto;

bool js_cocos2d_FadeOutTRTiles_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::FadeOutTRTiles)", s.nativeThisObject());
        cocos2d::FadeOutTRTiles* cobj = (cocos2d::FadeOutTRTiles*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FadeOutTRTiles_finalize)

bool js_register_cocos2dx_FadeOutTRTiles(se::Object* obj)
{
    auto cls = se::Class::create("FadeOutTRTiles", obj, __jsb_cocos2d_TiledGrid3DAction_proto, _SE(js_cocos2dx_FadeOutTRTiles_constructor));

    cls->defineFunction("turnOnTile", _SE(js_cocos2dx_FadeOutTRTiles_turnOnTile));
    cls->defineFunction("turnOffTile", _SE(js_cocos2dx_FadeOutTRTiles_turnOffTile));
    cls->defineFunction("transformTile", _SE(js_cocos2dx_FadeOutTRTiles_transformTile));
    cls->defineFunction("testFunc", _SE(js_cocos2dx_FadeOutTRTiles_testFunc));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FadeOutTRTiles_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FadeOutTRTiles_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_FadeOutTRTiles_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FadeOutTRTiles>(cls);

    __jsb_cocos2d_FadeOutTRTiles_proto = cls->getProto();
    __jsb_cocos2d_FadeOutTRTiles_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.FadeOutTRTiles.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_FadeOutBLTiles_proto = nullptr;
se::Class* __jsb_cocos2d_FadeOutBLTiles_class = nullptr;

static bool js_cocos2dx_FadeOutBLTiles_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Size arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeOutBLTiles_create : Error processing arguments");
        auto result = cocos2d::FadeOutBLTiles::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FadeOutBLTiles_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOutBLTiles_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FadeOutBLTiles_finalize)

static bool js_cocos2dx_FadeOutBLTiles_constructor(se::State& s)
{
    cocos2d::FadeOutBLTiles* cobj = new (std::nothrow) cocos2d::FadeOutBLTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FadeOutBLTiles_constructor, __jsb_cocos2d_FadeOutBLTiles_class, js_cocos2d_FadeOutBLTiles_finalize)

static bool js_cocos2dx_FadeOutBLTiles_ctor(se::State& s)
{
    cocos2d::FadeOutBLTiles* cobj = new (std::nothrow) cocos2d::FadeOutBLTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FadeOutBLTiles_ctor, __jsb_cocos2d_FadeOutBLTiles_class, js_cocos2d_FadeOutBLTiles_finalize)


    

extern se::Object* __jsb_cocos2d_FadeOutTRTiles_proto;

bool js_cocos2d_FadeOutBLTiles_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::FadeOutBLTiles)", s.nativeThisObject());
        cocos2d::FadeOutBLTiles* cobj = (cocos2d::FadeOutBLTiles*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FadeOutBLTiles_finalize)

bool js_register_cocos2dx_FadeOutBLTiles(se::Object* obj)
{
    auto cls = se::Class::create("FadeOutBLTiles", obj, __jsb_cocos2d_FadeOutTRTiles_proto, _SE(js_cocos2dx_FadeOutBLTiles_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_FadeOutBLTiles_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FadeOutBLTiles_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_FadeOutBLTiles_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FadeOutBLTiles>(cls);

    __jsb_cocos2d_FadeOutBLTiles_proto = cls->getProto();
    __jsb_cocos2d_FadeOutBLTiles_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.FadeOutBLTiles.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_FadeOutUpTiles_proto = nullptr;
se::Class* __jsb_cocos2d_FadeOutUpTiles_class = nullptr;

static bool js_cocos2dx_FadeOutUpTiles_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Size arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeOutUpTiles_create : Error processing arguments");
        auto result = cocos2d::FadeOutUpTiles::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FadeOutUpTiles_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOutUpTiles_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FadeOutUpTiles_finalize)

static bool js_cocos2dx_FadeOutUpTiles_constructor(se::State& s)
{
    cocos2d::FadeOutUpTiles* cobj = new (std::nothrow) cocos2d::FadeOutUpTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FadeOutUpTiles_constructor, __jsb_cocos2d_FadeOutUpTiles_class, js_cocos2d_FadeOutUpTiles_finalize)

static bool js_cocos2dx_FadeOutUpTiles_ctor(se::State& s)
{
    cocos2d::FadeOutUpTiles* cobj = new (std::nothrow) cocos2d::FadeOutUpTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FadeOutUpTiles_ctor, __jsb_cocos2d_FadeOutUpTiles_class, js_cocos2d_FadeOutUpTiles_finalize)


    

extern se::Object* __jsb_cocos2d_FadeOutTRTiles_proto;

bool js_cocos2d_FadeOutUpTiles_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::FadeOutUpTiles)", s.nativeThisObject());
        cocos2d::FadeOutUpTiles* cobj = (cocos2d::FadeOutUpTiles*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FadeOutUpTiles_finalize)

bool js_register_cocos2dx_FadeOutUpTiles(se::Object* obj)
{
    auto cls = se::Class::create("FadeOutUpTiles", obj, __jsb_cocos2d_FadeOutTRTiles_proto, _SE(js_cocos2dx_FadeOutUpTiles_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_FadeOutUpTiles_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FadeOutUpTiles_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_FadeOutUpTiles_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FadeOutUpTiles>(cls);

    __jsb_cocos2d_FadeOutUpTiles_proto = cls->getProto();
    __jsb_cocos2d_FadeOutUpTiles_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.FadeOutUpTiles.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_FadeOutDownTiles_proto = nullptr;
se::Class* __jsb_cocos2d_FadeOutDownTiles_class = nullptr;

static bool js_cocos2dx_FadeOutDownTiles_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Size arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_FadeOutDownTiles_create : Error processing arguments");
        auto result = cocos2d::FadeOutDownTiles::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FadeOutDownTiles_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOutDownTiles_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FadeOutDownTiles_finalize)

static bool js_cocos2dx_FadeOutDownTiles_constructor(se::State& s)
{
    cocos2d::FadeOutDownTiles* cobj = new (std::nothrow) cocos2d::FadeOutDownTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FadeOutDownTiles_constructor, __jsb_cocos2d_FadeOutDownTiles_class, js_cocos2d_FadeOutDownTiles_finalize)

static bool js_cocos2dx_FadeOutDownTiles_ctor(se::State& s)
{
    cocos2d::FadeOutDownTiles* cobj = new (std::nothrow) cocos2d::FadeOutDownTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FadeOutDownTiles_ctor, __jsb_cocos2d_FadeOutDownTiles_class, js_cocos2d_FadeOutDownTiles_finalize)


    

extern se::Object* __jsb_cocos2d_FadeOutUpTiles_proto;

bool js_cocos2d_FadeOutDownTiles_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::FadeOutDownTiles)", s.nativeThisObject());
        cocos2d::FadeOutDownTiles* cobj = (cocos2d::FadeOutDownTiles*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FadeOutDownTiles_finalize)

bool js_register_cocos2dx_FadeOutDownTiles(se::Object* obj)
{
    auto cls = se::Class::create("FadeOutDownTiles", obj, __jsb_cocos2d_FadeOutUpTiles_proto, _SE(js_cocos2dx_FadeOutDownTiles_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_FadeOutDownTiles_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FadeOutDownTiles_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_FadeOutDownTiles_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FadeOutDownTiles>(cls);

    __jsb_cocos2d_FadeOutDownTiles_proto = cls->getProto();
    __jsb_cocos2d_FadeOutDownTiles_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.FadeOutDownTiles.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TurnOffTiles_proto = nullptr;
se::Class* __jsb_cocos2d_TurnOffTiles_class = nullptr;

static bool js_cocos2dx_TurnOffTiles_turnOnTile(se::State& s)
{
    cocos2d::TurnOffTiles* cobj = (cocos2d::TurnOffTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TurnOffTiles_turnOnTile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TurnOffTiles_turnOnTile : Error processing arguments");
        cobj->turnOnTile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TurnOffTiles_turnOnTile)

static bool js_cocos2dx_TurnOffTiles_turnOffTile(se::State& s)
{
    cocos2d::TurnOffTiles* cobj = (cocos2d::TurnOffTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TurnOffTiles_turnOffTile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TurnOffTiles_turnOffTile : Error processing arguments");
        cobj->turnOffTile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TurnOffTiles_turnOffTile)

static bool js_cocos2dx_TurnOffTiles_shuffle(se::State& s)
{
    cocos2d::TurnOffTiles* cobj = (cocos2d::TurnOffTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TurnOffTiles_shuffle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        unsigned int* arg0 = 0;
        unsigned int arg1 = 0;
        #pragma warning NO CONVERSION TO NATIVE FOR unsigned int*
		ok = false;
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TurnOffTiles_shuffle : Error processing arguments");
        cobj->shuffle(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TurnOffTiles_shuffle)

static bool js_cocos2dx_TurnOffTiles_initWithDuration(se::State& s)
{
    cocos2d::TurnOffTiles* cobj = (cocos2d::TurnOffTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TurnOffTiles_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TurnOffTiles_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TurnOffTiles_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TurnOffTiles_initWithDuration)

static bool js_cocos2dx_TurnOffTiles_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg1;
            ok &= seval_to_Size(args[1], &arg1);
            if (!ok) { ok = true; break; }
            unsigned int arg2 = 0;
            ok &= seval_to_uint32(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TurnOffTiles* result = cocos2d::TurnOffTiles::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::TurnOffTiles>((cocos2d::TurnOffTiles*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TurnOffTiles_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg1;
            ok &= seval_to_Size(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TurnOffTiles* result = cocos2d::TurnOffTiles::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::TurnOffTiles>((cocos2d::TurnOffTiles*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TurnOffTiles_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TurnOffTiles_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TurnOffTiles_finalize)

static bool js_cocos2dx_TurnOffTiles_constructor(se::State& s)
{
    cocos2d::TurnOffTiles* cobj = new (std::nothrow) cocos2d::TurnOffTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TurnOffTiles_constructor, __jsb_cocos2d_TurnOffTiles_class, js_cocos2d_TurnOffTiles_finalize)



extern se::Object* __jsb_cocos2d_TiledGrid3DAction_proto;

bool js_cocos2d_TurnOffTiles_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TurnOffTiles)", s.nativeThisObject());
        cocos2d::TurnOffTiles* cobj = (cocos2d::TurnOffTiles*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TurnOffTiles_finalize)

bool js_register_cocos2dx_TurnOffTiles(se::Object* obj)
{
    auto cls = se::Class::create("TurnOffTiles", obj, __jsb_cocos2d_TiledGrid3DAction_proto, _SE(js_cocos2dx_TurnOffTiles_constructor));

    cls->defineFunction("turnOnTile", _SE(js_cocos2dx_TurnOffTiles_turnOnTile));
    cls->defineFunction("turnOffTile", _SE(js_cocos2dx_TurnOffTiles_turnOffTile));
    cls->defineFunction("shuffle", _SE(js_cocos2dx_TurnOffTiles_shuffle));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_TurnOffTiles_initWithDuration));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TurnOffTiles_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TurnOffTiles_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TurnOffTiles>(cls);

    __jsb_cocos2d_TurnOffTiles_proto = cls->getProto();
    __jsb_cocos2d_TurnOffTiles_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_WavesTiles3D_proto = nullptr;
se::Class* __jsb_cocos2d_WavesTiles3D_class = nullptr;

static bool js_cocos2dx_WavesTiles3D_setAmplitudeRate(se::State& s)
{
    cocos2d::WavesTiles3D* cobj = (cocos2d::WavesTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_WavesTiles3D_setAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_WavesTiles3D_setAmplitudeRate : Error processing arguments");
        cobj->setAmplitudeRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_WavesTiles3D_setAmplitudeRate)

static bool js_cocos2dx_WavesTiles3D_initWithDuration(se::State& s)
{
    cocos2d::WavesTiles3D* cobj = (cocos2d::WavesTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_WavesTiles3D_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_WavesTiles3D_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_WavesTiles3D_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_WavesTiles3D_initWithDuration)

static bool js_cocos2dx_WavesTiles3D_getAmplitude(se::State& s)
{
    cocos2d::WavesTiles3D* cobj = (cocos2d::WavesTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_WavesTiles3D_getAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitude();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_WavesTiles3D_getAmplitude : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_WavesTiles3D_getAmplitude)

static bool js_cocos2dx_WavesTiles3D_getAmplitudeRate(se::State& s)
{
    cocos2d::WavesTiles3D* cobj = (cocos2d::WavesTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_WavesTiles3D_getAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitudeRate();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_WavesTiles3D_getAmplitudeRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_WavesTiles3D_getAmplitudeRate)

static bool js_cocos2dx_WavesTiles3D_setAmplitude(se::State& s)
{
    cocos2d::WavesTiles3D* cobj = (cocos2d::WavesTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_WavesTiles3D_setAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_WavesTiles3D_setAmplitude : Error processing arguments");
        cobj->setAmplitude(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_WavesTiles3D_setAmplitude)

static bool js_cocos2dx_WavesTiles3D_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_WavesTiles3D_create : Error processing arguments");
        auto result = cocos2d::WavesTiles3D::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_WavesTiles3D_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_WavesTiles3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_WavesTiles3D_finalize)

static bool js_cocos2dx_WavesTiles3D_constructor(se::State& s)
{
    cocos2d::WavesTiles3D* cobj = new (std::nothrow) cocos2d::WavesTiles3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_WavesTiles3D_constructor, __jsb_cocos2d_WavesTiles3D_class, js_cocos2d_WavesTiles3D_finalize)



extern se::Object* __jsb_cocos2d_TiledGrid3DAction_proto;

bool js_cocos2d_WavesTiles3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::WavesTiles3D)", s.nativeThisObject());
        cocos2d::WavesTiles3D* cobj = (cocos2d::WavesTiles3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_WavesTiles3D_finalize)

bool js_register_cocos2dx_WavesTiles3D(se::Object* obj)
{
    auto cls = se::Class::create("WavesTiles3D", obj, __jsb_cocos2d_TiledGrid3DAction_proto, _SE(js_cocos2dx_WavesTiles3D_constructor));

    cls->defineFunction("setAmplitudeRate", _SE(js_cocos2dx_WavesTiles3D_setAmplitudeRate));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_WavesTiles3D_initWithDuration));
    cls->defineFunction("getAmplitude", _SE(js_cocos2dx_WavesTiles3D_getAmplitude));
    cls->defineFunction("getAmplitudeRate", _SE(js_cocos2dx_WavesTiles3D_getAmplitudeRate));
    cls->defineFunction("setAmplitude", _SE(js_cocos2dx_WavesTiles3D_setAmplitude));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_WavesTiles3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_WavesTiles3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::WavesTiles3D>(cls);

    __jsb_cocos2d_WavesTiles3D_proto = cls->getProto();
    __jsb_cocos2d_WavesTiles3D_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_JumpTiles3D_proto = nullptr;
se::Class* __jsb_cocos2d_JumpTiles3D_class = nullptr;

static bool js_cocos2dx_JumpTiles3D_setAmplitudeRate(se::State& s)
{
    cocos2d::JumpTiles3D* cobj = (cocos2d::JumpTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_JumpTiles3D_setAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpTiles3D_setAmplitudeRate : Error processing arguments");
        cobj->setAmplitudeRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpTiles3D_setAmplitudeRate)

static bool js_cocos2dx_JumpTiles3D_initWithDuration(se::State& s)
{
    cocos2d::JumpTiles3D* cobj = (cocos2d::JumpTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_JumpTiles3D_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpTiles3D_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpTiles3D_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpTiles3D_initWithDuration)

static bool js_cocos2dx_JumpTiles3D_getAmplitude(se::State& s)
{
    cocos2d::JumpTiles3D* cobj = (cocos2d::JumpTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_JumpTiles3D_getAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitude();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpTiles3D_getAmplitude : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpTiles3D_getAmplitude)

static bool js_cocos2dx_JumpTiles3D_getAmplitudeRate(se::State& s)
{
    cocos2d::JumpTiles3D* cobj = (cocos2d::JumpTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_JumpTiles3D_getAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitudeRate();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpTiles3D_getAmplitudeRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpTiles3D_getAmplitudeRate)

static bool js_cocos2dx_JumpTiles3D_setAmplitude(se::State& s)
{
    cocos2d::JumpTiles3D* cobj = (cocos2d::JumpTiles3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_JumpTiles3D_setAmplitude : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpTiles3D_setAmplitude : Error processing arguments");
        cobj->setAmplitude(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpTiles3D_setAmplitude)

static bool js_cocos2dx_JumpTiles3D_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Size arg1;
        unsigned int arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_JumpTiles3D_create : Error processing arguments");
        auto result = cocos2d::JumpTiles3D::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_JumpTiles3D_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpTiles3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_JumpTiles3D_finalize)

static bool js_cocos2dx_JumpTiles3D_constructor(se::State& s)
{
    cocos2d::JumpTiles3D* cobj = new (std::nothrow) cocos2d::JumpTiles3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_JumpTiles3D_constructor, __jsb_cocos2d_JumpTiles3D_class, js_cocos2d_JumpTiles3D_finalize)

static bool js_cocos2dx_JumpTiles3D_ctor(se::State& s)
{
    cocos2d::JumpTiles3D* cobj = new (std::nothrow) cocos2d::JumpTiles3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_JumpTiles3D_ctor, __jsb_cocos2d_JumpTiles3D_class, js_cocos2d_JumpTiles3D_finalize)


    

extern se::Object* __jsb_cocos2d_TiledGrid3DAction_proto;

bool js_cocos2d_JumpTiles3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::JumpTiles3D)", s.nativeThisObject());
        cocos2d::JumpTiles3D* cobj = (cocos2d::JumpTiles3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_JumpTiles3D_finalize)

bool js_register_cocos2dx_JumpTiles3D(se::Object* obj)
{
    auto cls = se::Class::create("JumpTiles3D", obj, __jsb_cocos2d_TiledGrid3DAction_proto, _SE(js_cocos2dx_JumpTiles3D_constructor));

    cls->defineFunction("setAmplitudeRate", _SE(js_cocos2dx_JumpTiles3D_setAmplitudeRate));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_JumpTiles3D_initWithDuration));
    cls->defineFunction("getAmplitude", _SE(js_cocos2dx_JumpTiles3D_getAmplitude));
    cls->defineFunction("getAmplitudeRate", _SE(js_cocos2dx_JumpTiles3D_getAmplitudeRate));
    cls->defineFunction("setAmplitude", _SE(js_cocos2dx_JumpTiles3D_setAmplitude));
    cls->defineFunction("ctor", _SE(js_cocos2dx_JumpTiles3D_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_JumpTiles3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_JumpTiles3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::JumpTiles3D>(cls);

    __jsb_cocos2d_JumpTiles3D_proto = cls->getProto();
    __jsb_cocos2d_JumpTiles3D_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.JumpTiles3D.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_SplitRows_proto = nullptr;
se::Class* __jsb_cocos2d_SplitRows_class = nullptr;

static bool js_cocos2dx_SplitRows_initWithDuration(se::State& s)
{
    cocos2d::SplitRows* cobj = (cocos2d::SplitRows*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SplitRows_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        unsigned int arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SplitRows_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SplitRows_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SplitRows_initWithDuration)

static bool js_cocos2dx_SplitRows_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        unsigned int arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SplitRows_create : Error processing arguments");
        auto result = cocos2d::SplitRows::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SplitRows_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SplitRows_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_SplitRows_finalize)

static bool js_cocos2dx_SplitRows_constructor(se::State& s)
{
    cocos2d::SplitRows* cobj = new (std::nothrow) cocos2d::SplitRows();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_SplitRows_constructor, __jsb_cocos2d_SplitRows_class, js_cocos2d_SplitRows_finalize)



extern se::Object* __jsb_cocos2d_TiledGrid3DAction_proto;

bool js_cocos2d_SplitRows_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::SplitRows)", s.nativeThisObject());
        cocos2d::SplitRows* cobj = (cocos2d::SplitRows*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_SplitRows_finalize)

bool js_register_cocos2dx_SplitRows(se::Object* obj)
{
    auto cls = se::Class::create("SplitRows", obj, __jsb_cocos2d_TiledGrid3DAction_proto, _SE(js_cocos2dx_SplitRows_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_SplitRows_initWithDuration));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_SplitRows_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_SplitRows_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::SplitRows>(cls);

    __jsb_cocos2d_SplitRows_proto = cls->getProto();
    __jsb_cocos2d_SplitRows_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_SplitCols_proto = nullptr;
se::Class* __jsb_cocos2d_SplitCols_class = nullptr;

static bool js_cocos2dx_SplitCols_initWithDuration(se::State& s)
{
    cocos2d::SplitCols* cobj = (cocos2d::SplitCols*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SplitCols_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        unsigned int arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SplitCols_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SplitCols_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SplitCols_initWithDuration)

static bool js_cocos2dx_SplitCols_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        unsigned int arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SplitCols_create : Error processing arguments");
        auto result = cocos2d::SplitCols::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SplitCols_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SplitCols_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_SplitCols_finalize)

static bool js_cocos2dx_SplitCols_constructor(se::State& s)
{
    cocos2d::SplitCols* cobj = new (std::nothrow) cocos2d::SplitCols();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_SplitCols_constructor, __jsb_cocos2d_SplitCols_class, js_cocos2d_SplitCols_finalize)



extern se::Object* __jsb_cocos2d_TiledGrid3DAction_proto;

bool js_cocos2d_SplitCols_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::SplitCols)", s.nativeThisObject());
        cocos2d::SplitCols* cobj = (cocos2d::SplitCols*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_SplitCols_finalize)

bool js_register_cocos2dx_SplitCols(se::Object* obj)
{
    auto cls = se::Class::create("SplitCols", obj, __jsb_cocos2d_TiledGrid3DAction_proto, _SE(js_cocos2dx_SplitCols_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_SplitCols_initWithDuration));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_SplitCols_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_SplitCols_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::SplitCols>(cls);

    __jsb_cocos2d_SplitCols_proto = cls->getProto();
    __jsb_cocos2d_SplitCols_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ActionTween_proto = nullptr;
se::Class* __jsb_cocos2d_ActionTween_class = nullptr;

static bool js_cocos2dx_ActionTween_initWithDuration(se::State& s)
{
    cocos2d::ActionTween* cobj = (cocos2d::ActionTween*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ActionTween_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        std::string arg1;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionTween_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionTween_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionTween_initWithDuration)

static bool js_cocos2dx_ActionTween_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        std::string arg1;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ActionTween_create : Error processing arguments");
        auto result = cocos2d::ActionTween::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ActionTween_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionTween_create)


extern se::Object* __jsb_cocos2d_ActionInterval_proto;


bool js_register_cocos2dx_ActionTween(se::Object* obj)
{
    auto cls = se::Class::create("ActionTween", obj, __jsb_cocos2d_ActionInterval_proto, nullptr);

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_ActionTween_initWithDuration));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ActionTween_create));
    cls->install();
    JSBClassType::registerClass<cocos2d::ActionTween>(cls);

    __jsb_cocos2d_ActionTween_proto = cls->getProto();
    __jsb_cocos2d_ActionTween_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ActionTween.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_AtlasNode_proto = nullptr;
se::Class* __jsb_cocos2d_AtlasNode_class = nullptr;

static bool js_cocos2dx_AtlasNode_updateAtlasValues(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_updateAtlasValues : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateAtlasValues();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_updateAtlasValues)

static bool js_cocos2dx_AtlasNode_initWithTileFile(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_initWithTileFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        std::string arg0;
        int arg1 = 0;
        int arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_initWithTileFile : Error processing arguments");
        bool result = cobj->initWithTileFile(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_initWithTileFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_initWithTileFile)

static bool js_cocos2dx_AtlasNode_getTexture(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_getTexture)

static bool js_cocos2dx_AtlasNode_setTextureAtlas(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_setTextureAtlas : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextureAtlas* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_setTextureAtlas : Error processing arguments");
        cobj->setTextureAtlas(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_setTextureAtlas)

static bool js_cocos2dx_AtlasNode_setBlendFunc(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_setBlendFunc)

static bool js_cocos2dx_AtlasNode_getBlendFunc(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_getBlendFunc)

static bool js_cocos2dx_AtlasNode_getQuadsToDraw(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_getQuadsToDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getQuadsToDraw();
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_getQuadsToDraw : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_getQuadsToDraw)

static bool js_cocos2dx_AtlasNode_setTexture(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_setTexture)

static bool js_cocos2dx_AtlasNode_initWithTexture(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_initWithTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        cocos2d::Texture2D* arg0 = nullptr;
        int arg1 = 0;
        int arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_initWithTexture : Error processing arguments");
        bool result = cobj->initWithTexture(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_initWithTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_initWithTexture)

static bool js_cocos2dx_AtlasNode_setQuadsToDraw(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_setQuadsToDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        ssize_t arg0 = 0;
        ok &= seval_to_ssize(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_setQuadsToDraw : Error processing arguments");
        cobj->setQuadsToDraw(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_setQuadsToDraw)

static bool js_cocos2dx_AtlasNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        std::string arg0;
        int arg1 = 0;
        int arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_create : Error processing arguments");
        auto result = cocos2d::AtlasNode::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_AtlasNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_AtlasNode_finalize)

static bool js_cocos2dx_AtlasNode_constructor(se::State& s)
{
    cocos2d::AtlasNode* cobj = new (std::nothrow) cocos2d::AtlasNode();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_AtlasNode_constructor, __jsb_cocos2d_AtlasNode_class, js_cocos2d_AtlasNode_finalize)



extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_AtlasNode_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::AtlasNode)", s.nativeThisObject());
        cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_AtlasNode_finalize)

bool js_register_cocos2dx_AtlasNode(se::Object* obj)
{
    auto cls = se::Class::create("AtlasNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_AtlasNode_constructor));

    cls->defineFunction("updateAtlasValues", _SE(js_cocos2dx_AtlasNode_updateAtlasValues));
    cls->defineFunction("initWithTileFile", _SE(js_cocos2dx_AtlasNode_initWithTileFile));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_AtlasNode_getTexture));
    cls->defineFunction("setTextureAtlas", _SE(js_cocos2dx_AtlasNode_setTextureAtlas));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_AtlasNode_setBlendFunc));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_AtlasNode_getBlendFunc));
    cls->defineFunction("getQuadsToDraw", _SE(js_cocos2dx_AtlasNode_getQuadsToDraw));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_AtlasNode_setTexture));
    cls->defineFunction("initWithTexture", _SE(js_cocos2dx_AtlasNode_initWithTexture));
    cls->defineFunction("setQuadsToDraw", _SE(js_cocos2dx_AtlasNode_setQuadsToDraw));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_AtlasNode_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_AtlasNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::AtlasNode>(cls);

    __jsb_cocos2d_AtlasNode_proto = cls->getProto();
    __jsb_cocos2d_AtlasNode_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ClippingNode_proto = nullptr;
se::Class* __jsb_cocos2d_ClippingNode_class = nullptr;

static bool js_cocos2dx_ClippingNode_hasContent(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_hasContent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasContent();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_hasContent : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_hasContent)

static bool js_cocos2dx_ClippingNode_setInverted(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_setInverted : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_setInverted : Error processing arguments");
        cobj->setInverted(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_setInverted)

static bool js_cocos2dx_ClippingNode_setStencil(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_setStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_setStencil : Error processing arguments");
        cobj->setStencil(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_setStencil)

static bool js_cocos2dx_ClippingNode_getAlphaThreshold(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_getAlphaThreshold : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAlphaThreshold();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_getAlphaThreshold : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_getAlphaThreshold)

static bool js_cocos2dx_ClippingNode_getStencil(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_getStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getStencil();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_getStencil : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_getStencil)

static bool js_cocos2dx_ClippingNode_setAlphaThreshold(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_setAlphaThreshold : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_setAlphaThreshold : Error processing arguments");
        cobj->setAlphaThreshold(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_setAlphaThreshold)

static bool js_cocos2dx_ClippingNode_isInverted(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_isInverted : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isInverted();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_isInverted : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_isInverted)

static bool js_cocos2dx_ClippingNode_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::ClippingNode* result = cocos2d::ClippingNode::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::ClippingNode>((cocos2d::ClippingNode*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 0) {
            cocos2d::ClippingNode* result = cocos2d::ClippingNode::create();
            ok &= native_ptr_to_seval<cocos2d::ClippingNode>((cocos2d::ClippingNode*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ClippingNode_finalize)

static bool js_cocos2dx_ClippingNode_constructor(se::State& s)
{
    cocos2d::ClippingNode* cobj = new (std::nothrow) cocos2d::ClippingNode();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ClippingNode_constructor, __jsb_cocos2d_ClippingNode_class, js_cocos2d_ClippingNode_finalize)



extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_ClippingNode_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ClippingNode)", s.nativeThisObject());
        cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ClippingNode_finalize)

bool js_register_cocos2dx_ClippingNode(se::Object* obj)
{
    auto cls = se::Class::create("ClippingNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_ClippingNode_constructor));

    cls->defineFunction("hasContent", _SE(js_cocos2dx_ClippingNode_hasContent));
    cls->defineFunction("setInverted", _SE(js_cocos2dx_ClippingNode_setInverted));
    cls->defineFunction("setStencil", _SE(js_cocos2dx_ClippingNode_setStencil));
    cls->defineFunction("getAlphaThreshold", _SE(js_cocos2dx_ClippingNode_getAlphaThreshold));
    cls->defineFunction("getStencil", _SE(js_cocos2dx_ClippingNode_getStencil));
    cls->defineFunction("setAlphaThreshold", _SE(js_cocos2dx_ClippingNode_setAlphaThreshold));
    cls->defineFunction("isInverted", _SE(js_cocos2dx_ClippingNode_isInverted));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ClippingNode_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ClippingNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ClippingNode>(cls);

    __jsb_cocos2d_ClippingNode_proto = cls->getProto();
    __jsb_cocos2d_ClippingNode_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_DrawNode_proto = nullptr;
se::Class* __jsb_cocos2d_DrawNode_class = nullptr;

static bool js_cocos2dx_DrawNode_drawLine(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawLine : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        cocos2d::Color4F arg2;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawLine : Error processing arguments");
        cobj->drawLine(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawLine)

static bool js_cocos2dx_DrawNode_drawPoints(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_DrawNode_drawPoints : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 4) {
            const cocos2d::Vec2* arg0 = nullptr;
            std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[0], &tempData);arg0=tempData.data();
            if (!ok) { ok = true; break; }
            unsigned int arg1 = 0;
            ok &= seval_to_uint32(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg3;
            ok &= seval_to_Color4F(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cobj->drawPoints(arg0, arg1, arg2, arg3);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            const cocos2d::Vec2* arg0 = nullptr;
            std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[0], &tempData);arg0=tempData.data();
            if (!ok) { ok = true; break; }
            unsigned int arg1 = 0;
            ok &= seval_to_uint32(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg2;
            ok &= seval_to_Color4F(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->drawPoints(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawPoints)

static bool js_cocos2dx_DrawNode_drawRect(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_DrawNode_drawRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg2;
            ok &= seval_to_Vec2(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg3;
            ok &= seval_to_Vec2(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg4;
            ok &= seval_to_Color4F(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cobj->drawRect(arg0, arg1, arg2, arg3, arg4);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg2;
            ok &= seval_to_Color4F(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->drawRect(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawRect)

static bool js_cocos2dx_DrawNode_drawSolidCircle(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_DrawNode_drawSolidCircle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg4;
            ok &= seval_to_Color4F(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cobj->drawSolidCircle(arg0, arg1, arg2, arg3, arg4);
            return true;
        }
    } while(false);

    do {
        if (argc == 7) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            float arg5 = 0;
            ok &= seval_to_float(args[5], &arg5);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg6;
            ok &= seval_to_Color4F(args[6], &arg6);
            if (!ok) { ok = true; break; }
            cobj->drawSolidCircle(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawSolidCircle)

static bool js_cocos2dx_DrawNode_setLineWidth(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_setLineWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_setLineWidth : Error processing arguments");
        cobj->setLineWidth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_setLineWidth)

static bool js_cocos2dx_DrawNode_onDrawGLPoint(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_onDrawGLPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Mat4 arg0;
        unsigned int arg1 = 0;
        ok &= seval_to_Mat4(args[0], &arg0);
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_onDrawGLPoint : Error processing arguments");
        cobj->onDrawGLPoint(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_onDrawGLPoint)

static bool js_cocos2dx_DrawNode_drawPolygon(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawPolygon : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 5) {
        const cocos2d::Vec2* arg0 = nullptr;
        int arg1 = 0;
        cocos2d::Color4F arg2;
        float arg3 = 0;
        cocos2d::Color4F arg4;
        std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[0], &tempData);arg0=tempData.data();
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        ok &= seval_to_Color4F(args[4], &arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawPolygon : Error processing arguments");
        cobj->drawPolygon(arg0, arg1, arg2, arg3, arg4);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawPolygon)

static bool js_cocos2dx_DrawNode_drawDot(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawDot : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vec2 arg0;
        float arg1 = 0;
        cocos2d::Color4F arg2;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawDot : Error processing arguments");
        cobj->drawDot(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawDot)

static bool js_cocos2dx_DrawNode_drawCatmullRom(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawCatmullRom : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::PointArray* arg0 = nullptr;
        unsigned int arg1 = 0;
        cocos2d::Color4F arg2;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_uint32(args[1], &arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawCatmullRom : Error processing arguments");
        cobj->drawCatmullRom(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawCatmullRom)

static bool js_cocos2dx_DrawNode_drawSegment(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawSegment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        float arg2 = 0;
        cocos2d::Color4F arg3;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Color4F(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawSegment : Error processing arguments");
        cobj->drawSegment(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawSegment)

static bool js_cocos2dx_DrawNode_getBlendFunc(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_getBlendFunc)

static bool js_cocos2dx_DrawNode_onDraw(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_onDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Mat4 arg0;
        unsigned int arg1 = 0;
        ok &= seval_to_Mat4(args[0], &arg0);
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_onDraw : Error processing arguments");
        cobj->onDraw(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_onDraw)

static bool js_cocos2dx_DrawNode_drawCircle(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_DrawNode_drawCircle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 6) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool arg4;
            ok &= seval_to_boolean(args[4], &arg4);
            cocos2d::Color4F arg5;
            ok &= seval_to_Color4F(args[5], &arg5);
            if (!ok) { ok = true; break; }
            cobj->drawCircle(arg0, arg1, arg2, arg3, arg4, arg5);
            return true;
        }
    } while(false);

    do {
        if (argc == 8) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool arg4;
            ok &= seval_to_boolean(args[4], &arg4);
            float arg5 = 0;
            ok &= seval_to_float(args[5], &arg5);
            if (!ok) { ok = true; break; }
            float arg6 = 0;
            ok &= seval_to_float(args[6], &arg6);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg7;
            ok &= seval_to_Color4F(args[7], &arg7);
            if (!ok) { ok = true; break; }
            cobj->drawCircle(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawCircle)

static bool js_cocos2dx_DrawNode_drawQuadBezier(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawQuadBezier : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 5) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        cocos2d::Vec2 arg2;
        unsigned int arg3 = 0;
        cocos2d::Color4F arg4;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_uint32(args[3], &arg3);
        ok &= seval_to_Color4F(args[4], &arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawQuadBezier : Error processing arguments");
        cobj->drawQuadBezier(arg0, arg1, arg2, arg3, arg4);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawQuadBezier)

static bool js_cocos2dx_DrawNode_onDrawGLLine(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_onDrawGLLine : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Mat4 arg0;
        unsigned int arg1 = 0;
        ok &= seval_to_Mat4(args[0], &arg0);
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_onDrawGLLine : Error processing arguments");
        cobj->onDrawGLLine(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_onDrawGLLine)

static bool js_cocos2dx_DrawNode_drawSolidPoly(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawSolidPoly : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        const cocos2d::Vec2* arg0 = nullptr;
        unsigned int arg1 = 0;
        cocos2d::Color4F arg2;
        std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[0], &tempData);arg0=tempData.data();
        ok &= seval_to_uint32(args[1], &arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawSolidPoly : Error processing arguments");
        cobj->drawSolidPoly(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawSolidPoly)

static bool js_cocos2dx_DrawNode_drawTriangle(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawTriangle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        cocos2d::Vec2 arg2;
        cocos2d::Color4F arg3;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_Color4F(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawTriangle : Error processing arguments");
        cobj->drawTriangle(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawTriangle)

static bool js_cocos2dx_DrawNode_setBlendFunc(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_setBlendFunc)

static bool js_cocos2dx_DrawNode_clear(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_clear : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->clear();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_clear)

static bool js_cocos2dx_DrawNode_drawCardinalSpline(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawCardinalSpline : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        cocos2d::PointArray* arg0 = nullptr;
        float arg1 = 0;
        unsigned int arg2 = 0;
        cocos2d::Color4F arg3;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_uint32(args[2], &arg2);
        ok &= seval_to_Color4F(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawCardinalSpline : Error processing arguments");
        cobj->drawCardinalSpline(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawCardinalSpline)

static bool js_cocos2dx_DrawNode_drawSolidRect(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawSolidRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        cocos2d::Color4F arg2;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawSolidRect : Error processing arguments");
        cobj->drawSolidRect(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawSolidRect)

static bool js_cocos2dx_DrawNode_getLineWidth(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_getLineWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getLineWidth();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_getLineWidth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_getLineWidth)

static bool js_cocos2dx_DrawNode_drawPoint(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vec2 arg0;
        float arg1 = 0;
        cocos2d::Color4F arg2;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawPoint : Error processing arguments");
        cobj->drawPoint(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawPoint)

static bool js_cocos2dx_DrawNode_drawCubicBezier(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawCubicBezier : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 6) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        cocos2d::Vec2 arg2;
        cocos2d::Vec2 arg3;
        unsigned int arg4 = 0;
        cocos2d::Color4F arg5;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_Vec2(args[3], &arg3);
        ok &= seval_to_uint32(args[4], &arg4);
        ok &= seval_to_Color4F(args[5], &arg5);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawCubicBezier : Error processing arguments");
        cobj->drawCubicBezier(arg0, arg1, arg2, arg3, arg4, arg5);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawCubicBezier)

static bool js_cocos2dx_DrawNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::DrawNode::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_DrawNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_create : Error processing arguments");
        auto result = cocos2d::DrawNode::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_DrawNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_DrawNode_finalize)

static bool js_cocos2dx_DrawNode_constructor(se::State& s)
{
    cocos2d::DrawNode* cobj = new (std::nothrow) cocos2d::DrawNode();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_DrawNode_constructor, __jsb_cocos2d_DrawNode_class, js_cocos2d_DrawNode_finalize)

static bool js_cocos2dx_DrawNode_ctor(se::State& s)
{
    cocos2d::DrawNode* cobj = new (std::nothrow) cocos2d::DrawNode();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_DrawNode_ctor, __jsb_cocos2d_DrawNode_class, js_cocos2d_DrawNode_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_DrawNode_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::DrawNode)", s.nativeThisObject());
        cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_DrawNode_finalize)

bool js_register_cocos2dx_DrawNode(se::Object* obj)
{
    auto cls = se::Class::create("DrawNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_DrawNode_constructor));

    cls->defineFunction("drawLine", _SE(js_cocos2dx_DrawNode_drawLine));
    cls->defineFunction("drawPoints", _SE(js_cocos2dx_DrawNode_drawPoints));
    cls->defineFunction("drawRect", _SE(js_cocos2dx_DrawNode_drawRect));
    cls->defineFunction("drawSolidCircle", _SE(js_cocos2dx_DrawNode_drawSolidCircle));
    cls->defineFunction("setLineWidth", _SE(js_cocos2dx_DrawNode_setLineWidth));
    cls->defineFunction("onDrawGLPoint", _SE(js_cocos2dx_DrawNode_onDrawGLPoint));
    cls->defineFunction("drawPolygon", _SE(js_cocos2dx_DrawNode_drawPolygon));
    cls->defineFunction("drawDot", _SE(js_cocos2dx_DrawNode_drawDot));
    cls->defineFunction("drawCatmullRom", _SE(js_cocos2dx_DrawNode_drawCatmullRom));
    cls->defineFunction("drawSegment", _SE(js_cocos2dx_DrawNode_drawSegment));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_DrawNode_getBlendFunc));
    cls->defineFunction("onDraw", _SE(js_cocos2dx_DrawNode_onDraw));
    cls->defineFunction("drawCircle", _SE(js_cocos2dx_DrawNode_drawCircle));
    cls->defineFunction("drawQuadBezier", _SE(js_cocos2dx_DrawNode_drawQuadBezier));
    cls->defineFunction("onDrawGLLine", _SE(js_cocos2dx_DrawNode_onDrawGLLine));
    cls->defineFunction("drawSolidPoly", _SE(js_cocos2dx_DrawNode_drawSolidPoly));
    cls->defineFunction("drawTriangle", _SE(js_cocos2dx_DrawNode_drawTriangle));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_DrawNode_setBlendFunc));
    cls->defineFunction("clear", _SE(js_cocos2dx_DrawNode_clear));
    cls->defineFunction("drawCardinalSpline", _SE(js_cocos2dx_DrawNode_drawCardinalSpline));
    cls->defineFunction("drawSolidRect", _SE(js_cocos2dx_DrawNode_drawSolidRect));
    cls->defineFunction("getLineWidth", _SE(js_cocos2dx_DrawNode_getLineWidth));
    cls->defineFunction("drawPoint", _SE(js_cocos2dx_DrawNode_drawPoint));
    cls->defineFunction("drawCubicBezier", _SE(js_cocos2dx_DrawNode_drawCubicBezier));
    cls->defineFunction("ctor", _SE(js_cocos2dx_DrawNode_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_DrawNode_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_DrawNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::DrawNode>(cls);

    __jsb_cocos2d_DrawNode_proto = cls->getProto();
    __jsb_cocos2d_DrawNode_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.DrawNode.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Label_proto = nullptr;
se::Class* __jsb_cocos2d_Label_class = nullptr;

static bool js_cocos2dx_Label_isClipMarginEnabled(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_isClipMarginEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isClipMarginEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_isClipMarginEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_isClipMarginEnabled)

static bool js_cocos2dx_Label_enableShadow(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableShadow : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cobj->enableShadow();
        return true;
    }
    if (argc == 1) {
        cocos2d::Color4B arg0;
        ok &= seval_to_Color4B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableShadow : Error processing arguments");
        cobj->enableShadow(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Color4B arg0;
        cocos2d::Size arg1;
        ok &= seval_to_Color4B(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableShadow : Error processing arguments");
        cobj->enableShadow(arg0, arg1);
        return true;
    }
    if (argc == 3) {
        cocos2d::Color4B arg0;
        cocos2d::Size arg1;
        int arg2 = 0;
        ok &= seval_to_Color4B(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableShadow : Error processing arguments");
        cobj->enableShadow(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableShadow)

static bool js_cocos2dx_Label_setDimensions(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setDimensions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setDimensions : Error processing arguments");
        cobj->setDimensions(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setDimensions)

static bool js_cocos2dx_Label_getWidth(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getWidth();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getWidth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getWidth)

static bool js_cocos2dx_Label_getString(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getString();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getString)

static bool js_cocos2dx_Label_getHeight(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getHeight();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getHeight : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getHeight)

static bool js_cocos2dx_Label_disableEffect(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Label_disableEffect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::LabelEffect arg0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            cobj->disableEffect(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cobj->disableEffect();
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_disableEffect)

static bool js_cocos2dx_Label_getTextColor(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getTextColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4B& result = cobj->getTextColor();
        ok &= Color4B_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getTextColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getTextColor)

static bool js_cocos2dx_Label_getBlendFunc(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getBlendFunc)

static bool js_cocos2dx_Label_enableWrap(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableWrap : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableWrap : Error processing arguments");
        cobj->enableWrap(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableWrap)

static bool js_cocos2dx_Label_setWidth(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setWidth : Error processing arguments");
        cobj->setWidth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setWidth)

static bool js_cocos2dx_Label_getAdditionalKerning(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getAdditionalKerning : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAdditionalKerning();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getAdditionalKerning : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getAdditionalKerning)

static bool js_cocos2dx_Label_getBMFontSize(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getBMFontSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getBMFontSize();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getBMFontSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getBMFontSize)

static bool js_cocos2dx_Label_getMaxLineWidth(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getMaxLineWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getMaxLineWidth();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getMaxLineWidth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getMaxLineWidth)

static bool js_cocos2dx_Label_getHorizontalAlignment(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getHorizontalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getHorizontalAlignment();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getHorizontalAlignment : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getHorizontalAlignment)

static bool js_cocos2dx_Label_getShadowOffset(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getShadowOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Size result = cobj->getShadowOffset();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getShadowOffset : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getShadowOffset)

static bool js_cocos2dx_Label_getLineSpacing(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getLineSpacing : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getLineSpacing();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getLineSpacing : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getLineSpacing)

static bool js_cocos2dx_Label_setClipMarginEnabled(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setClipMarginEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setClipMarginEnabled : Error processing arguments");
        cobj->setClipMarginEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setClipMarginEnabled)

static bool js_cocos2dx_Label_setString(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setString : Error processing arguments");
        cobj->setString(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setString)

static bool js_cocos2dx_Label_setSystemFontName(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setSystemFontName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setSystemFontName : Error processing arguments");
        cobj->setSystemFontName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setSystemFontName)

static bool js_cocos2dx_Label_isWrapEnabled(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_isWrapEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isWrapEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_isWrapEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_isWrapEnabled)

static bool js_cocos2dx_Label_getOutlineSize(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getOutlineSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getOutlineSize();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getOutlineSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getOutlineSize)

static bool js_cocos2dx_Label_setBMFontFilePath(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setBMFontFilePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        bool result = cobj->setBMFontFilePath(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        cocos2d::Vec2 arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        bool result = cobj->setBMFontFilePath(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        return true;
    }
    if (argc == 3) {
        std::string arg0;
        cocos2d::Vec2 arg1;
        float arg2 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        bool result = cobj->setBMFontFilePath(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setBMFontFilePath)

static bool js_cocos2dx_Label_initWithTTF(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Label_initWithTTF : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::_ttfConfig arg0;
            #pragma warning NO CONVERSION TO NATIVE FOR _ttfConfig
			ok = false;
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::_ttfConfig arg0;
            #pragma warning NO CONVERSION TO NATIVE FOR _ttfConfig
			ok = false;
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            cocos2d::_ttfConfig arg0;
            #pragma warning NO CONVERSION TO NATIVE FOR _ttfConfig
			ok = false;
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t *)&arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int32(args[4], (int32_t *)&arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 6) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int32(args[4], (int32_t *)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg5;
            ok &= seval_to_int32(args[5], (int32_t *)&arg5);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2, arg3, arg4, arg5);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_initWithTTF)

static bool js_cocos2dx_Label_setLineHeight(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setLineHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setLineHeight : Error processing arguments");
        cobj->setLineHeight(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setLineHeight)

static bool js_cocos2dx_Label_setSystemFontSize(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setSystemFontSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setSystemFontSize : Error processing arguments");
        cobj->setSystemFontSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setSystemFontSize)

static bool js_cocos2dx_Label_setOverflow(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setOverflow : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Label::Overflow arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setOverflow : Error processing arguments");
        cobj->setOverflow(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setOverflow)

static bool js_cocos2dx_Label_enableStrikethrough(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableStrikethrough : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->enableStrikethrough();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableStrikethrough)

static bool js_cocos2dx_Label_updateContent(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_updateContent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateContent();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_updateContent)

static bool js_cocos2dx_Label_getStringLength(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getStringLength : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getStringLength();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getStringLength : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getStringLength)

static bool js_cocos2dx_Label_setLineBreakWithoutSpace(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setLineBreakWithoutSpace : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setLineBreakWithoutSpace : Error processing arguments");
        cobj->setLineBreakWithoutSpace(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setLineBreakWithoutSpace)

static bool js_cocos2dx_Label_getStringNumLines(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getStringNumLines : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getStringNumLines();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getStringNumLines : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getStringNumLines)

static bool js_cocos2dx_Label_enableOutline(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableOutline : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4B arg0;
        ok &= seval_to_Color4B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableOutline : Error processing arguments");
        cobj->enableOutline(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Color4B arg0;
        int arg1 = 0;
        ok &= seval_to_Color4B(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableOutline : Error processing arguments");
        cobj->enableOutline(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableOutline)

static bool js_cocos2dx_Label_getShadowBlurRadius(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getShadowBlurRadius : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getShadowBlurRadius();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getShadowBlurRadius : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getShadowBlurRadius)

static bool js_cocos2dx_Label_getEffectColor(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getEffectColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Color4F result = cobj->getEffectColor();
        ok &= Color4F_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getEffectColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getEffectColor)

static bool js_cocos2dx_Label_removeAllChildrenWithCleanup(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_removeAllChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_removeAllChildrenWithCleanup : Error processing arguments");
        cobj->removeAllChildrenWithCleanup(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_removeAllChildrenWithCleanup)

static bool js_cocos2dx_Label_setCharMap(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Label_setCharMap : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 4) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t *)&arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->setCharMap(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setCharMap : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t *)&arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->setCharMap(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setCharMap : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->setCharMap(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setCharMap : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setCharMap)

static bool js_cocos2dx_Label_getDimensions(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getDimensions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getDimensions();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getDimensions : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getDimensions)

static bool js_cocos2dx_Label_setMaxLineWidth(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setMaxLineWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setMaxLineWidth : Error processing arguments");
        cobj->setMaxLineWidth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setMaxLineWidth)

static bool js_cocos2dx_Label_getSystemFontName(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getSystemFontName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getSystemFontName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getSystemFontName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getSystemFontName)

static bool js_cocos2dx_Label_setVerticalAlignment(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setVerticalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextVAlignment arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setVerticalAlignment : Error processing arguments");
        cobj->setVerticalAlignment(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setVerticalAlignment)

static bool js_cocos2dx_Label_setLineSpacing(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setLineSpacing : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setLineSpacing : Error processing arguments");
        cobj->setLineSpacing(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setLineSpacing)

static bool js_cocos2dx_Label_getLineHeight(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getLineHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getLineHeight();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getLineHeight : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getLineHeight)

static bool js_cocos2dx_Label_getShadowColor(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getShadowColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Color4F result = cobj->getShadowColor();
        ok &= Color4F_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getShadowColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getShadowColor)

static bool js_cocos2dx_Label_getTTFConfig(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getTTFConfig : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::_ttfConfig& result = cobj->getTTFConfig();
        #pragma warning NO CONVERSION FROM NATIVE FOR _ttfConfig;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getTTFConfig : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getTTFConfig)

static bool js_cocos2dx_Label_enableItalics(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableItalics : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->enableItalics();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableItalics)

static bool js_cocos2dx_Label_setTextColor(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setTextColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4B arg0;
        ok &= seval_to_Color4B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setTextColor : Error processing arguments");
        cobj->setTextColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setTextColor)

static bool js_cocos2dx_Label_getLetter(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getLetter : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getLetter : Error processing arguments");
        cocos2d::Sprite* result = cobj->getLetter(arg0);
        ok &= native_ptr_to_seval<cocos2d::Sprite>((cocos2d::Sprite*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getLetter : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getLetter)

static bool js_cocos2dx_Label_setHeight(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setHeight : Error processing arguments");
        cobj->setHeight(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setHeight)

static bool js_cocos2dx_Label_isShadowEnabled(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_isShadowEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isShadowEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_isShadowEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_isShadowEnabled)

static bool js_cocos2dx_Label_enableGlow(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableGlow : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4B arg0;
        ok &= seval_to_Color4B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableGlow : Error processing arguments");
        cobj->enableGlow(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableGlow)

static bool js_cocos2dx_Label_getOverflow(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getOverflow : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getOverflow();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getOverflow : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getOverflow)

static bool js_cocos2dx_Label_getVerticalAlignment(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getVerticalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getVerticalAlignment();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getVerticalAlignment : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getVerticalAlignment)

static bool js_cocos2dx_Label_setAdditionalKerning(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setAdditionalKerning : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setAdditionalKerning : Error processing arguments");
        cobj->setAdditionalKerning(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setAdditionalKerning)

static bool js_cocos2dx_Label_getSystemFontSize(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getSystemFontSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSystemFontSize();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getSystemFontSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getSystemFontSize)

static bool js_cocos2dx_Label_setBlendFunc(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setBlendFunc)

static bool js_cocos2dx_Label_getTextAlignment(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getTextAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getTextAlignment();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getTextAlignment : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getTextAlignment)

static bool js_cocos2dx_Label_getBMFontFilePath(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getBMFontFilePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getBMFontFilePath();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getBMFontFilePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getBMFontFilePath)

static bool js_cocos2dx_Label_setHorizontalAlignment(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setHorizontalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextHAlignment arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setHorizontalAlignment : Error processing arguments");
        cobj->setHorizontalAlignment(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setHorizontalAlignment)

static bool js_cocos2dx_Label_enableBold(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableBold : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->enableBold();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableBold)

static bool js_cocos2dx_Label_enableUnderline(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableUnderline : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->enableUnderline();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableUnderline)

static bool js_cocos2dx_Label_getLabelEffectType(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getLabelEffectType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getLabelEffectType();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_getLabelEffectType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getLabelEffectType)

static bool js_cocos2dx_Label_setAlignment(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Label_setAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::TextHAlignment arg0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg1;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            cobj->setAlignment(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::TextHAlignment arg0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            cobj->setAlignment(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setAlignment)

static bool js_cocos2dx_Label_requestSystemFontRefresh(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_requestSystemFontRefresh : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->requestSystemFontRefresh();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_requestSystemFontRefresh)

static bool js_cocos2dx_Label_setBMFontSize(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setBMFontSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontSize : Error processing arguments");
        cobj->setBMFontSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setBMFontSize)

static bool js_cocos2dx_Label_createWithBMFont(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithBMFont : Error processing arguments");
        auto result = cocos2d::Label::createWithBMFont(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 3) {
        std::string arg0;
        std::string arg1;
        cocos2d::TextHAlignment arg2;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithBMFont : Error processing arguments");
        auto result = cocos2d::Label::createWithBMFont(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        cocos2d::TextHAlignment arg2;
        int arg3 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithBMFont : Error processing arguments");
        auto result = cocos2d::Label::createWithBMFont(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 5) {
        std::string arg0;
        std::string arg1;
        cocos2d::TextHAlignment arg2;
        int arg3 = 0;
        cocos2d::Vec2 arg4;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        ok &= seval_to_Vec2(args[4], &arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithBMFont : Error processing arguments");
        auto result = cocos2d::Label::createWithBMFont(arg0, arg1, arg2, arg3, arg4);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_createWithBMFont)

static bool js_cocos2dx_Label_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Label::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_create)

static bool js_cocos2dx_Label_createWithCharMap(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 4) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t *)&arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithCharMap(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithCharMap : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t *)&arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithCharMap(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithCharMap : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithCharMap(arg0);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithCharMap : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_createWithCharMap)

static bool js_cocos2dx_Label_createWithSystemFont(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithSystemFont : Error processing arguments");
        auto result = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        cocos2d::Size arg3;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Size(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithSystemFont : Error processing arguments");
        auto result = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 5) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        cocos2d::Size arg3;
        cocos2d::TextHAlignment arg4;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Size(args[3], &arg3);
        ok &= seval_to_int32(args[4], (int32_t *)&arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithSystemFont : Error processing arguments");
        auto result = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, arg3, arg4);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 6) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        cocos2d::Size arg3;
        cocos2d::TextHAlignment arg4;
        cocos2d::TextVAlignment arg5;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Size(args[3], &arg3);
        ok &= seval_to_int32(args[4], (int32_t *)&arg4);
        ok &= seval_to_int32(args[5], (int32_t *)&arg5);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithSystemFont : Error processing arguments");
        auto result = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, arg3, arg4, arg5);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_createWithSystemFont)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Label_finalize)

static bool js_cocos2dx_Label_constructor(se::State& s)
{
    cocos2d::Label* cobj = new (std::nothrow) cocos2d::Label();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Label_constructor, __jsb_cocos2d_Label_class, js_cocos2d_Label_finalize)

static bool js_cocos2dx_Label_ctor(se::State& s)
{
    cocos2d::Label* cobj = new (std::nothrow) cocos2d::Label();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Label_ctor, __jsb_cocos2d_Label_class, js_cocos2d_Label_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_Label_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Label)", s.nativeThisObject());
        cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Label_finalize)

bool js_register_cocos2dx_Label(se::Object* obj)
{
    auto cls = se::Class::create("Label", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_Label_constructor));

    cls->defineFunction("isClipMarginEnabled", _SE(js_cocos2dx_Label_isClipMarginEnabled));
    cls->defineFunction("enableShadow", _SE(js_cocos2dx_Label_enableShadow));
    cls->defineFunction("setDimensions", _SE(js_cocos2dx_Label_setDimensions));
    cls->defineFunction("getWidth", _SE(js_cocos2dx_Label_getWidth));
    cls->defineFunction("getString", _SE(js_cocos2dx_Label_getString));
    cls->defineFunction("getHeight", _SE(js_cocos2dx_Label_getHeight));
    cls->defineFunction("disableEffect", _SE(js_cocos2dx_Label_disableEffect));
    cls->defineFunction("getTextColor", _SE(js_cocos2dx_Label_getTextColor));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_Label_getBlendFunc));
    cls->defineFunction("enableWrap", _SE(js_cocos2dx_Label_enableWrap));
    cls->defineFunction("setWidth", _SE(js_cocos2dx_Label_setWidth));
    cls->defineFunction("getAdditionalKerning", _SE(js_cocos2dx_Label_getAdditionalKerning));
    cls->defineFunction("getBMFontSize", _SE(js_cocos2dx_Label_getBMFontSize));
    cls->defineFunction("getMaxLineWidth", _SE(js_cocos2dx_Label_getMaxLineWidth));
    cls->defineFunction("getHorizontalAlignment", _SE(js_cocos2dx_Label_getHorizontalAlignment));
    cls->defineFunction("getShadowOffset", _SE(js_cocos2dx_Label_getShadowOffset));
    cls->defineFunction("getLineSpacing", _SE(js_cocos2dx_Label_getLineSpacing));
    cls->defineFunction("setClipMarginEnabled", _SE(js_cocos2dx_Label_setClipMarginEnabled));
    cls->defineFunction("setString", _SE(js_cocos2dx_Label_setString));
    cls->defineFunction("setSystemFontName", _SE(js_cocos2dx_Label_setSystemFontName));
    cls->defineFunction("isWrapEnabled", _SE(js_cocos2dx_Label_isWrapEnabled));
    cls->defineFunction("getOutlineSize", _SE(js_cocos2dx_Label_getOutlineSize));
    cls->defineFunction("setBMFontFilePath", _SE(js_cocos2dx_Label_setBMFontFilePath));
    cls->defineFunction("initWithTTF", _SE(js_cocos2dx_Label_initWithTTF));
    cls->defineFunction("setLineHeight", _SE(js_cocos2dx_Label_setLineHeight));
    cls->defineFunction("setSystemFontSize", _SE(js_cocos2dx_Label_setSystemFontSize));
    cls->defineFunction("setOverflow", _SE(js_cocos2dx_Label_setOverflow));
    cls->defineFunction("enableStrikethrough", _SE(js_cocos2dx_Label_enableStrikethrough));
    cls->defineFunction("updateContent", _SE(js_cocos2dx_Label_updateContent));
    cls->defineFunction("getStringLength", _SE(js_cocos2dx_Label_getStringLength));
    cls->defineFunction("setLineBreakWithoutSpace", _SE(js_cocos2dx_Label_setLineBreakWithoutSpace));
    cls->defineFunction("getStringNumLines", _SE(js_cocos2dx_Label_getStringNumLines));
    cls->defineFunction("enableOutline", _SE(js_cocos2dx_Label_enableOutline));
    cls->defineFunction("getShadowBlurRadius", _SE(js_cocos2dx_Label_getShadowBlurRadius));
    cls->defineFunction("getEffectColor", _SE(js_cocos2dx_Label_getEffectColor));
    cls->defineFunction("removeAllChildrenWithCleanup", _SE(js_cocos2dx_Label_removeAllChildrenWithCleanup));
    cls->defineFunction("setCharMap", _SE(js_cocos2dx_Label_setCharMap));
    cls->defineFunction("getDimensions", _SE(js_cocos2dx_Label_getDimensions));
    cls->defineFunction("setMaxLineWidth", _SE(js_cocos2dx_Label_setMaxLineWidth));
    cls->defineFunction("getSystemFontName", _SE(js_cocos2dx_Label_getSystemFontName));
    cls->defineFunction("setVerticalAlignment", _SE(js_cocos2dx_Label_setVerticalAlignment));
    cls->defineFunction("setLineSpacing", _SE(js_cocos2dx_Label_setLineSpacing));
    cls->defineFunction("getLineHeight", _SE(js_cocos2dx_Label_getLineHeight));
    cls->defineFunction("getShadowColor", _SE(js_cocos2dx_Label_getShadowColor));
    cls->defineFunction("getTTFConfig", _SE(js_cocos2dx_Label_getTTFConfig));
    cls->defineFunction("enableItalics", _SE(js_cocos2dx_Label_enableItalics));
    cls->defineFunction("setTextColor", _SE(js_cocos2dx_Label_setTextColor));
    cls->defineFunction("getLetter", _SE(js_cocos2dx_Label_getLetter));
    cls->defineFunction("setHeight", _SE(js_cocos2dx_Label_setHeight));
    cls->defineFunction("isShadowEnabled", _SE(js_cocos2dx_Label_isShadowEnabled));
    cls->defineFunction("enableGlow", _SE(js_cocos2dx_Label_enableGlow));
    cls->defineFunction("getOverflow", _SE(js_cocos2dx_Label_getOverflow));
    cls->defineFunction("getVerticalAlignment", _SE(js_cocos2dx_Label_getVerticalAlignment));
    cls->defineFunction("setAdditionalKerning", _SE(js_cocos2dx_Label_setAdditionalKerning));
    cls->defineFunction("getSystemFontSize", _SE(js_cocos2dx_Label_getSystemFontSize));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_Label_setBlendFunc));
    cls->defineFunction("getTextAlignment", _SE(js_cocos2dx_Label_getTextAlignment));
    cls->defineFunction("getBMFontFilePath", _SE(js_cocos2dx_Label_getBMFontFilePath));
    cls->defineFunction("setHorizontalAlignment", _SE(js_cocos2dx_Label_setHorizontalAlignment));
    cls->defineFunction("enableBold", _SE(js_cocos2dx_Label_enableBold));
    cls->defineFunction("enableUnderline", _SE(js_cocos2dx_Label_enableUnderline));
    cls->defineFunction("getLabelEffectType", _SE(js_cocos2dx_Label_getLabelEffectType));
    cls->defineFunction("setAlignment", _SE(js_cocos2dx_Label_setAlignment));
    cls->defineFunction("requestSystemFontRefresh", _SE(js_cocos2dx_Label_requestSystemFontRefresh));
    cls->defineFunction("setBMFontSize", _SE(js_cocos2dx_Label_setBMFontSize));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Label_ctor));
    cls->defineStaticFunction("createWithBMFont", _SE(js_cocos2dx_Label_createWithBMFont));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Label_create));
    cls->defineStaticFunction("createWithCharMap", _SE(js_cocos2dx_Label_createWithCharMap));
    cls->defineStaticFunction("createWithSystemFont", _SE(js_cocos2dx_Label_createWithSystemFont));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Label_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Label>(cls);

    __jsb_cocos2d_Label_proto = cls->getProto();
    __jsb_cocos2d_Label_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Label.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_LabelAtlas_proto = nullptr;
se::Class* __jsb_cocos2d_LabelAtlas_class = nullptr;

static bool js_cocos2dx_LabelAtlas_setString(se::State& s)
{
    cocos2d::LabelAtlas* cobj = (cocos2d::LabelAtlas*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelAtlas_setString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelAtlas_setString : Error processing arguments");
        cobj->setString(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelAtlas_setString)

static bool js_cocos2dx_LabelAtlas_initWithString(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::LabelAtlas* cobj = (cocos2d::LabelAtlas*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_LabelAtlas_initWithString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelAtlas_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t *)&arg3);
            if (!ok) { ok = true; break; }
            int arg4 = 0;
            ok &= seval_to_int32(args[4], (int32_t *)&arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelAtlas_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t *)&arg3);
            if (!ok) { ok = true; break; }
            int arg4 = 0;
            ok &= seval_to_int32(args[4], (int32_t *)&arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelAtlas_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelAtlas_initWithString)

static bool js_cocos2dx_LabelAtlas_getString(se::State& s)
{
    cocos2d::LabelAtlas* cobj = (cocos2d::LabelAtlas*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelAtlas_getString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getString();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelAtlas_getString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelAtlas_getString)

static bool js_cocos2dx_LabelAtlas_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t *)&arg3);
            if (!ok) { ok = true; break; }
            int arg4 = 0;
            ok &= seval_to_int32(args[4], (int32_t *)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::LabelAtlas* result = cocos2d::LabelAtlas::create(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::LabelAtlas>((cocos2d::LabelAtlas*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelAtlas_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 0) {
            cocos2d::LabelAtlas* result = cocos2d::LabelAtlas::create();
            ok &= native_ptr_to_seval<cocos2d::LabelAtlas>((cocos2d::LabelAtlas*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelAtlas_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::LabelAtlas* result = cocos2d::LabelAtlas::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::LabelAtlas>((cocos2d::LabelAtlas*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelAtlas_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelAtlas_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_LabelAtlas_finalize)

static bool js_cocos2dx_LabelAtlas_constructor(se::State& s)
{
    cocos2d::LabelAtlas* cobj = new (std::nothrow) cocos2d::LabelAtlas();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_LabelAtlas_constructor, __jsb_cocos2d_LabelAtlas_class, js_cocos2d_LabelAtlas_finalize)

static bool js_cocos2dx_LabelAtlas_ctor(se::State& s)
{
    cocos2d::LabelAtlas* cobj = new (std::nothrow) cocos2d::LabelAtlas();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_LabelAtlas_ctor, __jsb_cocos2d_LabelAtlas_class, js_cocos2d_LabelAtlas_finalize)


    

extern se::Object* __jsb_cocos2d_AtlasNode_proto;

bool js_cocos2d_LabelAtlas_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::LabelAtlas)", s.nativeThisObject());
        cocos2d::LabelAtlas* cobj = (cocos2d::LabelAtlas*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_LabelAtlas_finalize)

bool js_register_cocos2dx_LabelAtlas(se::Object* obj)
{
    auto cls = se::Class::create("LabelAtlas", obj, __jsb_cocos2d_AtlasNode_proto, _SE(js_cocos2dx_LabelAtlas_constructor));

    cls->defineFunction("setString", _SE(js_cocos2dx_LabelAtlas_setString));
    cls->defineFunction("initWithString", _SE(js_cocos2dx_LabelAtlas_initWithString));
    cls->defineFunction("getString", _SE(js_cocos2dx_LabelAtlas_getString));
    cls->defineFunction("ctor", _SE(js_cocos2dx_LabelAtlas_ctor));
    cls->defineStaticFunction("_create", _SE(js_cocos2dx_LabelAtlas_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_LabelAtlas_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::LabelAtlas>(cls);

    __jsb_cocos2d_LabelAtlas_proto = cls->getProto();
    __jsb_cocos2d_LabelAtlas_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.LabelAtlas.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_LabelBMFont_proto = nullptr;
se::Class* __jsb_cocos2d_LabelBMFont_class = nullptr;

static bool js_cocos2dx_LabelBMFont_setLineBreakWithoutSpace(se::State& s)
{
    cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelBMFont_setLineBreakWithoutSpace : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_setLineBreakWithoutSpace : Error processing arguments");
        cobj->setLineBreakWithoutSpace(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_setLineBreakWithoutSpace)

static bool js_cocos2dx_LabelBMFont_getBlendFunc(se::State& s)
{
    cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelBMFont_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_getBlendFunc)

static bool js_cocos2dx_LabelBMFont_getLetter(se::State& s)
{
    cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelBMFont_getLetter : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_getLetter : Error processing arguments");
        cocos2d::Sprite* result = cobj->getLetter(arg0);
        ok &= native_ptr_to_seval<cocos2d::Sprite>((cocos2d::Sprite*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_getLetter : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_getLetter)

static bool js_cocos2dx_LabelBMFont_getString(se::State& s)
{
    cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelBMFont_getString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getString();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_getString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_getString)

static bool js_cocos2dx_LabelBMFont_setBlendFunc(se::State& s)
{
    cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelBMFont_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_setBlendFunc)

static bool js_cocos2dx_LabelBMFont_setString(se::State& s)
{
    cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelBMFont_setString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_setString : Error processing arguments");
        cobj->setString(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_setString)

static bool js_cocos2dx_LabelBMFont_initWithString(se::State& s)
{
    cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelBMFont_initWithString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_initWithString : Error processing arguments");
        return true;
    }
    if (argc == 3) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_initWithString : Error processing arguments");
        return true;
    }
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        cocos2d::TextHAlignment arg3;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_initWithString : Error processing arguments");
        return true;
    }
    if (argc == 5) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        cocos2d::TextHAlignment arg3;
        cocos2d::Vec2 arg4;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        ok &= seval_to_Vec2(args[4], &arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_initWithString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_initWithString)

static bool js_cocos2dx_LabelBMFont_getFntFile(se::State& s)
{
    cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelBMFont_getFntFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getFntFile();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_getFntFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_getFntFile)

static bool js_cocos2dx_LabelBMFont_setFntFile(se::State& s)
{
    cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelBMFont_setFntFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_setFntFile : Error processing arguments");
        cobj->setFntFile(arg0);
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        cocos2d::Vec2 arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_setFntFile : Error processing arguments");
        cobj->setFntFile(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_setFntFile)

static bool js_cocos2dx_LabelBMFont_setAlignment(se::State& s)
{
    cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelBMFont_setAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextHAlignment arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_setAlignment : Error processing arguments");
        cobj->setAlignment(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_setAlignment)

static bool js_cocos2dx_LabelBMFont_setWidth(se::State& s)
{
    cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelBMFont_setWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_setWidth : Error processing arguments");
        cobj->setWidth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_setWidth)

static bool js_cocos2dx_LabelBMFont_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::LabelBMFont* result = cocos2d::LabelBMFont::create();
            ok &= native_ptr_to_seval<cocos2d::LabelBMFont>((cocos2d::LabelBMFont*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::LabelBMFont* result = cocos2d::LabelBMFont::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::LabelBMFont>((cocos2d::LabelBMFont*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::LabelBMFont* result = cocos2d::LabelBMFont::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::LabelBMFont>((cocos2d::LabelBMFont*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg3;
            ok &= seval_to_int32(args[3], (int32_t *)&arg3);
            if (!ok) { ok = true; break; }
            cocos2d::LabelBMFont* result = cocos2d::LabelBMFont::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::LabelBMFont>((cocos2d::LabelBMFont*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg3;
            ok &= seval_to_int32(args[3], (int32_t *)&arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg4;
            ok &= seval_to_Vec2(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cocos2d::LabelBMFont* result = cocos2d::LabelBMFont::create(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::LabelBMFont>((cocos2d::LabelBMFont*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelBMFont_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelBMFont_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_LabelBMFont_finalize)

static bool js_cocos2dx_LabelBMFont_constructor(se::State& s)
{
    cocos2d::LabelBMFont* cobj = new (std::nothrow) cocos2d::LabelBMFont();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_LabelBMFont_constructor, __jsb_cocos2d_LabelBMFont_class, js_cocos2d_LabelBMFont_finalize)

static bool js_cocos2dx_LabelBMFont_ctor(se::State& s)
{
    cocos2d::LabelBMFont* cobj = new (std::nothrow) cocos2d::LabelBMFont();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_LabelBMFont_ctor, __jsb_cocos2d_LabelBMFont_class, js_cocos2d_LabelBMFont_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_LabelBMFont_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::LabelBMFont)", s.nativeThisObject());
        cocos2d::LabelBMFont* cobj = (cocos2d::LabelBMFont*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_LabelBMFont_finalize)

bool js_register_cocos2dx_LabelBMFont(se::Object* obj)
{
    auto cls = se::Class::create("LabelBMFont", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_LabelBMFont_constructor));

    cls->defineFunction("setLineBreakWithoutSpace", _SE(js_cocos2dx_LabelBMFont_setLineBreakWithoutSpace));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_LabelBMFont_getBlendFunc));
    cls->defineFunction("getLetter", _SE(js_cocos2dx_LabelBMFont_getLetter));
    cls->defineFunction("getString", _SE(js_cocos2dx_LabelBMFont_getString));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_LabelBMFont_setBlendFunc));
    cls->defineFunction("setString", _SE(js_cocos2dx_LabelBMFont_setString));
    cls->defineFunction("initWithString", _SE(js_cocos2dx_LabelBMFont_initWithString));
    cls->defineFunction("getFntFile", _SE(js_cocos2dx_LabelBMFont_getFntFile));
    cls->defineFunction("setFntFile", _SE(js_cocos2dx_LabelBMFont_setFntFile));
    cls->defineFunction("setAlignment", _SE(js_cocos2dx_LabelBMFont_setAlignment));
    cls->defineFunction("setWidth", _SE(js_cocos2dx_LabelBMFont_setWidth));
    cls->defineFunction("ctor", _SE(js_cocos2dx_LabelBMFont_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_LabelBMFont_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_LabelBMFont_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::LabelBMFont>(cls);

    __jsb_cocos2d_LabelBMFont_proto = cls->getProto();
    __jsb_cocos2d_LabelBMFont_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.LabelBMFont.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_LabelTTF_proto = nullptr;
se::Class* __jsb_cocos2d_LabelTTF_class = nullptr;

static bool js_cocos2dx_LabelTTF_enableShadow(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_enableShadow : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Size arg0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_Size(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_enableShadow : Error processing arguments");
        cobj->enableShadow(arg0, arg1, arg2);
        return true;
    }
    if (argc == 4) {
        cocos2d::Size arg0;
        float arg1 = 0;
        float arg2 = 0;
        bool arg3;
        ok &= seval_to_Size(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_boolean(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_enableShadow : Error processing arguments");
        cobj->enableShadow(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_enableShadow)

static bool js_cocos2dx_LabelTTF_setDimensions(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_setDimensions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setDimensions : Error processing arguments");
        cobj->setDimensions(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_setDimensions)

static bool js_cocos2dx_LabelTTF_getFontSize(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_getFontSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getFontSize();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_getFontSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_getFontSize)

static bool js_cocos2dx_LabelTTF_getString(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_getString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getString();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_getString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_getString)

static bool js_cocos2dx_LabelTTF_setFlippedY(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_setFlippedY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setFlippedY : Error processing arguments");
        cobj->setFlippedY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_setFlippedY)

static bool js_cocos2dx_LabelTTF_setFlippedX(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_setFlippedX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setFlippedX : Error processing arguments");
        cobj->setFlippedX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_setFlippedX)

static bool js_cocos2dx_LabelTTF_setTextDefinition(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_setTextDefinition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FontDefinition arg0;
        ok &= seval_to_FontDefinition(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setTextDefinition : Error processing arguments");
        cobj->setTextDefinition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_setTextDefinition)

static bool js_cocos2dx_LabelTTF_setFontName(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_setFontName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setFontName : Error processing arguments");
        cobj->setFontName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_setFontName)

static bool js_cocos2dx_LabelTTF_getHorizontalAlignment(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_getHorizontalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getHorizontalAlignment();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_getHorizontalAlignment : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_getHorizontalAlignment)

static bool js_cocos2dx_LabelTTF_initWithStringAndTextDefinition(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_initWithStringAndTextDefinition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        cocos2d::FontDefinition arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_FontDefinition(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_initWithStringAndTextDefinition : Error processing arguments");
        bool result = cobj->initWithStringAndTextDefinition(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_initWithStringAndTextDefinition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_initWithStringAndTextDefinition)

static bool js_cocos2dx_LabelTTF_setString(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_setString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setString : Error processing arguments");
        cobj->setString(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_setString)

static bool js_cocos2dx_LabelTTF_initWithString(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_initWithString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_initWithString : Error processing arguments");
        return true;
    }
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        cocos2d::Size arg3;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Size(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_initWithString : Error processing arguments");
        return true;
    }
    if (argc == 5) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        cocos2d::Size arg3;
        cocos2d::TextHAlignment arg4;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Size(args[3], &arg3);
        ok &= seval_to_int32(args[4], (int32_t *)&arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_initWithString : Error processing arguments");
        return true;
    }
    if (argc == 6) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        cocos2d::Size arg3;
        cocos2d::TextHAlignment arg4;
        cocos2d::TextVAlignment arg5;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Size(args[3], &arg3);
        ok &= seval_to_int32(args[4], (int32_t *)&arg4);
        ok &= seval_to_int32(args[5], (int32_t *)&arg5);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_initWithString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_initWithString)

static bool js_cocos2dx_LabelTTF_setFontFillColor(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_setFontFillColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setFontFillColor : Error processing arguments");
        cobj->setFontFillColor(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Color3B arg0;
        bool arg1;
        ok &= seval_to_Color3B(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setFontFillColor : Error processing arguments");
        cobj->setFontFillColor(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_setFontFillColor)

static bool js_cocos2dx_LabelTTF_getBlendFunc(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_getBlendFunc)

static bool js_cocos2dx_LabelTTF_enableStroke(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_enableStroke : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Color3B arg0;
        float arg1 = 0;
        ok &= seval_to_Color3B(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_enableStroke : Error processing arguments");
        cobj->enableStroke(arg0, arg1);
        return true;
    }
    if (argc == 3) {
        cocos2d::Color3B arg0;
        float arg1 = 0;
        bool arg2;
        ok &= seval_to_Color3B(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_boolean(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_enableStroke : Error processing arguments");
        cobj->enableStroke(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_enableStroke)

static bool js_cocos2dx_LabelTTF_getDimensions(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_getDimensions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getDimensions();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_getDimensions : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_getDimensions)

static bool js_cocos2dx_LabelTTF_setVerticalAlignment(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_setVerticalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextVAlignment arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setVerticalAlignment : Error processing arguments");
        cobj->setVerticalAlignment(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_setVerticalAlignment)

static bool js_cocos2dx_LabelTTF_setFontSize(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_setFontSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setFontSize : Error processing arguments");
        cobj->setFontSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_setFontSize)

static bool js_cocos2dx_LabelTTF_getVerticalAlignment(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_getVerticalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getVerticalAlignment();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_getVerticalAlignment : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_getVerticalAlignment)

static bool js_cocos2dx_LabelTTF_getTextDefinition(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_getTextDefinition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::FontDefinition& result = cobj->getTextDefinition();
        ok &= FontDefinition_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_getTextDefinition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_getTextDefinition)

static bool js_cocos2dx_LabelTTF_setBlendFunc(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_setBlendFunc)

static bool js_cocos2dx_LabelTTF_getFontName(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_getFontName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getFontName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_getFontName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_getFontName)

static bool js_cocos2dx_LabelTTF_setHorizontalAlignment(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_setHorizontalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextHAlignment arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_setHorizontalAlignment : Error processing arguments");
        cobj->setHorizontalAlignment(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_setHorizontalAlignment)

static bool js_cocos2dx_LabelTTF_disableShadow(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_disableShadow : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cobj->disableShadow();
        return true;
    }
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_disableShadow : Error processing arguments");
        cobj->disableShadow(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_disableShadow)

static bool js_cocos2dx_LabelTTF_disableStroke(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_disableStroke : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cobj->disableStroke();
        return true;
    }
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_disableStroke : Error processing arguments");
        cobj->disableStroke(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_disableStroke)

static bool js_cocos2dx_LabelTTF_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::LabelTTF* result = cocos2d::LabelTTF::create();
            ok &= native_ptr_to_seval<cocos2d::LabelTTF>((cocos2d::LabelTTF*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::LabelTTF* result = cocos2d::LabelTTF::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::LabelTTF>((cocos2d::LabelTTF*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::LabelTTF* result = cocos2d::LabelTTF::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::LabelTTF>((cocos2d::LabelTTF*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int32(args[4], (int32_t *)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::LabelTTF* result = cocos2d::LabelTTF::create(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::LabelTTF>((cocos2d::LabelTTF*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 6) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int32(args[4], (int32_t *)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg5;
            ok &= seval_to_int32(args[5], (int32_t *)&arg5);
            if (!ok) { ok = true; break; }
            cocos2d::LabelTTF* result = cocos2d::LabelTTF::create(arg0, arg1, arg2, arg3, arg4, arg5);
            ok &= native_ptr_to_seval<cocos2d::LabelTTF>((cocos2d::LabelTTF*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_create)

static bool js_cocos2dx_LabelTTF_createWithFontDefinition(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        cocos2d::FontDefinition arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_FontDefinition(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_createWithFontDefinition : Error processing arguments");
        auto result = cocos2d::LabelTTF::createWithFontDefinition(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_LabelTTF_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_createWithFontDefinition)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_LabelTTF_finalize)

static bool js_cocos2dx_LabelTTF_constructor(se::State& s)
{
    cocos2d::LabelTTF* cobj = new (std::nothrow) cocos2d::LabelTTF();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_LabelTTF_constructor, __jsb_cocos2d_LabelTTF_class, js_cocos2d_LabelTTF_finalize)

static bool js_cocos2dx_LabelTTF_ctor(se::State& s)
{
    cocos2d::LabelTTF* cobj = new (std::nothrow) cocos2d::LabelTTF();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_LabelTTF_ctor, __jsb_cocos2d_LabelTTF_class, js_cocos2d_LabelTTF_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_LabelTTF_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::LabelTTF)", s.nativeThisObject());
        cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_LabelTTF_finalize)

bool js_register_cocos2dx_LabelTTF(se::Object* obj)
{
    auto cls = se::Class::create("LabelTTF", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_LabelTTF_constructor));

    cls->defineFunction("enableShadow", _SE(js_cocos2dx_LabelTTF_enableShadow));
    cls->defineFunction("setDimensions", _SE(js_cocos2dx_LabelTTF_setDimensions));
    cls->defineFunction("getFontSize", _SE(js_cocos2dx_LabelTTF_getFontSize));
    cls->defineFunction("getString", _SE(js_cocos2dx_LabelTTF_getString));
    cls->defineFunction("setFlippedY", _SE(js_cocos2dx_LabelTTF_setFlippedY));
    cls->defineFunction("setFlippedX", _SE(js_cocos2dx_LabelTTF_setFlippedX));
    cls->defineFunction("setTextDefinition", _SE(js_cocos2dx_LabelTTF_setTextDefinition));
    cls->defineFunction("setFontName", _SE(js_cocos2dx_LabelTTF_setFontName));
    cls->defineFunction("getHorizontalAlignment", _SE(js_cocos2dx_LabelTTF_getHorizontalAlignment));
    cls->defineFunction("initWithStringAndTextDefinition", _SE(js_cocos2dx_LabelTTF_initWithStringAndTextDefinition));
    cls->defineFunction("setString", _SE(js_cocos2dx_LabelTTF_setString));
    cls->defineFunction("initWithString", _SE(js_cocos2dx_LabelTTF_initWithString));
    cls->defineFunction("setFontFillColor", _SE(js_cocos2dx_LabelTTF_setFontFillColor));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_LabelTTF_getBlendFunc));
    cls->defineFunction("enableStroke", _SE(js_cocos2dx_LabelTTF_enableStroke));
    cls->defineFunction("getDimensions", _SE(js_cocos2dx_LabelTTF_getDimensions));
    cls->defineFunction("setVerticalAlignment", _SE(js_cocos2dx_LabelTTF_setVerticalAlignment));
    cls->defineFunction("setFontSize", _SE(js_cocos2dx_LabelTTF_setFontSize));
    cls->defineFunction("getVerticalAlignment", _SE(js_cocos2dx_LabelTTF_getVerticalAlignment));
    cls->defineFunction("getTextDefinition", _SE(js_cocos2dx_LabelTTF_getTextDefinition));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_LabelTTF_setBlendFunc));
    cls->defineFunction("getFontName", _SE(js_cocos2dx_LabelTTF_getFontName));
    cls->defineFunction("setHorizontalAlignment", _SE(js_cocos2dx_LabelTTF_setHorizontalAlignment));
    cls->defineFunction("disableShadow", _SE(js_cocos2dx_LabelTTF_disableShadow));
    cls->defineFunction("disableStroke", _SE(js_cocos2dx_LabelTTF_disableStroke));
    cls->defineFunction("ctor", _SE(js_cocos2dx_LabelTTF_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_LabelTTF_create));
    cls->defineStaticFunction("createWithFontDefinition", _SE(js_cocos2dx_LabelTTF_createWithFontDefinition));
    cls->defineFinalizedFunction(_SE(js_cocos2d_LabelTTF_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::LabelTTF>(cls);

    __jsb_cocos2d_LabelTTF_proto = cls->getProto();
    __jsb_cocos2d_LabelTTF_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.LabelTTF.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Layer_proto = nullptr;
se::Class* __jsb_cocos2d_Layer_class = nullptr;

static bool js_cocos2dx_Layer_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Layer::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Layer_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Layer_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Layer_finalize)

static bool js_cocos2dx_Layer_constructor(se::State& s)
{
    cocos2d::Layer* cobj = new (std::nothrow) cocos2d::Layer();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Layer_constructor, __jsb_cocos2d_Layer_class, js_cocos2d_Layer_finalize)

static bool js_cocos2dx_Layer_ctor(se::State& s)
{
    cocos2d::Layer* cobj = new (std::nothrow) cocos2d::Layer();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Layer_ctor, __jsb_cocos2d_Layer_class, js_cocos2d_Layer_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_Layer_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Layer)", s.nativeThisObject());
        cocos2d::Layer* cobj = (cocos2d::Layer*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Layer_finalize)

bool js_register_cocos2dx_Layer(se::Object* obj)
{
    auto cls = se::Class::create("Layer", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_Layer_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_Layer_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Layer_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Layer_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Layer>(cls);

    __jsb_cocos2d_Layer_proto = cls->getProto();
    __jsb_cocos2d_Layer_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Layer.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d___LayerRGBA_proto = nullptr;
se::Class* __jsb_cocos2d___LayerRGBA_class = nullptr;

static bool js_cocos2dx___LayerRGBA_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::__LayerRGBA::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d___LayerRGBA_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx___LayerRGBA_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d___LayerRGBA_finalize)

static bool js_cocos2dx___LayerRGBA_constructor(se::State& s)
{
    cocos2d::__LayerRGBA* cobj = new (std::nothrow) cocos2d::__LayerRGBA();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx___LayerRGBA_constructor, __jsb_cocos2d___LayerRGBA_class, js_cocos2d___LayerRGBA_finalize)



extern se::Object* __jsb_cocos2d_Layer_proto;

bool js_cocos2d___LayerRGBA_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::__LayerRGBA)", s.nativeThisObject());
        cocos2d::__LayerRGBA* cobj = (cocos2d::__LayerRGBA*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d___LayerRGBA_finalize)

bool js_register_cocos2dx___LayerRGBA(se::Object* obj)
{
    auto cls = se::Class::create("__LayerRGBA", obj, __jsb_cocos2d_Layer_proto, _SE(js_cocos2dx___LayerRGBA_constructor));

    cls->defineStaticFunction("create", _SE(js_cocos2dx___LayerRGBA_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d___LayerRGBA_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::__LayerRGBA>(cls);

    __jsb_cocos2d___LayerRGBA_proto = cls->getProto();
    __jsb_cocos2d___LayerRGBA_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_LayerColor_proto = nullptr;
se::Class* __jsb_cocos2d_LayerColor_class = nullptr;

static bool js_cocos2dx_LayerColor_changeWidthAndHeight(se::State& s)
{
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerColor_changeWidthAndHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_changeWidthAndHeight : Error processing arguments");
        cobj->changeWidthAndHeight(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_changeWidthAndHeight)

static bool js_cocos2dx_LayerColor_getBlendFunc(se::State& s)
{
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerColor_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_getBlendFunc)

static bool js_cocos2dx_LayerColor_setBlendFunc(se::State& s)
{
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerColor_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_setBlendFunc)

static bool js_cocos2dx_LayerColor_changeWidth(se::State& s)
{
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerColor_changeWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_changeWidth : Error processing arguments");
        cobj->changeWidth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_changeWidth)

static bool js_cocos2dx_LayerColor_initWithColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_LayerColor_initWithColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithColor(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_initWithColor : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithColor(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_initWithColor : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_initWithColor)

static bool js_cocos2dx_LayerColor_changeHeight(se::State& s)
{
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerColor_changeHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_changeHeight : Error processing arguments");
        cobj->changeHeight(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_changeHeight)

static bool js_cocos2dx_LayerColor_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::LayerColor* result = cocos2d::LayerColor::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::LayerColor>((cocos2d::LayerColor*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 0) {
            cocos2d::LayerColor* result = cocos2d::LayerColor::create();
            ok &= native_ptr_to_seval<cocos2d::LayerColor>((cocos2d::LayerColor*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 1) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::LayerColor* result = cocos2d::LayerColor::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::LayerColor>((cocos2d::LayerColor*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_LayerColor_finalize)

static bool js_cocos2dx_LayerColor_constructor(se::State& s)
{
    cocos2d::LayerColor* cobj = new (std::nothrow) cocos2d::LayerColor();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_LayerColor_constructor, __jsb_cocos2d_LayerColor_class, js_cocos2d_LayerColor_finalize)

static bool js_cocos2dx_LayerColor_ctor(se::State& s)
{
    cocos2d::LayerColor* cobj = new (std::nothrow) cocos2d::LayerColor();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_LayerColor_ctor, __jsb_cocos2d_LayerColor_class, js_cocos2d_LayerColor_finalize)


    

extern se::Object* __jsb_cocos2d_Layer_proto;

bool js_cocos2d_LayerColor_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::LayerColor)", s.nativeThisObject());
        cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_LayerColor_finalize)

bool js_register_cocos2dx_LayerColor(se::Object* obj)
{
    auto cls = se::Class::create("LayerColor", obj, __jsb_cocos2d_Layer_proto, _SE(js_cocos2dx_LayerColor_constructor));

    cls->defineFunction("changeWidthAndHeight", _SE(js_cocos2dx_LayerColor_changeWidthAndHeight));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_LayerColor_getBlendFunc));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_LayerColor_setBlendFunc));
    cls->defineFunction("changeWidth", _SE(js_cocos2dx_LayerColor_changeWidth));
    cls->defineFunction("init", _SE(js_cocos2dx_LayerColor_initWithColor));
    cls->defineFunction("changeHeight", _SE(js_cocos2dx_LayerColor_changeHeight));
    cls->defineFunction("ctor", _SE(js_cocos2dx_LayerColor_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_LayerColor_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_LayerColor_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::LayerColor>(cls);

    __jsb_cocos2d_LayerColor_proto = cls->getProto();
    __jsb_cocos2d_LayerColor_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.LayerColor.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_LayerGradient_proto = nullptr;
se::Class* __jsb_cocos2d_LayerGradient_class = nullptr;

static bool js_cocos2dx_LayerGradient_getStartColor(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_getStartColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color3B& result = cobj->getStartColor();
        ok &= Color3B_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_getStartColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_getStartColor)

static bool js_cocos2dx_LayerGradient_isCompressedInterpolation(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_isCompressedInterpolation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isCompressedInterpolation();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_isCompressedInterpolation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_isCompressedInterpolation)

static bool js_cocos2dx_LayerGradient_getStartOpacity(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_getStartOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        uint8_t result = cobj->getStartOpacity();
        ok &= uint8_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_getStartOpacity : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_getStartOpacity)

static bool js_cocos2dx_LayerGradient_setVector(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setVector : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setVector : Error processing arguments");
        cobj->setVector(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setVector)

static bool js_cocos2dx_LayerGradient_setStartOpacity(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setStartOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        uint8_t arg0;
        ok &= seval_to_uint8(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setStartOpacity : Error processing arguments");
        cobj->setStartOpacity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setStartOpacity)

static bool js_cocos2dx_LayerGradient_setCompressedInterpolation(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setCompressedInterpolation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setCompressedInterpolation : Error processing arguments");
        cobj->setCompressedInterpolation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setCompressedInterpolation)

static bool js_cocos2dx_LayerGradient_setEndOpacity(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setEndOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        uint8_t arg0;
        ok &= seval_to_uint8(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setEndOpacity : Error processing arguments");
        cobj->setEndOpacity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setEndOpacity)

static bool js_cocos2dx_LayerGradient_getVector(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_getVector : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getVector();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_getVector : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_getVector)

static bool js_cocos2dx_LayerGradient_setEndColor(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setEndColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setEndColor : Error processing arguments");
        cobj->setEndColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setEndColor)

static bool js_cocos2dx_LayerGradient_initWithColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_LayerGradient_initWithColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Color4B arg1;
            ok &= seval_to_Color4B(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg2;
            ok &= seval_to_Vec2(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithColor(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_initWithColor : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Color4B arg1;
            ok &= seval_to_Color4B(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithColor(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_initWithColor : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_initWithColor)

static bool js_cocos2dx_LayerGradient_getEndColor(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_getEndColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color3B& result = cobj->getEndColor();
        ok &= Color3B_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_getEndColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_getEndColor)

static bool js_cocos2dx_LayerGradient_getEndOpacity(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_getEndOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        uint8_t result = cobj->getEndOpacity();
        ok &= uint8_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_getEndOpacity : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_getEndOpacity)

static bool js_cocos2dx_LayerGradient_setStartColor(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setStartColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setStartColor : Error processing arguments");
        cobj->setStartColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setStartColor)

static bool js_cocos2dx_LayerGradient_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Color4B arg1;
            ok &= seval_to_Color4B(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::LayerGradient* result = cocos2d::LayerGradient::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::LayerGradient>((cocos2d::LayerGradient*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 0) {
            cocos2d::LayerGradient* result = cocos2d::LayerGradient::create();
            ok &= native_ptr_to_seval<cocos2d::LayerGradient>((cocos2d::LayerGradient*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Color4B arg1;
            ok &= seval_to_Color4B(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg2;
            ok &= seval_to_Vec2(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::LayerGradient* result = cocos2d::LayerGradient::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::LayerGradient>((cocos2d::LayerGradient*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_LayerGradient_finalize)

static bool js_cocos2dx_LayerGradient_constructor(se::State& s)
{
    cocos2d::LayerGradient* cobj = new (std::nothrow) cocos2d::LayerGradient();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_LayerGradient_constructor, __jsb_cocos2d_LayerGradient_class, js_cocos2d_LayerGradient_finalize)

static bool js_cocos2dx_LayerGradient_ctor(se::State& s)
{
    cocos2d::LayerGradient* cobj = new (std::nothrow) cocos2d::LayerGradient();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_LayerGradient_ctor, __jsb_cocos2d_LayerGradient_class, js_cocos2d_LayerGradient_finalize)


    

extern se::Object* __jsb_cocos2d_LayerColor_proto;

bool js_cocos2d_LayerGradient_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::LayerGradient)", s.nativeThisObject());
        cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_LayerGradient_finalize)

bool js_register_cocos2dx_LayerGradient(se::Object* obj)
{
    auto cls = se::Class::create("LayerGradient", obj, __jsb_cocos2d_LayerColor_proto, _SE(js_cocos2dx_LayerGradient_constructor));

    cls->defineFunction("getStartColor", _SE(js_cocos2dx_LayerGradient_getStartColor));
    cls->defineFunction("isCompressedInterpolation", _SE(js_cocos2dx_LayerGradient_isCompressedInterpolation));
    cls->defineFunction("getStartOpacity", _SE(js_cocos2dx_LayerGradient_getStartOpacity));
    cls->defineFunction("setVector", _SE(js_cocos2dx_LayerGradient_setVector));
    cls->defineFunction("setStartOpacity", _SE(js_cocos2dx_LayerGradient_setStartOpacity));
    cls->defineFunction("setCompressedInterpolation", _SE(js_cocos2dx_LayerGradient_setCompressedInterpolation));
    cls->defineFunction("setEndOpacity", _SE(js_cocos2dx_LayerGradient_setEndOpacity));
    cls->defineFunction("getVector", _SE(js_cocos2dx_LayerGradient_getVector));
    cls->defineFunction("setEndColor", _SE(js_cocos2dx_LayerGradient_setEndColor));
    cls->defineFunction("initWithColor", _SE(js_cocos2dx_LayerGradient_initWithColor));
    cls->defineFunction("getEndColor", _SE(js_cocos2dx_LayerGradient_getEndColor));
    cls->defineFunction("getEndOpacity", _SE(js_cocos2dx_LayerGradient_getEndOpacity));
    cls->defineFunction("setStartColor", _SE(js_cocos2dx_LayerGradient_setStartColor));
    cls->defineFunction("ctor", _SE(js_cocos2dx_LayerGradient_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_LayerGradient_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_LayerGradient_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::LayerGradient>(cls);

    __jsb_cocos2d_LayerGradient_proto = cls->getProto();
    __jsb_cocos2d_LayerGradient_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.LayerGradient.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_LayerMultiplex_proto = nullptr;
se::Class* __jsb_cocos2d_LayerMultiplex_class = nullptr;

static bool js_cocos2dx_LayerMultiplex_initWithArray(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = (cocos2d::LayerMultiplex*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerMultiplex_initWithArray : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::Layer *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerMultiplex_initWithArray : Error processing arguments");
        bool result = cobj->initWithArray(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerMultiplex_initWithArray : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerMultiplex_initWithArray)

static bool js_cocos2dx_LayerMultiplex_switchToAndReleaseMe(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = (cocos2d::LayerMultiplex*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerMultiplex_switchToAndReleaseMe : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerMultiplex_switchToAndReleaseMe : Error processing arguments");
        cobj->switchToAndReleaseMe(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerMultiplex_switchToAndReleaseMe)

static bool js_cocos2dx_LayerMultiplex_addLayer(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = (cocos2d::LayerMultiplex*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerMultiplex_addLayer : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Layer* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerMultiplex_addLayer : Error processing arguments");
        cobj->addLayer(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerMultiplex_addLayer)

static bool js_cocos2dx_LayerMultiplex_switchTo(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = (cocos2d::LayerMultiplex*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_LayerMultiplex_switchTo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_LayerMultiplex_switchTo : Error processing arguments");
        cobj->switchTo(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerMultiplex_switchTo)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_LayerMultiplex_finalize)

static bool js_cocos2dx_LayerMultiplex_constructor(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = new (std::nothrow) cocos2d::LayerMultiplex();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_LayerMultiplex_constructor, __jsb_cocos2d_LayerMultiplex_class, js_cocos2d_LayerMultiplex_finalize)

static bool js_cocos2dx_LayerMultiplex_ctor(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = new (std::nothrow) cocos2d::LayerMultiplex();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_LayerMultiplex_ctor, __jsb_cocos2d_LayerMultiplex_class, js_cocos2d_LayerMultiplex_finalize)


    

extern se::Object* __jsb_cocos2d_Layer_proto;

bool js_cocos2d_LayerMultiplex_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::LayerMultiplex)", s.nativeThisObject());
        cocos2d::LayerMultiplex* cobj = (cocos2d::LayerMultiplex*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_LayerMultiplex_finalize)

bool js_register_cocos2dx_LayerMultiplex(se::Object* obj)
{
    auto cls = se::Class::create("LayerMultiplex", obj, __jsb_cocos2d_Layer_proto, _SE(js_cocos2dx_LayerMultiplex_constructor));

    cls->defineFunction("initWithArray", _SE(js_cocos2dx_LayerMultiplex_initWithArray));
    cls->defineFunction("switchToAndReleaseMe", _SE(js_cocos2dx_LayerMultiplex_switchToAndReleaseMe));
    cls->defineFunction("addLayer", _SE(js_cocos2dx_LayerMultiplex_addLayer));
    cls->defineFunction("switchTo", _SE(js_cocos2dx_LayerMultiplex_switchTo));
    cls->defineFunction("ctor", _SE(js_cocos2dx_LayerMultiplex_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_LayerMultiplex_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::LayerMultiplex>(cls);

    __jsb_cocos2d_LayerMultiplex_proto = cls->getProto();
    __jsb_cocos2d_LayerMultiplex_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.LayerMultiplex.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_MenuItem_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItem_class = nullptr;

static bool js_cocos2dx_MenuItem_setEnabled(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_setEnabled)

static bool js_cocos2dx_MenuItem_activate(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_activate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->activate();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_activate)

static bool js_cocos2dx_MenuItem_initWithCallback(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_initWithCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void (cocos2d::Ref *)> arg0;
        do {
		    if (args[0].isObject() && args[0].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[0]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](cocos2d::Ref* larg0) -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(1);
		            ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg0 = lambda;
		    }
		    else
		    {
		        arg0 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_initWithCallback : Error processing arguments");
        bool result = cobj->initWithCallback(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_initWithCallback : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_initWithCallback)

static bool js_cocos2dx_MenuItem_isEnabled(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_isEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_isEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_isEnabled)

static bool js_cocos2dx_MenuItem_selected(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_selected : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->selected();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_selected)

static bool js_cocos2dx_MenuItem_isSelected(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_isSelected : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isSelected();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_isSelected : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_isSelected)

static bool js_cocos2dx_MenuItem_setCallback(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_setCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void (cocos2d::Ref *)> arg0;
        do {
		    if (args[0].isObject() && args[0].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[0]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](cocos2d::Ref* larg0) -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(1);
		            ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg0 = lambda;
		    }
		    else
		    {
		        arg0 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_setCallback : Error processing arguments");
        cobj->setCallback(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_setCallback)

static bool js_cocos2dx_MenuItem_unselected(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_unselected : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->unselected();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_unselected)

static bool js_cocos2dx_MenuItem_rect(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_rect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->rect();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_rect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_rect)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItem_finalize)

static bool js_cocos2dx_MenuItem_constructor(se::State& s)
{
    cocos2d::MenuItem* cobj = new (std::nothrow) cocos2d::MenuItem();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItem_constructor, __jsb_cocos2d_MenuItem_class, js_cocos2d_MenuItem_finalize)

static bool js_cocos2dx_MenuItem_ctor(se::State& s)
{
    cocos2d::MenuItem* cobj = new (std::nothrow) cocos2d::MenuItem();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItem_ctor, __jsb_cocos2d_MenuItem_class, js_cocos2d_MenuItem_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_MenuItem_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::MenuItem)", s.nativeThisObject());
        cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItem_finalize)

bool js_register_cocos2dx_MenuItem(se::Object* obj)
{
    auto cls = se::Class::create("MenuItem", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_MenuItem_constructor));

    cls->defineFunction("setEnabled", _SE(js_cocos2dx_MenuItem_setEnabled));
    cls->defineFunction("activate", _SE(js_cocos2dx_MenuItem_activate));
    cls->defineFunction("initWithCallback", _SE(js_cocos2dx_MenuItem_initWithCallback));
    cls->defineFunction("isEnabled", _SE(js_cocos2dx_MenuItem_isEnabled));
    cls->defineFunction("selected", _SE(js_cocos2dx_MenuItem_selected));
    cls->defineFunction("isSelected", _SE(js_cocos2dx_MenuItem_isSelected));
    cls->defineFunction("setCallback", _SE(js_cocos2dx_MenuItem_setCallback));
    cls->defineFunction("unselected", _SE(js_cocos2dx_MenuItem_unselected));
    cls->defineFunction("rect", _SE(js_cocos2dx_MenuItem_rect));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItem_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_MenuItem_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItem>(cls);

    __jsb_cocos2d_MenuItem_proto = cls->getProto();
    __jsb_cocos2d_MenuItem_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.MenuItem.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_MenuItemLabel_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemLabel_class = nullptr;

static bool js_cocos2dx_MenuItemLabel_setLabel(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_setLabel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_setLabel : Error processing arguments");
        cobj->setLabel(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_setLabel)

static bool js_cocos2dx_MenuItemLabel_getString(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_getString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getString();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_getString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_getString)

static bool js_cocos2dx_MenuItemLabel_getDisabledColor(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_getDisabledColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color3B& result = cobj->getDisabledColor();
        ok &= Color3B_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_getDisabledColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_getDisabledColor)

static bool js_cocos2dx_MenuItemLabel_setString(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_setString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_setString : Error processing arguments");
        cobj->setString(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_setString)

static bool js_cocos2dx_MenuItemLabel_initWithLabel(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_initWithLabel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        std::function<void (cocos2d::Ref *)> arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        do {
		    if (args[1].isObject() && args[1].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[1]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](cocos2d::Ref* larg0) -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(1);
		            ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg1 = lambda;
		    }
		    else
		    {
		        arg1 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_initWithLabel : Error processing arguments");
        bool result = cobj->initWithLabel(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_initWithLabel : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_initWithLabel)

static bool js_cocos2dx_MenuItemLabel_setDisabledColor(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_setDisabledColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_setDisabledColor : Error processing arguments");
        cobj->setDisabledColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_setDisabledColor)

static bool js_cocos2dx_MenuItemLabel_getLabel(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_getLabel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getLabel();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_getLabel : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_getLabel)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemLabel_finalize)

static bool js_cocos2dx_MenuItemLabel_constructor(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = new (std::nothrow) cocos2d::MenuItemLabel();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemLabel_constructor, __jsb_cocos2d_MenuItemLabel_class, js_cocos2d_MenuItemLabel_finalize)

static bool js_cocos2dx_MenuItemLabel_ctor(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = new (std::nothrow) cocos2d::MenuItemLabel();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemLabel_ctor, __jsb_cocos2d_MenuItemLabel_class, js_cocos2d_MenuItemLabel_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItem_proto;

bool js_cocos2d_MenuItemLabel_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::MenuItemLabel)", s.nativeThisObject());
        cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemLabel_finalize)

bool js_register_cocos2dx_MenuItemLabel(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemLabel", obj, __jsb_cocos2d_MenuItem_proto, _SE(js_cocos2dx_MenuItemLabel_constructor));

    cls->defineFunction("setLabel", _SE(js_cocos2dx_MenuItemLabel_setLabel));
    cls->defineFunction("getString", _SE(js_cocos2dx_MenuItemLabel_getString));
    cls->defineFunction("getDisabledColor", _SE(js_cocos2dx_MenuItemLabel_getDisabledColor));
    cls->defineFunction("setString", _SE(js_cocos2dx_MenuItemLabel_setString));
    cls->defineFunction("initWithLabel", _SE(js_cocos2dx_MenuItemLabel_initWithLabel));
    cls->defineFunction("setDisabledColor", _SE(js_cocos2dx_MenuItemLabel_setDisabledColor));
    cls->defineFunction("getLabel", _SE(js_cocos2dx_MenuItemLabel_getLabel));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemLabel_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_MenuItemLabel_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemLabel>(cls);

    __jsb_cocos2d_MenuItemLabel_proto = cls->getProto();
    __jsb_cocos2d_MenuItemLabel_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.MenuItemLabel.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_MenuItemAtlasFont_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemAtlasFont_class = nullptr;

static bool js_cocos2dx_MenuItemAtlasFont_initWithString(se::State& s)
{
    cocos2d::MenuItemAtlasFont* cobj = (cocos2d::MenuItemAtlasFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemAtlasFont_initWithString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 6) {
        std::string arg0;
        std::string arg1;
        int arg2 = 0;
        int arg3 = 0;
        int8_t arg4;
        std::function<void (cocos2d::Ref *)> arg5;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        ok &= seval_to_int8(args[4], &arg4);
        do {
		    if (args[5].isObject() && args[5].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[5]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](cocos2d::Ref* larg0) -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(1);
		            ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg5 = lambda;
		    }
		    else
		    {
		        arg5 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemAtlasFont_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemAtlasFont_initWithString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemAtlasFont_initWithString)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemAtlasFont_finalize)

static bool js_cocos2dx_MenuItemAtlasFont_constructor(se::State& s)
{
    cocos2d::MenuItemAtlasFont* cobj = new (std::nothrow) cocos2d::MenuItemAtlasFont();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemAtlasFont_constructor, __jsb_cocos2d_MenuItemAtlasFont_class, js_cocos2d_MenuItemAtlasFont_finalize)

static bool js_cocos2dx_MenuItemAtlasFont_ctor(se::State& s)
{
    cocos2d::MenuItemAtlasFont* cobj = new (std::nothrow) cocos2d::MenuItemAtlasFont();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemAtlasFont_ctor, __jsb_cocos2d_MenuItemAtlasFont_class, js_cocos2d_MenuItemAtlasFont_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItemLabel_proto;

bool js_cocos2d_MenuItemAtlasFont_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::MenuItemAtlasFont)", s.nativeThisObject());
        cocos2d::MenuItemAtlasFont* cobj = (cocos2d::MenuItemAtlasFont*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemAtlasFont_finalize)

bool js_register_cocos2dx_MenuItemAtlasFont(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemAtlasFont", obj, __jsb_cocos2d_MenuItemLabel_proto, _SE(js_cocos2dx_MenuItemAtlasFont_constructor));

    cls->defineFunction("initWithString", _SE(js_cocos2dx_MenuItemAtlasFont_initWithString));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemAtlasFont_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_MenuItemAtlasFont_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemAtlasFont>(cls);

    __jsb_cocos2d_MenuItemAtlasFont_proto = cls->getProto();
    __jsb_cocos2d_MenuItemAtlasFont_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.MenuItemAtlasFont.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_MenuItemFont_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemFont_class = nullptr;

static bool js_cocos2dx_MenuItemFont_setFontNameObj(se::State& s)
{
    cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemFont_setFontNameObj : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_setFontNameObj : Error processing arguments");
        cobj->setFontNameObj(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_setFontNameObj)

static bool js_cocos2dx_MenuItemFont_getFontSizeObj(se::State& s)
{
    cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemFont_getFontSizeObj : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getFontSizeObj();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_getFontSizeObj : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_getFontSizeObj)

static bool js_cocos2dx_MenuItemFont_setFontSizeObj(se::State& s)
{
    cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemFont_setFontSizeObj : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_setFontSizeObj : Error processing arguments");
        cobj->setFontSizeObj(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_setFontSizeObj)

static bool js_cocos2dx_MenuItemFont_initWithString(se::State& s)
{
    cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemFont_initWithString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::function<void (cocos2d::Ref *)> arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        do {
		    if (args[1].isObject() && args[1].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[1]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](cocos2d::Ref* larg0) -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(1);
		            ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg1 = lambda;
		    }
		    else
		    {
		        arg1 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_initWithString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_initWithString)

static bool js_cocos2dx_MenuItemFont_getFontNameObj(se::State& s)
{
    cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemFont_getFontNameObj : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getFontNameObj();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_getFontNameObj : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_getFontNameObj)

static bool js_cocos2dx_MenuItemFont_setFontName(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_setFontName : Error processing arguments");
        cocos2d::MenuItemFont::setFontName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_setFontName)

static bool js_cocos2dx_MenuItemFont_getFontSize(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cocos2d::MenuItemFont::getFontSize();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_getFontSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_getFontSize)

static bool js_cocos2dx_MenuItemFont_getFontName(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cocos2d::MenuItemFont::getFontName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_getFontName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_getFontName)

static bool js_cocos2dx_MenuItemFont_setFontSize(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_setFontSize : Error processing arguments");
        cocos2d::MenuItemFont::setFontSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_setFontSize)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemFont_finalize)

static bool js_cocos2dx_MenuItemFont_constructor(se::State& s)
{
    cocos2d::MenuItemFont* cobj = new (std::nothrow) cocos2d::MenuItemFont();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemFont_constructor, __jsb_cocos2d_MenuItemFont_class, js_cocos2d_MenuItemFont_finalize)

static bool js_cocos2dx_MenuItemFont_ctor(se::State& s)
{
    cocos2d::MenuItemFont* cobj = new (std::nothrow) cocos2d::MenuItemFont();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemFont_ctor, __jsb_cocos2d_MenuItemFont_class, js_cocos2d_MenuItemFont_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItemLabel_proto;

bool js_cocos2d_MenuItemFont_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::MenuItemFont)", s.nativeThisObject());
        cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemFont_finalize)

bool js_register_cocos2dx_MenuItemFont(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemFont", obj, __jsb_cocos2d_MenuItemLabel_proto, _SE(js_cocos2dx_MenuItemFont_constructor));

    cls->defineFunction("setFontName", _SE(js_cocos2dx_MenuItemFont_setFontNameObj));
    cls->defineFunction("getFontSize", _SE(js_cocos2dx_MenuItemFont_getFontSizeObj));
    cls->defineFunction("setFontSize", _SE(js_cocos2dx_MenuItemFont_setFontSizeObj));
    cls->defineFunction("initWithString", _SE(js_cocos2dx_MenuItemFont_initWithString));
    cls->defineFunction("getFontName", _SE(js_cocos2dx_MenuItemFont_getFontNameObj));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemFont_ctor));
    cls->defineStaticFunction("setFontName", _SE(js_cocos2dx_MenuItemFont_setFontName));
    cls->defineStaticFunction("getFontSize", _SE(js_cocos2dx_MenuItemFont_getFontSize));
    cls->defineStaticFunction("getFontName", _SE(js_cocos2dx_MenuItemFont_getFontName));
    cls->defineStaticFunction("setFontSize", _SE(js_cocos2dx_MenuItemFont_setFontSize));
    cls->defineFinalizedFunction(_SE(js_cocos2d_MenuItemFont_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemFont>(cls);

    __jsb_cocos2d_MenuItemFont_proto = cls->getProto();
    __jsb_cocos2d_MenuItemFont_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.MenuItemFont.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_MenuItemSprite_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemSprite_class = nullptr;

static bool js_cocos2dx_MenuItemSprite_setEnabled(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_setEnabled)

static bool js_cocos2dx_MenuItemSprite_selected(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_selected : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->selected();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_selected)

static bool js_cocos2dx_MenuItemSprite_setNormalImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_setNormalImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_setNormalImage : Error processing arguments");
        cobj->setNormalImage(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_setNormalImage)

static bool js_cocos2dx_MenuItemSprite_setDisabledImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_setDisabledImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_setDisabledImage : Error processing arguments");
        cobj->setDisabledImage(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_setDisabledImage)

static bool js_cocos2dx_MenuItemSprite_initWithNormalSprite(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_initWithNormalSprite : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        cocos2d::Node* arg0 = nullptr;
        cocos2d::Node* arg1 = nullptr;
        cocos2d::Node* arg2 = nullptr;
        std::function<void (cocos2d::Ref *)> arg3;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_native_ptr(args[2], &arg2);
        do {
		    if (args[3].isObject() && args[3].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[3]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](cocos2d::Ref* larg0) -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(1);
		            ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg3 = lambda;
		    }
		    else
		    {
		        arg3 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_initWithNormalSprite : Error processing arguments");
        bool result = cobj->initWithNormalSprite(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_initWithNormalSprite : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_initWithNormalSprite)

static bool js_cocos2dx_MenuItemSprite_setSelectedImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_setSelectedImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_setSelectedImage : Error processing arguments");
        cobj->setSelectedImage(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_setSelectedImage)

static bool js_cocos2dx_MenuItemSprite_getDisabledImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_getDisabledImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getDisabledImage();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_getDisabledImage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_getDisabledImage)

static bool js_cocos2dx_MenuItemSprite_getSelectedImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_getSelectedImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getSelectedImage();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_getSelectedImage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_getSelectedImage)

static bool js_cocos2dx_MenuItemSprite_getNormalImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_getNormalImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getNormalImage();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_getNormalImage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_getNormalImage)

static bool js_cocos2dx_MenuItemSprite_unselected(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_unselected : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->unselected();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_unselected)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemSprite_finalize)

static bool js_cocos2dx_MenuItemSprite_constructor(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = new (std::nothrow) cocos2d::MenuItemSprite();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemSprite_constructor, __jsb_cocos2d_MenuItemSprite_class, js_cocos2d_MenuItemSprite_finalize)

static bool js_cocos2dx_MenuItemSprite_ctor(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = new (std::nothrow) cocos2d::MenuItemSprite();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemSprite_ctor, __jsb_cocos2d_MenuItemSprite_class, js_cocos2d_MenuItemSprite_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItem_proto;

bool js_cocos2d_MenuItemSprite_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::MenuItemSprite)", s.nativeThisObject());
        cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemSprite_finalize)

bool js_register_cocos2dx_MenuItemSprite(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemSprite", obj, __jsb_cocos2d_MenuItem_proto, _SE(js_cocos2dx_MenuItemSprite_constructor));

    cls->defineFunction("setEnabled", _SE(js_cocos2dx_MenuItemSprite_setEnabled));
    cls->defineFunction("selected", _SE(js_cocos2dx_MenuItemSprite_selected));
    cls->defineFunction("setNormalImage", _SE(js_cocos2dx_MenuItemSprite_setNormalImage));
    cls->defineFunction("setDisabledImage", _SE(js_cocos2dx_MenuItemSprite_setDisabledImage));
    cls->defineFunction("initWithNormalSprite", _SE(js_cocos2dx_MenuItemSprite_initWithNormalSprite));
    cls->defineFunction("setSelectedImage", _SE(js_cocos2dx_MenuItemSprite_setSelectedImage));
    cls->defineFunction("getDisabledImage", _SE(js_cocos2dx_MenuItemSprite_getDisabledImage));
    cls->defineFunction("getSelectedImage", _SE(js_cocos2dx_MenuItemSprite_getSelectedImage));
    cls->defineFunction("getNormalImage", _SE(js_cocos2dx_MenuItemSprite_getNormalImage));
    cls->defineFunction("unselected", _SE(js_cocos2dx_MenuItemSprite_unselected));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemSprite_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_MenuItemSprite_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemSprite>(cls);

    __jsb_cocos2d_MenuItemSprite_proto = cls->getProto();
    __jsb_cocos2d_MenuItemSprite_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.MenuItemSprite.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_MenuItemImage_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemImage_class = nullptr;

static bool js_cocos2dx_MenuItemImage_setDisabledSpriteFrame(se::State& s)
{
    cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemImage_setDisabledSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_setDisabledSpriteFrame : Error processing arguments");
        cobj->setDisabledSpriteFrame(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemImage_setDisabledSpriteFrame)

static bool js_cocos2dx_MenuItemImage_setSelectedSpriteFrame(se::State& s)
{
    cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemImage_setSelectedSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_setSelectedSpriteFrame : Error processing arguments");
        cobj->setSelectedSpriteFrame(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemImage_setSelectedSpriteFrame)

static bool js_cocos2dx_MenuItemImage_setNormalSpriteFrame(se::State& s)
{
    cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemImage_setNormalSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_setNormalSpriteFrame : Error processing arguments");
        cobj->setNormalSpriteFrame(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemImage_setNormalSpriteFrame)

static bool js_cocos2dx_MenuItemImage_init(se::State& s)
{
    cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemImage_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemImage_init)

static bool js_cocos2dx_MenuItemImage_initWithNormalImage(se::State& s)
{
    cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemImage_initWithNormalImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        std::string arg2;
        std::function<void (cocos2d::Ref *)> arg3;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_std_string(args[2], &arg2);
        do {
		    if (args[3].isObject() && args[3].toObject()->isFunction())
		    {
		        se::Value jsThis(s.thisObject());
		        se::Value jsFunc(args[3]);
		        jsThis.toObject()->attachChild(jsFunc.toObject());
		        auto lambda = [=](cocos2d::Ref* larg0) -> void {
		            se::ScriptEngine::getInstance()->clearException();
		            se::AutoHandleScope hs;
		
		            CC_UNUSED bool ok = true;
		            se::ValueArray args;
		            args.resize(1);
		            ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
		            se::Value rval;
		            se::Object* thisObj = jsThis.toObject();
		            se::Object* funcObj = jsFunc.toObject();
		            bool succeed = funcObj->call(args, thisObj, &rval);
		            if (!succeed) {
		                se::ScriptEngine::getInstance()->clearException();
		            }
		        };
		        arg3 = lambda;
		    }
		    else
		    {
		        arg3 = nullptr;
		    }
		} while(false)
		;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_initWithNormalImage : Error processing arguments");
        bool result = cobj->initWithNormalImage(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_initWithNormalImage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemImage_initWithNormalImage)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemImage_finalize)

static bool js_cocos2dx_MenuItemImage_constructor(se::State& s)
{
    cocos2d::MenuItemImage* cobj = new (std::nothrow) cocos2d::MenuItemImage();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemImage_constructor, __jsb_cocos2d_MenuItemImage_class, js_cocos2d_MenuItemImage_finalize)

static bool js_cocos2dx_MenuItemImage_ctor(se::State& s)
{
    cocos2d::MenuItemImage* cobj = new (std::nothrow) cocos2d::MenuItemImage();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemImage_ctor, __jsb_cocos2d_MenuItemImage_class, js_cocos2d_MenuItemImage_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItemSprite_proto;

bool js_cocos2d_MenuItemImage_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::MenuItemImage)", s.nativeThisObject());
        cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemImage_finalize)

bool js_register_cocos2dx_MenuItemImage(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemImage", obj, __jsb_cocos2d_MenuItemSprite_proto, _SE(js_cocos2dx_MenuItemImage_constructor));

    cls->defineFunction("setDisabledSpriteFrame", _SE(js_cocos2dx_MenuItemImage_setDisabledSpriteFrame));
    cls->defineFunction("setSelectedSpriteFrame", _SE(js_cocos2dx_MenuItemImage_setSelectedSpriteFrame));
    cls->defineFunction("setNormalSpriteFrame", _SE(js_cocos2dx_MenuItemImage_setNormalSpriteFrame));
    cls->defineFunction("init", _SE(js_cocos2dx_MenuItemImage_init));
    cls->defineFunction("initWithNormalImage", _SE(js_cocos2dx_MenuItemImage_initWithNormalImage));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemImage_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_MenuItemImage_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemImage>(cls);

    __jsb_cocos2d_MenuItemImage_proto = cls->getProto();
    __jsb_cocos2d_MenuItemImage_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.MenuItemImage.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_MenuItemToggle_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemToggle_class = nullptr;

static bool js_cocos2dx_MenuItemToggle_setSubItems(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_setSubItems : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::MenuItem *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_setSubItems : Error processing arguments");
        cobj->setSubItems(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_setSubItems)

static bool js_cocos2dx_MenuItemToggle_initWithItem(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_initWithItem : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::MenuItem* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_initWithItem : Error processing arguments");
        bool result = cobj->initWithItem(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_initWithItem : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_initWithItem)

static bool js_cocos2dx_MenuItemToggle_getSelectedIndex(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_getSelectedIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getSelectedIndex();
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_getSelectedIndex : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_getSelectedIndex)

static bool js_cocos2dx_MenuItemToggle_addSubItem(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_addSubItem : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::MenuItem* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_addSubItem : Error processing arguments");
        cobj->addSubItem(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_addSubItem)

static bool js_cocos2dx_MenuItemToggle_getSelectedItem(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_getSelectedItem : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::MenuItem* result = cobj->getSelectedItem();
        ok &= native_ptr_to_seval<cocos2d::MenuItem>((cocos2d::MenuItem*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_getSelectedItem : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_getSelectedItem)

static bool js_cocos2dx_MenuItemToggle_setSelectedIndex(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_setSelectedIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_setSelectedIndex : Error processing arguments");
        cobj->setSelectedIndex(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_setSelectedIndex)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemToggle_finalize)

static bool js_cocos2dx_MenuItemToggle_constructor(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = new (std::nothrow) cocos2d::MenuItemToggle();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemToggle_constructor, __jsb_cocos2d_MenuItemToggle_class, js_cocos2d_MenuItemToggle_finalize)

static bool js_cocos2dx_MenuItemToggle_ctor(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = new (std::nothrow) cocos2d::MenuItemToggle();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemToggle_ctor, __jsb_cocos2d_MenuItemToggle_class, js_cocos2d_MenuItemToggle_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItem_proto;

bool js_cocos2d_MenuItemToggle_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::MenuItemToggle)", s.nativeThisObject());
        cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemToggle_finalize)

bool js_register_cocos2dx_MenuItemToggle(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemToggle", obj, __jsb_cocos2d_MenuItem_proto, _SE(js_cocos2dx_MenuItemToggle_constructor));

    cls->defineFunction("setSubItems", _SE(js_cocos2dx_MenuItemToggle_setSubItems));
    cls->defineFunction("initWithItem", _SE(js_cocos2dx_MenuItemToggle_initWithItem));
    cls->defineFunction("getSelectedIndex", _SE(js_cocos2dx_MenuItemToggle_getSelectedIndex));
    cls->defineFunction("addSubItem", _SE(js_cocos2dx_MenuItemToggle_addSubItem));
    cls->defineFunction("getSelectedItem", _SE(js_cocos2dx_MenuItemToggle_getSelectedItem));
    cls->defineFunction("setSelectedIndex", _SE(js_cocos2dx_MenuItemToggle_setSelectedIndex));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemToggle_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_MenuItemToggle_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemToggle>(cls);

    __jsb_cocos2d_MenuItemToggle_proto = cls->getProto();
    __jsb_cocos2d_MenuItemToggle_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.MenuItemToggle.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Menu_proto = nullptr;
se::Class* __jsb_cocos2d_Menu_class = nullptr;

static bool js_cocos2dx_Menu_initWithArray(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_initWithArray : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::MenuItem *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Menu_initWithArray : Error processing arguments");
        bool result = cobj->initWithArray(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Menu_initWithArray : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_initWithArray)

static bool js_cocos2dx_Menu_setEnabled(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Menu_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_setEnabled)

static bool js_cocos2dx_Menu_alignItemsVertically(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_alignItemsVertically : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->alignItemsVertically();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_alignItemsVertically)

static bool js_cocos2dx_Menu_isEnabled(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_isEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Menu_isEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_isEnabled)

static bool js_cocos2dx_Menu_alignItemsHorizontallyWithPadding(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_alignItemsHorizontallyWithPadding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Menu_alignItemsHorizontallyWithPadding : Error processing arguments");
        cobj->alignItemsHorizontallyWithPadding(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_alignItemsHorizontallyWithPadding)

static bool js_cocos2dx_Menu_alignItemsVerticallyWithPadding(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_alignItemsVerticallyWithPadding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Menu_alignItemsVerticallyWithPadding : Error processing arguments");
        cobj->alignItemsVerticallyWithPadding(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_alignItemsVerticallyWithPadding)

static bool js_cocos2dx_Menu_alignItemsHorizontally(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_alignItemsHorizontally : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->alignItemsHorizontally();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_alignItemsHorizontally)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Menu_finalize)

static bool js_cocos2dx_Menu_constructor(se::State& s)
{
    cocos2d::Menu* cobj = new (std::nothrow) cocos2d::Menu();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Menu_constructor, __jsb_cocos2d_Menu_class, js_cocos2d_Menu_finalize)

static bool js_cocos2dx_Menu_ctor(se::State& s)
{
    cocos2d::Menu* cobj = new (std::nothrow) cocos2d::Menu();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Menu_ctor, __jsb_cocos2d_Menu_class, js_cocos2d_Menu_finalize)


    

extern se::Object* __jsb_cocos2d_Layer_proto;

bool js_cocos2d_Menu_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Menu)", s.nativeThisObject());
        cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Menu_finalize)

bool js_register_cocos2dx_Menu(se::Object* obj)
{
    auto cls = se::Class::create("Menu", obj, __jsb_cocos2d_Layer_proto, _SE(js_cocos2dx_Menu_constructor));

    cls->defineFunction("initWithArray", _SE(js_cocos2dx_Menu_initWithArray));
    cls->defineFunction("setEnabled", _SE(js_cocos2dx_Menu_setEnabled));
    cls->defineFunction("alignItemsVertically", _SE(js_cocos2dx_Menu_alignItemsVertically));
    cls->defineFunction("isEnabled", _SE(js_cocos2dx_Menu_isEnabled));
    cls->defineFunction("alignItemsHorizontallyWithPadding", _SE(js_cocos2dx_Menu_alignItemsHorizontallyWithPadding));
    cls->defineFunction("alignItemsVerticallyWithPadding", _SE(js_cocos2dx_Menu_alignItemsVerticallyWithPadding));
    cls->defineFunction("alignItemsHorizontally", _SE(js_cocos2dx_Menu_alignItemsHorizontally));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Menu_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Menu_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Menu>(cls);

    __jsb_cocos2d_Menu_proto = cls->getProto();
    __jsb_cocos2d_Menu_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Menu.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_MotionStreak_proto = nullptr;
se::Class* __jsb_cocos2d_MotionStreak_class = nullptr;

static bool js_cocos2dx_MotionStreak_reset(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_reset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->reset();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_reset)

static bool js_cocos2dx_MotionStreak_setTexture(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setTexture)

static bool js_cocos2dx_MotionStreak_getTexture(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_getTexture)

static bool js_cocos2dx_MotionStreak_tintWithColor(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_tintWithColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_tintWithColor : Error processing arguments");
        cobj->tintWithColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_tintWithColor)

static bool js_cocos2dx_MotionStreak_setBlendFunc(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setBlendFunc)

static bool js_cocos2dx_MotionStreak_setStartingPositionInitialized(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setStartingPositionInitialized : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setStartingPositionInitialized : Error processing arguments");
        cobj->setStartingPositionInitialized(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setStartingPositionInitialized)

static bool js_cocos2dx_MotionStreak_getBlendFunc(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_getBlendFunc)

static bool js_cocos2dx_MotionStreak_isStartingPositionInitialized(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_isStartingPositionInitialized : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isStartingPositionInitialized();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_isStartingPositionInitialized : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_isStartingPositionInitialized)

static bool js_cocos2dx_MotionStreak_isFastMode(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_isFastMode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isFastMode();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_isFastMode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_isFastMode)

static bool js_cocos2dx_MotionStreak_getStroke(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_getStroke : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStroke();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_getStroke : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_getStroke)

static bool js_cocos2dx_MotionStreak_initWithFade(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_MotionStreak_initWithFade : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg3;
            ok &= seval_to_Color3B(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg4 = nullptr;
            ok &= seval_to_native_ptr(args[4], &arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFade(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_initWithFade : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg3;
            ok &= seval_to_Color3B(args[3], &arg3);
            if (!ok) { ok = true; break; }
            std::string arg4;
            ok &= seval_to_std_string(args[4], &arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFade(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_initWithFade : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_initWithFade)

static bool js_cocos2dx_MotionStreak_setFastMode(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setFastMode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setFastMode : Error processing arguments");
        cobj->setFastMode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setFastMode)

static bool js_cocos2dx_MotionStreak_setStroke(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setStroke : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setStroke : Error processing arguments");
        cobj->setStroke(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setStroke)

static bool js_cocos2dx_MotionStreak_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg3;
            ok &= seval_to_Color3B(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg4 = nullptr;
            ok &= seval_to_native_ptr(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cocos2d::MotionStreak* result = cocos2d::MotionStreak::create(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::MotionStreak>((cocos2d::MotionStreak*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 5) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg3;
            ok &= seval_to_Color3B(args[3], &arg3);
            if (!ok) { ok = true; break; }
            std::string arg4;
            ok &= seval_to_std_string(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cocos2d::MotionStreak* result = cocos2d::MotionStreak::create(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::MotionStreak>((cocos2d::MotionStreak*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MotionStreak_finalize)

static bool js_cocos2dx_MotionStreak_constructor(se::State& s)
{
    cocos2d::MotionStreak* cobj = new (std::nothrow) cocos2d::MotionStreak();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MotionStreak_constructor, __jsb_cocos2d_MotionStreak_class, js_cocos2d_MotionStreak_finalize)

static bool js_cocos2dx_MotionStreak_ctor(se::State& s)
{
    cocos2d::MotionStreak* cobj = new (std::nothrow) cocos2d::MotionStreak();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MotionStreak_ctor, __jsb_cocos2d_MotionStreak_class, js_cocos2d_MotionStreak_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_MotionStreak_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::MotionStreak)", s.nativeThisObject());
        cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MotionStreak_finalize)

bool js_register_cocos2dx_MotionStreak(se::Object* obj)
{
    auto cls = se::Class::create("MotionStreak", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_MotionStreak_constructor));

    cls->defineFunction("reset", _SE(js_cocos2dx_MotionStreak_reset));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_MotionStreak_setTexture));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_MotionStreak_getTexture));
    cls->defineFunction("tintWithColor", _SE(js_cocos2dx_MotionStreak_tintWithColor));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_MotionStreak_setBlendFunc));
    cls->defineFunction("setStartingPositionInitialized", _SE(js_cocos2dx_MotionStreak_setStartingPositionInitialized));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_MotionStreak_getBlendFunc));
    cls->defineFunction("isStartingPositionInitialized", _SE(js_cocos2dx_MotionStreak_isStartingPositionInitialized));
    cls->defineFunction("isFastMode", _SE(js_cocos2dx_MotionStreak_isFastMode));
    cls->defineFunction("getStroke", _SE(js_cocos2dx_MotionStreak_getStroke));
    cls->defineFunction("initWithFade", _SE(js_cocos2dx_MotionStreak_initWithFade));
    cls->defineFunction("setFastMode", _SE(js_cocos2dx_MotionStreak_setFastMode));
    cls->defineFunction("setStroke", _SE(js_cocos2dx_MotionStreak_setStroke));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MotionStreak_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_MotionStreak_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_MotionStreak_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MotionStreak>(cls);

    __jsb_cocos2d_MotionStreak_proto = cls->getProto();
    __jsb_cocos2d_MotionStreak_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.MotionStreak.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_NodeGrid_proto = nullptr;
se::Class* __jsb_cocos2d_NodeGrid_class = nullptr;

static bool js_cocos2dx_NodeGrid_setTarget(se::State& s)
{
    cocos2d::NodeGrid* cobj = (cocos2d::NodeGrid*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_NodeGrid_setTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_NodeGrid_setTarget : Error processing arguments");
        cobj->setTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_NodeGrid_setTarget)

static bool js_cocos2dx_NodeGrid_getGrid(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::NodeGrid* cobj = (cocos2d::NodeGrid*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_NodeGrid_getGrid : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::GridBase* result = cobj->getGrid();
            ok &= native_ptr_to_seval<cocos2d::GridBase>((cocos2d::GridBase*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_NodeGrid_getGrid : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::GridBase* result = cobj->getGrid();
            ok &= native_ptr_to_seval<cocos2d::GridBase>((cocos2d::GridBase*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_NodeGrid_getGrid : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_NodeGrid_getGrid)

static bool js_cocos2dx_NodeGrid_getGridRect(se::State& s)
{
    cocos2d::NodeGrid* cobj = (cocos2d::NodeGrid*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_NodeGrid_getGridRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Rect& result = cobj->getGridRect();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_NodeGrid_getGridRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_NodeGrid_getGridRect)

static bool js_cocos2dx_NodeGrid_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Rect arg0;
            ok &= seval_to_Rect(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::NodeGrid* result = cocos2d::NodeGrid::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::NodeGrid>((cocos2d::NodeGrid*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_NodeGrid_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 0) {
            cocos2d::NodeGrid* result = cocos2d::NodeGrid::create();
            ok &= native_ptr_to_seval<cocos2d::NodeGrid>((cocos2d::NodeGrid*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_NodeGrid_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_NodeGrid_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_NodeGrid_finalize)

static bool js_cocos2dx_NodeGrid_constructor(se::State& s)
{
    cocos2d::NodeGrid* cobj = new (std::nothrow) cocos2d::NodeGrid();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_NodeGrid_constructor, __jsb_cocos2d_NodeGrid_class, js_cocos2d_NodeGrid_finalize)



extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_NodeGrid_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::NodeGrid)", s.nativeThisObject());
        cocos2d::NodeGrid* cobj = (cocos2d::NodeGrid*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_NodeGrid_finalize)

bool js_register_cocos2dx_NodeGrid(se::Object* obj)
{
    auto cls = se::Class::create("NodeGrid", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_NodeGrid_constructor));

    cls->defineFunction("setTarget", _SE(js_cocos2dx_NodeGrid_setTarget));
    cls->defineFunction("getGrid", _SE(js_cocos2dx_NodeGrid_getGrid));
    cls->defineFunction("getGridRect", _SE(js_cocos2dx_NodeGrid_getGridRect));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_NodeGrid_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_NodeGrid_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::NodeGrid>(cls);

    __jsb_cocos2d_NodeGrid_proto = cls->getProto();
    __jsb_cocos2d_NodeGrid_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleBatchNode_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleBatchNode_class = nullptr;

static bool js_cocos2dx_ParticleBatchNode_setTexture(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_setTexture)

static bool js_cocos2dx_ParticleBatchNode_initWithTexture(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_initWithTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Texture2D* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_initWithTexture : Error processing arguments");
        bool result = cobj->initWithTexture(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_initWithTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_initWithTexture)

static bool js_cocos2dx_ParticleBatchNode_disableParticle(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_disableParticle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_disableParticle : Error processing arguments");
        cobj->disableParticle(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_disableParticle)

static bool js_cocos2dx_ParticleBatchNode_getTexture(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_getTexture)

static bool js_cocos2dx_ParticleBatchNode_setTextureAtlas(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_setTextureAtlas : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextureAtlas* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_setTextureAtlas : Error processing arguments");
        cobj->setTextureAtlas(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_setTextureAtlas)

static bool js_cocos2dx_ParticleBatchNode_initWithFile(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_initWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        int arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_initWithFile : Error processing arguments");
        bool result = cobj->initWithFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_initWithFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_initWithFile)

static bool js_cocos2dx_ParticleBatchNode_setBlendFunc(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_setBlendFunc)

static bool js_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup : Error processing arguments");
        cobj->removeAllChildrenWithCleanup(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup)

static bool js_cocos2dx_ParticleBatchNode_getBlendFunc(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_getBlendFunc)

static bool js_cocos2dx_ParticleBatchNode_insertChild(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_insertChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ParticleSystem* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_insertChild : Error processing arguments");
        cobj->insertChild(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_insertChild)

static bool js_cocos2dx_ParticleBatchNode_removeChildAtIndex(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_removeChildAtIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        int arg0 = 0;
        bool arg1;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_removeChildAtIndex : Error processing arguments");
        cobj->removeChildAtIndex(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_removeChildAtIndex)

static bool js_cocos2dx_ParticleBatchNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_create : Error processing arguments");
        auto result = cocos2d::ParticleBatchNode::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleBatchNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        int arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_create : Error processing arguments");
        auto result = cocos2d::ParticleBatchNode::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleBatchNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_create)

static bool js_cocos2dx_ParticleBatchNode_createWithTexture(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_createWithTexture : Error processing arguments");
        auto result = cocos2d::ParticleBatchNode::createWithTexture(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleBatchNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        cocos2d::Texture2D* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_createWithTexture : Error processing arguments");
        auto result = cocos2d::ParticleBatchNode::createWithTexture(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleBatchNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_createWithTexture)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleBatchNode_finalize)

static bool js_cocos2dx_ParticleBatchNode_constructor(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = new (std::nothrow) cocos2d::ParticleBatchNode();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleBatchNode_constructor, __jsb_cocos2d_ParticleBatchNode_class, js_cocos2d_ParticleBatchNode_finalize)

static bool js_cocos2dx_ParticleBatchNode_ctor(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = new (std::nothrow) cocos2d::ParticleBatchNode();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ParticleBatchNode_ctor, __jsb_cocos2d_ParticleBatchNode_class, js_cocos2d_ParticleBatchNode_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_ParticleBatchNode_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleBatchNode)", s.nativeThisObject());
        cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleBatchNode_finalize)

bool js_register_cocos2dx_ParticleBatchNode(se::Object* obj)
{
    auto cls = se::Class::create("ParticleBatchNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_ParticleBatchNode_constructor));

    cls->defineFunction("setTexture", _SE(js_cocos2dx_ParticleBatchNode_setTexture));
    cls->defineFunction("initWithTexture", _SE(js_cocos2dx_ParticleBatchNode_initWithTexture));
    cls->defineFunction("disableParticle", _SE(js_cocos2dx_ParticleBatchNode_disableParticle));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_ParticleBatchNode_getTexture));
    cls->defineFunction("setTextureAtlas", _SE(js_cocos2dx_ParticleBatchNode_setTextureAtlas));
    cls->defineFunction("initWithFile", _SE(js_cocos2dx_ParticleBatchNode_initWithFile));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_ParticleBatchNode_setBlendFunc));
    cls->defineFunction("removeAllChildrenWithCleanup", _SE(js_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_ParticleBatchNode_getBlendFunc));
    cls->defineFunction("insertChild", _SE(js_cocos2dx_ParticleBatchNode_insertChild));
    cls->defineFunction("removeChildAtIndex", _SE(js_cocos2dx_ParticleBatchNode_removeChildAtIndex));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ParticleBatchNode_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleBatchNode_create));
    cls->defineStaticFunction("createWithTexture", _SE(js_cocos2dx_ParticleBatchNode_createWithTexture));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleBatchNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleBatchNode>(cls);

    __jsb_cocos2d_ParticleBatchNode_proto = cls->getProto();
    __jsb_cocos2d_ParticleBatchNode_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ParticleBatchNode.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ParticleSystem_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSystem_class = nullptr;

static bool js_cocos2dx_ParticleSystem_getStartSizeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartSizeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartSizeVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartSizeVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartSizeVar)

static bool js_cocos2dx_ParticleSystem_getTexture(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getTexture)

static bool js_cocos2dx_ParticleSystem_isFull(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_isFull : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isFull();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_isFull : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_isFull)

static bool js_cocos2dx_ParticleSystem_getBatchNode(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getBatchNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ParticleBatchNode* result = cobj->getBatchNode();
        ok &= native_ptr_to_seval<cocos2d::ParticleBatchNode>((cocos2d::ParticleBatchNode*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getBatchNode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getBatchNode)

static bool js_cocos2dx_ParticleSystem_getStartColor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4F& result = cobj->getStartColor();
        ok &= Color4F_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartColor)

static bool js_cocos2dx_ParticleSystem_getPositionType(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getPositionType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getPositionType();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getPositionType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getPositionType)

static bool js_cocos2dx_ParticleSystem_setPosVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setPosVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setPosVar : Error processing arguments");
        cobj->setPosVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setPosVar)

static bool js_cocos2dx_ParticleSystem_getEndSpin(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndSpin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndSpin();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndSpin : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndSpin)

static bool js_cocos2dx_ParticleSystem_setRotatePerSecondVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setRotatePerSecondVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setRotatePerSecondVar : Error processing arguments");
        cobj->setRotatePerSecondVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setRotatePerSecondVar)

static bool js_cocos2dx_ParticleSystem_getStartSpinVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartSpinVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartSpinVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartSpinVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartSpinVar)

static bool js_cocos2dx_ParticleSystem_getRadialAccelVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getRadialAccelVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRadialAccelVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getRadialAccelVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getRadialAccelVar)

static bool js_cocos2dx_ParticleSystem_getEndSizeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndSizeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndSizeVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndSizeVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndSizeVar)

static bool js_cocos2dx_ParticleSystem_setTangentialAccel(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setTangentialAccel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setTangentialAccel : Error processing arguments");
        cobj->setTangentialAccel(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setTangentialAccel)

static bool js_cocos2dx_ParticleSystem_getRadialAccel(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getRadialAccel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRadialAccel();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getRadialAccel : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getRadialAccel)

static bool js_cocos2dx_ParticleSystem_setStartRadius(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartRadius : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartRadius : Error processing arguments");
        cobj->setStartRadius(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartRadius)

static bool js_cocos2dx_ParticleSystem_setRotatePerSecond(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setRotatePerSecond : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setRotatePerSecond : Error processing arguments");
        cobj->setRotatePerSecond(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setRotatePerSecond)

static bool js_cocos2dx_ParticleSystem_setEndSize(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndSize : Error processing arguments");
        cobj->setEndSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndSize)

static bool js_cocos2dx_ParticleSystem_getGravity(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getGravity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getGravity();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getGravity : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getGravity)

static bool js_cocos2dx_ParticleSystem_resumeEmissions(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_resumeEmissions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resumeEmissions();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_resumeEmissions)

static bool js_cocos2dx_ParticleSystem_getTangentialAccel(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getTangentialAccel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getTangentialAccel();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getTangentialAccel : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getTangentialAccel)

static bool js_cocos2dx_ParticleSystem_setEndRadius(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndRadius : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndRadius : Error processing arguments");
        cobj->setEndRadius(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndRadius)

static bool js_cocos2dx_ParticleSystem_getSpeed(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getSpeed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSpeed();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getSpeed : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getSpeed)

static bool js_cocos2dx_ParticleSystem_pauseEmissions(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_pauseEmissions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->pauseEmissions();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_pauseEmissions)

static bool js_cocos2dx_ParticleSystem_getAngle(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getAngle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAngle();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getAngle : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getAngle)

static bool js_cocos2dx_ParticleSystem_setEndColor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndColor : Error processing arguments");
        cobj->setEndColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndColor)

static bool js_cocos2dx_ParticleSystem_setStartSpin(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartSpin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartSpin : Error processing arguments");
        cobj->setStartSpin(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartSpin)

static bool js_cocos2dx_ParticleSystem_setDuration(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setDuration : Error processing arguments");
        cobj->setDuration(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setDuration)

static bool js_cocos2dx_ParticleSystem_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_initWithTotalParticles)

static bool js_cocos2dx_ParticleSystem_addParticles(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_addParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_addParticles : Error processing arguments");
        cobj->addParticles(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_addParticles)

static bool js_cocos2dx_ParticleSystem_setTexture(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setTexture)

static bool js_cocos2dx_ParticleSystem_getPosVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getPosVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getPosVar();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getPosVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getPosVar)

static bool js_cocos2dx_ParticleSystem_updateWithNoTime(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_updateWithNoTime : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateWithNoTime();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_updateWithNoTime)

static bool js_cocos2dx_ParticleSystem_isBlendAdditive(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_isBlendAdditive : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isBlendAdditive();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_isBlendAdditive : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_isBlendAdditive)

static bool js_cocos2dx_ParticleSystem_getSpeedVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getSpeedVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSpeedVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getSpeedVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getSpeedVar)

static bool js_cocos2dx_ParticleSystem_setPositionType(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setPositionType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ParticleSystem::PositionType arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setPositionType : Error processing arguments");
        cobj->setPositionType(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setPositionType)

static bool js_cocos2dx_ParticleSystem_stopSystem(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_stopSystem : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stopSystem();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_stopSystem)

static bool js_cocos2dx_ParticleSystem_getSourcePosition(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getSourcePosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getSourcePosition();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getSourcePosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getSourcePosition)

static bool js_cocos2dx_ParticleSystem_setLifeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setLifeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setLifeVar : Error processing arguments");
        cobj->setLifeVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setLifeVar)

static bool js_cocos2dx_ParticleSystem_setTotalParticles(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setTotalParticles : Error processing arguments");
        cobj->setTotalParticles(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setTotalParticles)

static bool js_cocos2dx_ParticleSystem_setEndColorVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndColorVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndColorVar : Error processing arguments");
        cobj->setEndColorVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndColorVar)

static bool js_cocos2dx_ParticleSystem_getAtlasIndex(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getAtlasIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getAtlasIndex();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getAtlasIndex : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getAtlasIndex)

static bool js_cocos2dx_ParticleSystem_getStartSize(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartSize();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartSize)

static bool js_cocos2dx_ParticleSystem_setStartSpinVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartSpinVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartSpinVar : Error processing arguments");
        cobj->setStartSpinVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartSpinVar)

static bool js_cocos2dx_ParticleSystem_resetSystem(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_resetSystem : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resetSystem();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_resetSystem)

static bool js_cocos2dx_ParticleSystem_setAtlasIndex(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setAtlasIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setAtlasIndex : Error processing arguments");
        cobj->setAtlasIndex(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setAtlasIndex)

static bool js_cocos2dx_ParticleSystem_setTangentialAccelVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setTangentialAccelVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setTangentialAccelVar : Error processing arguments");
        cobj->setTangentialAccelVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setTangentialAccelVar)

static bool js_cocos2dx_ParticleSystem_setEndRadiusVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndRadiusVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndRadiusVar : Error processing arguments");
        cobj->setEndRadiusVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndRadiusVar)

static bool js_cocos2dx_ParticleSystem_getEndRadius(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndRadius : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndRadius();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndRadius : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndRadius)

static bool js_cocos2dx_ParticleSystem_isActive(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_isActive : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isActive();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_isActive : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_isActive)

static bool js_cocos2dx_ParticleSystem_setRadialAccelVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setRadialAccelVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setRadialAccelVar : Error processing arguments");
        cobj->setRadialAccelVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setRadialAccelVar)

static bool js_cocos2dx_ParticleSystem_setStartSize(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartSize : Error processing arguments");
        cobj->setStartSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartSize)

static bool js_cocos2dx_ParticleSystem_setSpeed(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setSpeed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setSpeed : Error processing arguments");
        cobj->setSpeed(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setSpeed)

static bool js_cocos2dx_ParticleSystem_getStartSpin(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartSpin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartSpin();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartSpin : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartSpin)

static bool js_cocos2dx_ParticleSystem_getResourceFile(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getResourceFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getResourceFile();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getResourceFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getResourceFile)

static bool js_cocos2dx_ParticleSystem_getRotatePerSecond(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getRotatePerSecond : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRotatePerSecond();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getRotatePerSecond : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getRotatePerSecond)

static bool js_cocos2dx_ParticleSystem_setEmitterMode(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEmitterMode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ParticleSystem::Mode arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEmitterMode : Error processing arguments");
        cobj->setEmitterMode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEmitterMode)

static bool js_cocos2dx_ParticleSystem_getDuration(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getDuration();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getDuration)

static bool js_cocos2dx_ParticleSystem_setSourcePosition(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setSourcePosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setSourcePosition : Error processing arguments");
        cobj->setSourcePosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setSourcePosition)

static bool js_cocos2dx_ParticleSystem_stop(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_stop : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stop();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_stop)

static bool js_cocos2dx_ParticleSystem_updateParticleQuads(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_updateParticleQuads : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateParticleQuads();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_updateParticleQuads)

static bool js_cocos2dx_ParticleSystem_getEndSpinVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndSpinVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndSpinVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndSpinVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndSpinVar)

static bool js_cocos2dx_ParticleSystem_setBlendAdditive(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setBlendAdditive : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setBlendAdditive : Error processing arguments");
        cobj->setBlendAdditive(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setBlendAdditive)

static bool js_cocos2dx_ParticleSystem_setLife(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setLife : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setLife : Error processing arguments");
        cobj->setLife(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setLife)

static bool js_cocos2dx_ParticleSystem_setAngleVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setAngleVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setAngleVar : Error processing arguments");
        cobj->setAngleVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setAngleVar)

static bool js_cocos2dx_ParticleSystem_setRotationIsDir(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setRotationIsDir : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setRotationIsDir : Error processing arguments");
        cobj->setRotationIsDir(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setRotationIsDir)

static bool js_cocos2dx_ParticleSystem_start(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_start : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->start();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_start)

static bool js_cocos2dx_ParticleSystem_setEndSizeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndSizeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndSizeVar : Error processing arguments");
        cobj->setEndSizeVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndSizeVar)

static bool js_cocos2dx_ParticleSystem_setAngle(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setAngle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setAngle : Error processing arguments");
        cobj->setAngle(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setAngle)

static bool js_cocos2dx_ParticleSystem_setBatchNode(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setBatchNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ParticleBatchNode* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setBatchNode : Error processing arguments");
        cobj->setBatchNode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setBatchNode)

static bool js_cocos2dx_ParticleSystem_getTangentialAccelVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getTangentialAccelVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getTangentialAccelVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getTangentialAccelVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getTangentialAccelVar)

static bool js_cocos2dx_ParticleSystem_getEmitterMode(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEmitterMode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getEmitterMode();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEmitterMode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEmitterMode)

static bool js_cocos2dx_ParticleSystem_setEndSpinVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndSpinVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndSpinVar : Error processing arguments");
        cobj->setEndSpinVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndSpinVar)

static bool js_cocos2dx_ParticleSystem_initWithFile(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_initWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithFile : Error processing arguments");
        bool result = cobj->initWithFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_initWithFile)

static bool js_cocos2dx_ParticleSystem_getAngleVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getAngleVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAngleVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getAngleVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getAngleVar)

static bool js_cocos2dx_ParticleSystem_setStartColor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartColor : Error processing arguments");
        cobj->setStartColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartColor)

static bool js_cocos2dx_ParticleSystem_getRotatePerSecondVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getRotatePerSecondVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRotatePerSecondVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getRotatePerSecondVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getRotatePerSecondVar)

static bool js_cocos2dx_ParticleSystem_getEndSize(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndSize();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndSize)

static bool js_cocos2dx_ParticleSystem_getLife(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getLife : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getLife();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getLife : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getLife)

static bool js_cocos2dx_ParticleSystem_isPaused(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_isPaused : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isPaused();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_isPaused : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_isPaused)

static bool js_cocos2dx_ParticleSystem_setSpeedVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setSpeedVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setSpeedVar : Error processing arguments");
        cobj->setSpeedVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setSpeedVar)

static bool js_cocos2dx_ParticleSystem_setAutoRemoveOnFinish(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setAutoRemoveOnFinish : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setAutoRemoveOnFinish : Error processing arguments");
        cobj->setAutoRemoveOnFinish(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setAutoRemoveOnFinish)

static bool js_cocos2dx_ParticleSystem_setGravity(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setGravity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setGravity : Error processing arguments");
        cobj->setGravity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setGravity)

static bool js_cocos2dx_ParticleSystem_postStep(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_postStep : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->postStep();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_postStep)

static bool js_cocos2dx_ParticleSystem_setEmissionRate(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEmissionRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEmissionRate : Error processing arguments");
        cobj->setEmissionRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEmissionRate)

static bool js_cocos2dx_ParticleSystem_getEndColorVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndColorVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4F& result = cobj->getEndColorVar();
        ok &= Color4F_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndColorVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndColorVar)

static bool js_cocos2dx_ParticleSystem_getRotationIsDir(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getRotationIsDir : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->getRotationIsDir();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getRotationIsDir : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getRotationIsDir)

static bool js_cocos2dx_ParticleSystem_getEmissionRate(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEmissionRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEmissionRate();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEmissionRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEmissionRate)

static bool js_cocos2dx_ParticleSystem_getEndColor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4F& result = cobj->getEndColor();
        ok &= Color4F_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndColor)

static bool js_cocos2dx_ParticleSystem_getLifeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getLifeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getLifeVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getLifeVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getLifeVar)

static bool js_cocos2dx_ParticleSystem_setStartSizeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartSizeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartSizeVar : Error processing arguments");
        cobj->setStartSizeVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartSizeVar)

static bool js_cocos2dx_ParticleSystem_getStartRadius(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartRadius : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartRadius();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartRadius : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartRadius)

static bool js_cocos2dx_ParticleSystem_getParticleCount(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getParticleCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getParticleCount();
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getParticleCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getParticleCount)

static bool js_cocos2dx_ParticleSystem_getStartRadiusVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartRadiusVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartRadiusVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartRadiusVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartRadiusVar)

static bool js_cocos2dx_ParticleSystem_getBlendFunc(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getBlendFunc)

static bool js_cocos2dx_ParticleSystem_setStartColorVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartColorVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartColorVar : Error processing arguments");
        cobj->setStartColorVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartColorVar)

static bool js_cocos2dx_ParticleSystem_setEndSpin(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndSpin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndSpin : Error processing arguments");
        cobj->setEndSpin(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndSpin)

static bool js_cocos2dx_ParticleSystem_setRadialAccel(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setRadialAccel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setRadialAccel : Error processing arguments");
        cobj->setRadialAccel(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setRadialAccel)

static bool js_cocos2dx_ParticleSystem_initWithDictionary(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_ParticleSystem_initWithDictionary : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::ValueMap arg0;
            ok &= seval_to_ccvaluemap(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDictionary(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithDictionary : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::ValueMap arg0;
            ok &= seval_to_ccvaluemap(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDictionary(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithDictionary : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_initWithDictionary)

static bool js_cocos2dx_ParticleSystem_isAutoRemoveOnFinish(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_isAutoRemoveOnFinish : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isAutoRemoveOnFinish();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_isAutoRemoveOnFinish : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_isAutoRemoveOnFinish)

static bool js_cocos2dx_ParticleSystem_getTotalParticles(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getTotalParticles();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getTotalParticles)

static bool js_cocos2dx_ParticleSystem_setStartRadiusVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartRadiusVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartRadiusVar : Error processing arguments");
        cobj->setStartRadiusVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartRadiusVar)

static bool js_cocos2dx_ParticleSystem_setBlendFunc(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setBlendFunc)

static bool js_cocos2dx_ParticleSystem_getEndRadiusVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndRadiusVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndRadiusVar();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndRadiusVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndRadiusVar)

static bool js_cocos2dx_ParticleSystem_getStartColorVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartColorVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4F& result = cobj->getStartColorVar();
        ok &= Color4F_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartColorVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartColorVar)

static bool js_cocos2dx_ParticleSystem_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_create : Error processing arguments");
        auto result = cocos2d::ParticleSystem::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSystem_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_create)

static bool js_cocos2dx_ParticleSystem_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSystem::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSystem_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSystem_finalize)

static bool js_cocos2dx_ParticleSystem_constructor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = new (std::nothrow) cocos2d::ParticleSystem();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSystem_constructor, __jsb_cocos2d_ParticleSystem_class, js_cocos2d_ParticleSystem_finalize)

static bool js_cocos2dx_ParticleSystem_ctor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = new (std::nothrow) cocos2d::ParticleSystem();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ParticleSystem_ctor, __jsb_cocos2d_ParticleSystem_class, js_cocos2d_ParticleSystem_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_ParticleSystem_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleSystem)", s.nativeThisObject());
        cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSystem_finalize)

bool js_register_cocos2dx_ParticleSystem(se::Object* obj)
{
    auto cls = se::Class::create("_ParticleSystem", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_ParticleSystem_constructor));

    cls->defineFunction("getStartSizeVar", _SE(js_cocos2dx_ParticleSystem_getStartSizeVar));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_ParticleSystem_getTexture));
    cls->defineFunction("isFull", _SE(js_cocos2dx_ParticleSystem_isFull));
    cls->defineFunction("getBatchNode", _SE(js_cocos2dx_ParticleSystem_getBatchNode));
    cls->defineFunction("getStartColor", _SE(js_cocos2dx_ParticleSystem_getStartColor));
    cls->defineFunction("getPositionType", _SE(js_cocos2dx_ParticleSystem_getPositionType));
    cls->defineFunction("setPosVar", _SE(js_cocos2dx_ParticleSystem_setPosVar));
    cls->defineFunction("getEndSpin", _SE(js_cocos2dx_ParticleSystem_getEndSpin));
    cls->defineFunction("setRotatePerSecondVar", _SE(js_cocos2dx_ParticleSystem_setRotatePerSecondVar));
    cls->defineFunction("getStartSpinVar", _SE(js_cocos2dx_ParticleSystem_getStartSpinVar));
    cls->defineFunction("getRadialAccelVar", _SE(js_cocos2dx_ParticleSystem_getRadialAccelVar));
    cls->defineFunction("getEndSizeVar", _SE(js_cocos2dx_ParticleSystem_getEndSizeVar));
    cls->defineFunction("setTangentialAccel", _SE(js_cocos2dx_ParticleSystem_setTangentialAccel));
    cls->defineFunction("getRadialAccel", _SE(js_cocos2dx_ParticleSystem_getRadialAccel));
    cls->defineFunction("setStartRadius", _SE(js_cocos2dx_ParticleSystem_setStartRadius));
    cls->defineFunction("setRotatePerSecond", _SE(js_cocos2dx_ParticleSystem_setRotatePerSecond));
    cls->defineFunction("setEndSize", _SE(js_cocos2dx_ParticleSystem_setEndSize));
    cls->defineFunction("getGravity", _SE(js_cocos2dx_ParticleSystem_getGravity));
    cls->defineFunction("resumeEmissions", _SE(js_cocos2dx_ParticleSystem_resumeEmissions));
    cls->defineFunction("getTangentialAccel", _SE(js_cocos2dx_ParticleSystem_getTangentialAccel));
    cls->defineFunction("setEndRadius", _SE(js_cocos2dx_ParticleSystem_setEndRadius));
    cls->defineFunction("getSpeed", _SE(js_cocos2dx_ParticleSystem_getSpeed));
    cls->defineFunction("pauseEmissions", _SE(js_cocos2dx_ParticleSystem_pauseEmissions));
    cls->defineFunction("getAngle", _SE(js_cocos2dx_ParticleSystem_getAngle));
    cls->defineFunction("setEndColor", _SE(js_cocos2dx_ParticleSystem_setEndColor));
    cls->defineFunction("setStartSpin", _SE(js_cocos2dx_ParticleSystem_setStartSpin));
    cls->defineFunction("setDuration", _SE(js_cocos2dx_ParticleSystem_setDuration));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleSystem_initWithTotalParticles));
    cls->defineFunction("addParticles", _SE(js_cocos2dx_ParticleSystem_addParticles));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_ParticleSystem_setTexture));
    cls->defineFunction("getPosVar", _SE(js_cocos2dx_ParticleSystem_getPosVar));
    cls->defineFunction("updateWithNoTime", _SE(js_cocos2dx_ParticleSystem_updateWithNoTime));
    cls->defineFunction("isBlendAdditive", _SE(js_cocos2dx_ParticleSystem_isBlendAdditive));
    cls->defineFunction("getSpeedVar", _SE(js_cocos2dx_ParticleSystem_getSpeedVar));
    cls->defineFunction("setPositionType", _SE(js_cocos2dx_ParticleSystem_setPositionType));
    cls->defineFunction("stopSystem", _SE(js_cocos2dx_ParticleSystem_stopSystem));
    cls->defineFunction("getSourcePosition", _SE(js_cocos2dx_ParticleSystem_getSourcePosition));
    cls->defineFunction("setLifeVar", _SE(js_cocos2dx_ParticleSystem_setLifeVar));
    cls->defineFunction("setTotalParticles", _SE(js_cocos2dx_ParticleSystem_setTotalParticles));
    cls->defineFunction("setEndColorVar", _SE(js_cocos2dx_ParticleSystem_setEndColorVar));
    cls->defineFunction("getAtlasIndex", _SE(js_cocos2dx_ParticleSystem_getAtlasIndex));
    cls->defineFunction("getStartSize", _SE(js_cocos2dx_ParticleSystem_getStartSize));
    cls->defineFunction("setStartSpinVar", _SE(js_cocos2dx_ParticleSystem_setStartSpinVar));
    cls->defineFunction("resetSystem", _SE(js_cocos2dx_ParticleSystem_resetSystem));
    cls->defineFunction("setAtlasIndex", _SE(js_cocos2dx_ParticleSystem_setAtlasIndex));
    cls->defineFunction("setTangentialAccelVar", _SE(js_cocos2dx_ParticleSystem_setTangentialAccelVar));
    cls->defineFunction("setEndRadiusVar", _SE(js_cocos2dx_ParticleSystem_setEndRadiusVar));
    cls->defineFunction("getEndRadius", _SE(js_cocos2dx_ParticleSystem_getEndRadius));
    cls->defineFunction("isActive", _SE(js_cocos2dx_ParticleSystem_isActive));
    cls->defineFunction("setRadialAccelVar", _SE(js_cocos2dx_ParticleSystem_setRadialAccelVar));
    cls->defineFunction("setStartSize", _SE(js_cocos2dx_ParticleSystem_setStartSize));
    cls->defineFunction("setSpeed", _SE(js_cocos2dx_ParticleSystem_setSpeed));
    cls->defineFunction("getStartSpin", _SE(js_cocos2dx_ParticleSystem_getStartSpin));
    cls->defineFunction("getResourceFile", _SE(js_cocos2dx_ParticleSystem_getResourceFile));
    cls->defineFunction("getRotatePerSecond", _SE(js_cocos2dx_ParticleSystem_getRotatePerSecond));
    cls->defineFunction("setEmitterMode", _SE(js_cocos2dx_ParticleSystem_setEmitterMode));
    cls->defineFunction("getDuration", _SE(js_cocos2dx_ParticleSystem_getDuration));
    cls->defineFunction("setSourcePosition", _SE(js_cocos2dx_ParticleSystem_setSourcePosition));
    cls->defineFunction("stop", _SE(js_cocos2dx_ParticleSystem_stop));
    cls->defineFunction("updateParticleQuads", _SE(js_cocos2dx_ParticleSystem_updateParticleQuads));
    cls->defineFunction("getEndSpinVar", _SE(js_cocos2dx_ParticleSystem_getEndSpinVar));
    cls->defineFunction("setBlendAdditive", _SE(js_cocos2dx_ParticleSystem_setBlendAdditive));
    cls->defineFunction("setLife", _SE(js_cocos2dx_ParticleSystem_setLife));
    cls->defineFunction("setAngleVar", _SE(js_cocos2dx_ParticleSystem_setAngleVar));
    cls->defineFunction("setRotationIsDir", _SE(js_cocos2dx_ParticleSystem_setRotationIsDir));
    cls->defineFunction("start", _SE(js_cocos2dx_ParticleSystem_start));
    cls->defineFunction("setEndSizeVar", _SE(js_cocos2dx_ParticleSystem_setEndSizeVar));
    cls->defineFunction("setAngle", _SE(js_cocos2dx_ParticleSystem_setAngle));
    cls->defineFunction("setBatchNode", _SE(js_cocos2dx_ParticleSystem_setBatchNode));
    cls->defineFunction("getTangentialAccelVar", _SE(js_cocos2dx_ParticleSystem_getTangentialAccelVar));
    cls->defineFunction("getEmitterMode", _SE(js_cocos2dx_ParticleSystem_getEmitterMode));
    cls->defineFunction("setEndSpinVar", _SE(js_cocos2dx_ParticleSystem_setEndSpinVar));
    cls->defineFunction("initWithFile", _SE(js_cocos2dx_ParticleSystem_initWithFile));
    cls->defineFunction("getAngleVar", _SE(js_cocos2dx_ParticleSystem_getAngleVar));
    cls->defineFunction("setStartColor", _SE(js_cocos2dx_ParticleSystem_setStartColor));
    cls->defineFunction("getRotatePerSecondVar", _SE(js_cocos2dx_ParticleSystem_getRotatePerSecondVar));
    cls->defineFunction("getEndSize", _SE(js_cocos2dx_ParticleSystem_getEndSize));
    cls->defineFunction("getLife", _SE(js_cocos2dx_ParticleSystem_getLife));
    cls->defineFunction("isPaused", _SE(js_cocos2dx_ParticleSystem_isPaused));
    cls->defineFunction("setSpeedVar", _SE(js_cocos2dx_ParticleSystem_setSpeedVar));
    cls->defineFunction("setAutoRemoveOnFinish", _SE(js_cocos2dx_ParticleSystem_setAutoRemoveOnFinish));
    cls->defineFunction("setGravity", _SE(js_cocos2dx_ParticleSystem_setGravity));
    cls->defineFunction("postStep", _SE(js_cocos2dx_ParticleSystem_postStep));
    cls->defineFunction("setEmissionRate", _SE(js_cocos2dx_ParticleSystem_setEmissionRate));
    cls->defineFunction("getEndColorVar", _SE(js_cocos2dx_ParticleSystem_getEndColorVar));
    cls->defineFunction("getRotationIsDir", _SE(js_cocos2dx_ParticleSystem_getRotationIsDir));
    cls->defineFunction("getEmissionRate", _SE(js_cocos2dx_ParticleSystem_getEmissionRate));
    cls->defineFunction("getEndColor", _SE(js_cocos2dx_ParticleSystem_getEndColor));
    cls->defineFunction("getLifeVar", _SE(js_cocos2dx_ParticleSystem_getLifeVar));
    cls->defineFunction("setStartSizeVar", _SE(js_cocos2dx_ParticleSystem_setStartSizeVar));
    cls->defineFunction("getStartRadius", _SE(js_cocos2dx_ParticleSystem_getStartRadius));
    cls->defineFunction("getParticleCount", _SE(js_cocos2dx_ParticleSystem_getParticleCount));
    cls->defineFunction("getStartRadiusVar", _SE(js_cocos2dx_ParticleSystem_getStartRadiusVar));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_ParticleSystem_getBlendFunc));
    cls->defineFunction("setStartColorVar", _SE(js_cocos2dx_ParticleSystem_setStartColorVar));
    cls->defineFunction("setEndSpin", _SE(js_cocos2dx_ParticleSystem_setEndSpin));
    cls->defineFunction("setRadialAccel", _SE(js_cocos2dx_ParticleSystem_setRadialAccel));
    cls->defineFunction("initWithDictionary", _SE(js_cocos2dx_ParticleSystem_initWithDictionary));
    cls->defineFunction("isAutoRemoveOnFinish", _SE(js_cocos2dx_ParticleSystem_isAutoRemoveOnFinish));
    cls->defineFunction("getTotalParticles", _SE(js_cocos2dx_ParticleSystem_getTotalParticles));
    cls->defineFunction("setStartRadiusVar", _SE(js_cocos2dx_ParticleSystem_setStartRadiusVar));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_ParticleSystem_setBlendFunc));
    cls->defineFunction("getEndRadiusVar", _SE(js_cocos2dx_ParticleSystem_getEndRadiusVar));
    cls->defineFunction("getStartColorVar", _SE(js_cocos2dx_ParticleSystem_getStartColorVar));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ParticleSystem_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSystem_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSystem_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleSystem_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSystem>(cls);

    __jsb_cocos2d_ParticleSystem_proto = cls->getProto();
    __jsb_cocos2d_ParticleSystem_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc._ParticleSystem.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ParticleSystemQuad_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSystemQuad_class = nullptr;

static bool js_cocos2dx_ParticleSystemQuad_setDisplayFrame(se::State& s)
{
    cocos2d::ParticleSystemQuad* cobj = (cocos2d::ParticleSystemQuad*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystemQuad_setDisplayFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_setDisplayFrame : Error processing arguments");
        cobj->setDisplayFrame(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystemQuad_setDisplayFrame)

static bool js_cocos2dx_ParticleSystemQuad_setTextureWithRect(se::State& s)
{
    cocos2d::ParticleSystemQuad* cobj = (cocos2d::ParticleSystemQuad*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystemQuad_setTextureWithRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Texture2D* arg0 = nullptr;
        cocos2d::Rect arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_Rect(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_setTextureWithRect : Error processing arguments");
        cobj->setTextureWithRect(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystemQuad_setTextureWithRect)

static bool js_cocos2dx_ParticleSystemQuad_listenRendererRecreated(se::State& s)
{
    cocos2d::ParticleSystemQuad* cobj = (cocos2d::ParticleSystemQuad*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystemQuad_listenRendererRecreated : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventCustom* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_listenRendererRecreated : Error processing arguments");
        cobj->listenRendererRecreated(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystemQuad_listenRendererRecreated)

static bool js_cocos2dx_ParticleSystemQuad_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::ParticleSystemQuad* result = cocos2d::ParticleSystemQuad::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::ParticleSystemQuad>((cocos2d::ParticleSystemQuad*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 0) {
            cocos2d::ParticleSystemQuad* result = cocos2d::ParticleSystemQuad::create();
            ok &= native_ptr_to_seval<cocos2d::ParticleSystemQuad>((cocos2d::ParticleSystemQuad*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 1) {
            cocos2d::ValueMap arg0;
            ok &= seval_to_ccvaluemap(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::ParticleSystemQuad* result = cocos2d::ParticleSystemQuad::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::ParticleSystemQuad>((cocos2d::ParticleSystemQuad*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystemQuad_create)

static bool js_cocos2dx_ParticleSystemQuad_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSystemQuad::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSystemQuad_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystemQuad_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSystemQuad_finalize)

static bool js_cocos2dx_ParticleSystemQuad_constructor(se::State& s)
{
    cocos2d::ParticleSystemQuad* cobj = new (std::nothrow) cocos2d::ParticleSystemQuad();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSystemQuad_constructor, __jsb_cocos2d_ParticleSystemQuad_class, js_cocos2d_ParticleSystemQuad_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystem_proto;

bool js_cocos2d_ParticleSystemQuad_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleSystemQuad)", s.nativeThisObject());
        cocos2d::ParticleSystemQuad* cobj = (cocos2d::ParticleSystemQuad*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSystemQuad_finalize)

bool js_register_cocos2dx_ParticleSystemQuad(se::Object* obj)
{
    auto cls = se::Class::create("ParticleSystem", obj, __jsb_cocos2d_ParticleSystem_proto, _SE(js_cocos2dx_ParticleSystemQuad_constructor));

    cls->defineFunction("setDisplayFrame", _SE(js_cocos2dx_ParticleSystemQuad_setDisplayFrame));
    cls->defineFunction("setTextureWithRect", _SE(js_cocos2dx_ParticleSystemQuad_setTextureWithRect));
    cls->defineFunction("listenRendererRecreated", _SE(js_cocos2dx_ParticleSystemQuad_listenRendererRecreated));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSystemQuad_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSystemQuad_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleSystemQuad_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSystemQuad>(cls);

    __jsb_cocos2d_ParticleSystemQuad_proto = cls->getProto();
    __jsb_cocos2d_ParticleSystemQuad_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleFire_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleFire_class = nullptr;

static bool js_cocos2dx_ParticleFire_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleFire::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFire_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFire_create)

static bool js_cocos2dx_ParticleFire_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFire_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleFire::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFire_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFire_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleFire_finalize)

static bool js_cocos2dx_ParticleFire_constructor(se::State& s)
{
    cocos2d::ParticleFire* cobj = new (std::nothrow) cocos2d::ParticleFire();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleFire_constructor, __jsb_cocos2d_ParticleFire_class, js_cocos2d_ParticleFire_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

bool js_cocos2d_ParticleFire_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleFire)", s.nativeThisObject());
        cocos2d::ParticleFire* cobj = (cocos2d::ParticleFire*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleFire_finalize)

bool js_register_cocos2dx_ParticleFire(se::Object* obj)
{
    auto cls = se::Class::create("ParticleFire", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleFire_constructor));

    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleFire_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleFire_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleFire_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleFire>(cls);

    __jsb_cocos2d_ParticleFire_proto = cls->getProto();
    __jsb_cocos2d_ParticleFire_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleFireworks_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleFireworks_class = nullptr;

static bool js_cocos2dx_ParticleFireworks_init(se::State& s)
{
    cocos2d::ParticleFireworks* cobj = (cocos2d::ParticleFireworks*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleFireworks_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFireworks_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFireworks_init)

static bool js_cocos2dx_ParticleFireworks_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleFireworks* cobj = (cocos2d::ParticleFireworks*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleFireworks_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFireworks_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFireworks_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFireworks_initWithTotalParticles)

static bool js_cocos2dx_ParticleFireworks_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleFireworks::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFireworks_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFireworks_create)

static bool js_cocos2dx_ParticleFireworks_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFireworks_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleFireworks::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFireworks_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFireworks_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleFireworks_finalize)

static bool js_cocos2dx_ParticleFireworks_constructor(se::State& s)
{
    cocos2d::ParticleFireworks* cobj = new (std::nothrow) cocos2d::ParticleFireworks();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleFireworks_constructor, __jsb_cocos2d_ParticleFireworks_class, js_cocos2d_ParticleFireworks_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

bool js_cocos2d_ParticleFireworks_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleFireworks)", s.nativeThisObject());
        cocos2d::ParticleFireworks* cobj = (cocos2d::ParticleFireworks*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleFireworks_finalize)

bool js_register_cocos2dx_ParticleFireworks(se::Object* obj)
{
    auto cls = se::Class::create("ParticleFireworks", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleFireworks_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleFireworks_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleFireworks_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleFireworks_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleFireworks_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleFireworks_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleFireworks>(cls);

    __jsb_cocos2d_ParticleFireworks_proto = cls->getProto();
    __jsb_cocos2d_ParticleFireworks_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleSun_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSun_class = nullptr;

static bool js_cocos2dx_ParticleSun_init(se::State& s)
{
    cocos2d::ParticleSun* cobj = (cocos2d::ParticleSun*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSun_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSun_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSun_init)

static bool js_cocos2dx_ParticleSun_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleSun* cobj = (cocos2d::ParticleSun*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSun_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSun_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSun_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSun_initWithTotalParticles)

static bool js_cocos2dx_ParticleSun_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleSun::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSun_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSun_create)

static bool js_cocos2dx_ParticleSun_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSun_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSun::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSun_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSun_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSun_finalize)

static bool js_cocos2dx_ParticleSun_constructor(se::State& s)
{
    cocos2d::ParticleSun* cobj = new (std::nothrow) cocos2d::ParticleSun();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSun_constructor, __jsb_cocos2d_ParticleSun_class, js_cocos2d_ParticleSun_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

bool js_cocos2d_ParticleSun_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleSun)", s.nativeThisObject());
        cocos2d::ParticleSun* cobj = (cocos2d::ParticleSun*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSun_finalize)

bool js_register_cocos2dx_ParticleSun(se::Object* obj)
{
    auto cls = se::Class::create("ParticleSun", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleSun_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleSun_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleSun_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSun_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSun_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleSun_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSun>(cls);

    __jsb_cocos2d_ParticleSun_proto = cls->getProto();
    __jsb_cocos2d_ParticleSun_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleGalaxy_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleGalaxy_class = nullptr;

static bool js_cocos2dx_ParticleGalaxy_init(se::State& s)
{
    cocos2d::ParticleGalaxy* cobj = (cocos2d::ParticleGalaxy*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleGalaxy_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleGalaxy_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleGalaxy_init)

static bool js_cocos2dx_ParticleGalaxy_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleGalaxy* cobj = (cocos2d::ParticleGalaxy*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleGalaxy_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleGalaxy_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleGalaxy_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleGalaxy_initWithTotalParticles)

static bool js_cocos2dx_ParticleGalaxy_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleGalaxy::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleGalaxy_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleGalaxy_create)

static bool js_cocos2dx_ParticleGalaxy_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleGalaxy_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleGalaxy::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleGalaxy_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleGalaxy_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleGalaxy_finalize)

static bool js_cocos2dx_ParticleGalaxy_constructor(se::State& s)
{
    cocos2d::ParticleGalaxy* cobj = new (std::nothrow) cocos2d::ParticleGalaxy();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleGalaxy_constructor, __jsb_cocos2d_ParticleGalaxy_class, js_cocos2d_ParticleGalaxy_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

bool js_cocos2d_ParticleGalaxy_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleGalaxy)", s.nativeThisObject());
        cocos2d::ParticleGalaxy* cobj = (cocos2d::ParticleGalaxy*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleGalaxy_finalize)

bool js_register_cocos2dx_ParticleGalaxy(se::Object* obj)
{
    auto cls = se::Class::create("ParticleGalaxy", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleGalaxy_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleGalaxy_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleGalaxy_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleGalaxy_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleGalaxy_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleGalaxy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleGalaxy>(cls);

    __jsb_cocos2d_ParticleGalaxy_proto = cls->getProto();
    __jsb_cocos2d_ParticleGalaxy_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleFlower_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleFlower_class = nullptr;

static bool js_cocos2dx_ParticleFlower_init(se::State& s)
{
    cocos2d::ParticleFlower* cobj = (cocos2d::ParticleFlower*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleFlower_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFlower_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFlower_init)

static bool js_cocos2dx_ParticleFlower_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleFlower* cobj = (cocos2d::ParticleFlower*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleFlower_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFlower_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFlower_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFlower_initWithTotalParticles)

static bool js_cocos2dx_ParticleFlower_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleFlower::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFlower_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFlower_create)

static bool js_cocos2dx_ParticleFlower_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFlower_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleFlower::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFlower_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFlower_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleFlower_finalize)

static bool js_cocos2dx_ParticleFlower_constructor(se::State& s)
{
    cocos2d::ParticleFlower* cobj = new (std::nothrow) cocos2d::ParticleFlower();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleFlower_constructor, __jsb_cocos2d_ParticleFlower_class, js_cocos2d_ParticleFlower_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

bool js_cocos2d_ParticleFlower_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleFlower)", s.nativeThisObject());
        cocos2d::ParticleFlower* cobj = (cocos2d::ParticleFlower*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleFlower_finalize)

bool js_register_cocos2dx_ParticleFlower(se::Object* obj)
{
    auto cls = se::Class::create("ParticleFlower", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleFlower_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleFlower_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleFlower_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleFlower_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleFlower_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleFlower_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleFlower>(cls);

    __jsb_cocos2d_ParticleFlower_proto = cls->getProto();
    __jsb_cocos2d_ParticleFlower_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleMeteor_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleMeteor_class = nullptr;

static bool js_cocos2dx_ParticleMeteor_init(se::State& s)
{
    cocos2d::ParticleMeteor* cobj = (cocos2d::ParticleMeteor*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleMeteor_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleMeteor_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleMeteor_init)

static bool js_cocos2dx_ParticleMeteor_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleMeteor* cobj = (cocos2d::ParticleMeteor*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleMeteor_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleMeteor_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleMeteor_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleMeteor_initWithTotalParticles)

static bool js_cocos2dx_ParticleMeteor_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleMeteor::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleMeteor_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleMeteor_create)

static bool js_cocos2dx_ParticleMeteor_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleMeteor_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleMeteor::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleMeteor_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleMeteor_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleMeteor_finalize)

static bool js_cocos2dx_ParticleMeteor_constructor(se::State& s)
{
    cocos2d::ParticleMeteor* cobj = new (std::nothrow) cocos2d::ParticleMeteor();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleMeteor_constructor, __jsb_cocos2d_ParticleMeteor_class, js_cocos2d_ParticleMeteor_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

bool js_cocos2d_ParticleMeteor_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleMeteor)", s.nativeThisObject());
        cocos2d::ParticleMeteor* cobj = (cocos2d::ParticleMeteor*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleMeteor_finalize)

bool js_register_cocos2dx_ParticleMeteor(se::Object* obj)
{
    auto cls = se::Class::create("ParticleMeteor", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleMeteor_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleMeteor_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleMeteor_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleMeteor_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleMeteor_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleMeteor_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleMeteor>(cls);

    __jsb_cocos2d_ParticleMeteor_proto = cls->getProto();
    __jsb_cocos2d_ParticleMeteor_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleSpiral_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSpiral_class = nullptr;

static bool js_cocos2dx_ParticleSpiral_init(se::State& s)
{
    cocos2d::ParticleSpiral* cobj = (cocos2d::ParticleSpiral*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSpiral_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSpiral_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSpiral_init)

static bool js_cocos2dx_ParticleSpiral_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleSpiral* cobj = (cocos2d::ParticleSpiral*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSpiral_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSpiral_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSpiral_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSpiral_initWithTotalParticles)

static bool js_cocos2dx_ParticleSpiral_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleSpiral::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSpiral_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSpiral_create)

static bool js_cocos2dx_ParticleSpiral_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSpiral_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSpiral::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSpiral_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSpiral_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSpiral_finalize)

static bool js_cocos2dx_ParticleSpiral_constructor(se::State& s)
{
    cocos2d::ParticleSpiral* cobj = new (std::nothrow) cocos2d::ParticleSpiral();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSpiral_constructor, __jsb_cocos2d_ParticleSpiral_class, js_cocos2d_ParticleSpiral_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

bool js_cocos2d_ParticleSpiral_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleSpiral)", s.nativeThisObject());
        cocos2d::ParticleSpiral* cobj = (cocos2d::ParticleSpiral*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSpiral_finalize)

bool js_register_cocos2dx_ParticleSpiral(se::Object* obj)
{
    auto cls = se::Class::create("ParticleSpiral", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleSpiral_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleSpiral_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleSpiral_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSpiral_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSpiral_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleSpiral_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSpiral>(cls);

    __jsb_cocos2d_ParticleSpiral_proto = cls->getProto();
    __jsb_cocos2d_ParticleSpiral_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleExplosion_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleExplosion_class = nullptr;

static bool js_cocos2dx_ParticleExplosion_init(se::State& s)
{
    cocos2d::ParticleExplosion* cobj = (cocos2d::ParticleExplosion*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleExplosion_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleExplosion_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleExplosion_init)

static bool js_cocos2dx_ParticleExplosion_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleExplosion* cobj = (cocos2d::ParticleExplosion*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleExplosion_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleExplosion_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleExplosion_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleExplosion_initWithTotalParticles)

static bool js_cocos2dx_ParticleExplosion_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleExplosion::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleExplosion_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleExplosion_create)

static bool js_cocos2dx_ParticleExplosion_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleExplosion_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleExplosion::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleExplosion_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleExplosion_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleExplosion_finalize)

static bool js_cocos2dx_ParticleExplosion_constructor(se::State& s)
{
    cocos2d::ParticleExplosion* cobj = new (std::nothrow) cocos2d::ParticleExplosion();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleExplosion_constructor, __jsb_cocos2d_ParticleExplosion_class, js_cocos2d_ParticleExplosion_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

bool js_cocos2d_ParticleExplosion_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleExplosion)", s.nativeThisObject());
        cocos2d::ParticleExplosion* cobj = (cocos2d::ParticleExplosion*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleExplosion_finalize)

bool js_register_cocos2dx_ParticleExplosion(se::Object* obj)
{
    auto cls = se::Class::create("ParticleExplosion", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleExplosion_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleExplosion_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleExplosion_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleExplosion_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleExplosion_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleExplosion_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleExplosion>(cls);

    __jsb_cocos2d_ParticleExplosion_proto = cls->getProto();
    __jsb_cocos2d_ParticleExplosion_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleSmoke_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSmoke_class = nullptr;

static bool js_cocos2dx_ParticleSmoke_init(se::State& s)
{
    cocos2d::ParticleSmoke* cobj = (cocos2d::ParticleSmoke*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSmoke_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSmoke_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSmoke_init)

static bool js_cocos2dx_ParticleSmoke_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleSmoke* cobj = (cocos2d::ParticleSmoke*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSmoke_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSmoke_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSmoke_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSmoke_initWithTotalParticles)

static bool js_cocos2dx_ParticleSmoke_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleSmoke::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSmoke_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSmoke_create)

static bool js_cocos2dx_ParticleSmoke_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSmoke_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSmoke::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSmoke_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSmoke_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSmoke_finalize)

static bool js_cocos2dx_ParticleSmoke_constructor(se::State& s)
{
    cocos2d::ParticleSmoke* cobj = new (std::nothrow) cocos2d::ParticleSmoke();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSmoke_constructor, __jsb_cocos2d_ParticleSmoke_class, js_cocos2d_ParticleSmoke_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

bool js_cocos2d_ParticleSmoke_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleSmoke)", s.nativeThisObject());
        cocos2d::ParticleSmoke* cobj = (cocos2d::ParticleSmoke*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSmoke_finalize)

bool js_register_cocos2dx_ParticleSmoke(se::Object* obj)
{
    auto cls = se::Class::create("ParticleSmoke", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleSmoke_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleSmoke_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleSmoke_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSmoke_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSmoke_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleSmoke_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSmoke>(cls);

    __jsb_cocos2d_ParticleSmoke_proto = cls->getProto();
    __jsb_cocos2d_ParticleSmoke_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleSnow_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSnow_class = nullptr;

static bool js_cocos2dx_ParticleSnow_init(se::State& s)
{
    cocos2d::ParticleSnow* cobj = (cocos2d::ParticleSnow*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSnow_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSnow_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSnow_init)

static bool js_cocos2dx_ParticleSnow_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleSnow* cobj = (cocos2d::ParticleSnow*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSnow_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSnow_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSnow_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSnow_initWithTotalParticles)

static bool js_cocos2dx_ParticleSnow_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleSnow::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSnow_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSnow_create)

static bool js_cocos2dx_ParticleSnow_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSnow_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSnow::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSnow_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSnow_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSnow_finalize)

static bool js_cocos2dx_ParticleSnow_constructor(se::State& s)
{
    cocos2d::ParticleSnow* cobj = new (std::nothrow) cocos2d::ParticleSnow();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSnow_constructor, __jsb_cocos2d_ParticleSnow_class, js_cocos2d_ParticleSnow_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

bool js_cocos2d_ParticleSnow_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleSnow)", s.nativeThisObject());
        cocos2d::ParticleSnow* cobj = (cocos2d::ParticleSnow*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSnow_finalize)

bool js_register_cocos2dx_ParticleSnow(se::Object* obj)
{
    auto cls = se::Class::create("ParticleSnow", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleSnow_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleSnow_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleSnow_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSnow_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSnow_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleSnow_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSnow>(cls);

    __jsb_cocos2d_ParticleSnow_proto = cls->getProto();
    __jsb_cocos2d_ParticleSnow_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ParticleRain_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleRain_class = nullptr;

static bool js_cocos2dx_ParticleRain_init(se::State& s)
{
    cocos2d::ParticleRain* cobj = (cocos2d::ParticleRain*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleRain_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleRain_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleRain_init)

static bool js_cocos2dx_ParticleRain_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleRain* cobj = (cocos2d::ParticleRain*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleRain_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleRain_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleRain_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleRain_initWithTotalParticles)

static bool js_cocos2dx_ParticleRain_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleRain::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleRain_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleRain_create)

static bool js_cocos2dx_ParticleRain_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParticleRain_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleRain::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleRain_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleRain_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleRain_finalize)

static bool js_cocos2dx_ParticleRain_constructor(se::State& s)
{
    cocos2d::ParticleRain* cobj = new (std::nothrow) cocos2d::ParticleRain();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleRain_constructor, __jsb_cocos2d_ParticleRain_class, js_cocos2d_ParticleRain_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

bool js_cocos2d_ParticleRain_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParticleRain)", s.nativeThisObject());
        cocos2d::ParticleRain* cobj = (cocos2d::ParticleRain*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleRain_finalize)

bool js_register_cocos2dx_ParticleRain(se::Object* obj)
{
    auto cls = se::Class::create("ParticleRain", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleRain_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleRain_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleRain_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleRain_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleRain_createWithTotalParticles));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParticleRain_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleRain>(cls);

    __jsb_cocos2d_ParticleRain_proto = cls->getProto();
    __jsb_cocos2d_ParticleRain_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_ProgressTimer_proto = nullptr;
se::Class* __jsb_cocos2d_ProgressTimer_class = nullptr;

static bool js_cocos2dx_ProgressTimer_initWithSprite(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_initWithSprite : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_initWithSprite : Error processing arguments");
        bool result = cobj->initWithSprite(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_initWithSprite : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_initWithSprite)

static bool js_cocos2dx_ProgressTimer_isReverseDirection(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_isReverseDirection : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isReverseDirection();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_isReverseDirection : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_isReverseDirection)

static bool js_cocos2dx_ProgressTimer_setBarChangeRate(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_setBarChangeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_setBarChangeRate : Error processing arguments");
        cobj->setBarChangeRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_setBarChangeRate)

static bool js_cocos2dx_ProgressTimer_getPercentage(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_getPercentage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getPercentage();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_getPercentage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_getPercentage)

static bool js_cocos2dx_ProgressTimer_setSprite(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_setSprite : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_setSprite : Error processing arguments");
        cobj->setSprite(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_setSprite)

static bool js_cocos2dx_ProgressTimer_getType(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_getType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getType();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_getType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_getType)

static bool js_cocos2dx_ProgressTimer_getSprite(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_getSprite : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Sprite* result = cobj->getSprite();
        ok &= native_ptr_to_seval<cocos2d::Sprite>((cocos2d::Sprite*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_getSprite : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_getSprite)

static bool js_cocos2dx_ProgressTimer_setMidpoint(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_setMidpoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_setMidpoint : Error processing arguments");
        cobj->setMidpoint(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_setMidpoint)

static bool js_cocos2dx_ProgressTimer_getBarChangeRate(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_getBarChangeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getBarChangeRate();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_getBarChangeRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_getBarChangeRate)

static bool js_cocos2dx_ProgressTimer_setReverseDirection(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_setReverseDirection : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_setReverseDirection : Error processing arguments");
        cobj->setReverseDirection(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_setReverseDirection)

static bool js_cocos2dx_ProgressTimer_getMidpoint(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_getMidpoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getMidpoint();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_getMidpoint : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_getMidpoint)

static bool js_cocos2dx_ProgressTimer_setPercentage(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_setPercentage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_setPercentage : Error processing arguments");
        cobj->setPercentage(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_setPercentage)

static bool js_cocos2dx_ProgressTimer_setType(se::State& s)
{
    cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProgressTimer_setType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ProgressTimer::Type arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_setType : Error processing arguments");
        cobj->setType(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_setType)

static bool js_cocos2dx_ProgressTimer_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProgressTimer_create : Error processing arguments");
        auto result = cocos2d::ProgressTimer::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ProgressTimer_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProgressTimer_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ProgressTimer_finalize)

static bool js_cocos2dx_ProgressTimer_constructor(se::State& s)
{
    cocos2d::ProgressTimer* cobj = new (std::nothrow) cocos2d::ProgressTimer();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ProgressTimer_constructor, __jsb_cocos2d_ProgressTimer_class, js_cocos2d_ProgressTimer_finalize)

static bool js_cocos2dx_ProgressTimer_ctor(se::State& s)
{
    cocos2d::ProgressTimer* cobj = new (std::nothrow) cocos2d::ProgressTimer();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ProgressTimer_ctor, __jsb_cocos2d_ProgressTimer_class, js_cocos2d_ProgressTimer_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_ProgressTimer_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ProgressTimer)", s.nativeThisObject());
        cocos2d::ProgressTimer* cobj = (cocos2d::ProgressTimer*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ProgressTimer_finalize)

bool js_register_cocos2dx_ProgressTimer(se::Object* obj)
{
    auto cls = se::Class::create("ProgressTimer", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_ProgressTimer_constructor));

    cls->defineFunction("initWithSprite", _SE(js_cocos2dx_ProgressTimer_initWithSprite));
    cls->defineFunction("isReverseDirection", _SE(js_cocos2dx_ProgressTimer_isReverseDirection));
    cls->defineFunction("setBarChangeRate", _SE(js_cocos2dx_ProgressTimer_setBarChangeRate));
    cls->defineFunction("getPercentage", _SE(js_cocos2dx_ProgressTimer_getPercentage));
    cls->defineFunction("setSprite", _SE(js_cocos2dx_ProgressTimer_setSprite));
    cls->defineFunction("getType", _SE(js_cocos2dx_ProgressTimer_getType));
    cls->defineFunction("getSprite", _SE(js_cocos2dx_ProgressTimer_getSprite));
    cls->defineFunction("setMidpoint", _SE(js_cocos2dx_ProgressTimer_setMidpoint));
    cls->defineFunction("getBarChangeRate", _SE(js_cocos2dx_ProgressTimer_getBarChangeRate));
    cls->defineFunction("setReverseDirection", _SE(js_cocos2dx_ProgressTimer_setReverseDirection));
    cls->defineFunction("getMidpoint", _SE(js_cocos2dx_ProgressTimer_getMidpoint));
    cls->defineFunction("setPercentage", _SE(js_cocos2dx_ProgressTimer_setPercentage));
    cls->defineFunction("setType", _SE(js_cocos2dx_ProgressTimer_setType));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ProgressTimer_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ProgressTimer_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ProgressTimer_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ProgressTimer>(cls);

    __jsb_cocos2d_ProgressTimer_proto = cls->getProto();
    __jsb_cocos2d_ProgressTimer_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ProgressTimer.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ProtectedNode_proto = nullptr;
se::Class* __jsb_cocos2d_ProtectedNode_class = nullptr;

static bool js_cocos2dx_ProtectedNode_addProtectedChild(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_ProtectedNode_addProtectedChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            cobj->addProtectedChild(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->addProtectedChild(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            cobj->addProtectedChild(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_addProtectedChild)

static bool js_cocos2dx_ProtectedNode_disableCascadeColor(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_disableCascadeColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->disableCascadeColor();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_disableCascadeColor)

static bool js_cocos2dx_ProtectedNode_removeProtectedChildByTag(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_removeProtectedChildByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_removeProtectedChildByTag : Error processing arguments");
        cobj->removeProtectedChildByTag(arg0);
        return true;
    }
    if (argc == 2) {
        int arg0 = 0;
        bool arg1;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_removeProtectedChildByTag : Error processing arguments");
        cobj->removeProtectedChildByTag(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_removeProtectedChildByTag)

static bool js_cocos2dx_ProtectedNode_reorderProtectedChild(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_reorderProtectedChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_reorderProtectedChild : Error processing arguments");
        cobj->reorderProtectedChild(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_reorderProtectedChild)

static bool js_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup : Error processing arguments");
        cobj->removeAllProtectedChildrenWithCleanup(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup)

static bool js_cocos2dx_ProtectedNode_disableCascadeOpacity(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_disableCascadeOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->disableCascadeOpacity();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_disableCascadeOpacity)

static bool js_cocos2dx_ProtectedNode_sortAllProtectedChildren(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_sortAllProtectedChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->sortAllProtectedChildren();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_sortAllProtectedChildren)

static bool js_cocos2dx_ProtectedNode_getProtectedChildByTag(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_getProtectedChildByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_getProtectedChildByTag : Error processing arguments");
        cocos2d::Node* result = cobj->getProtectedChildByTag(arg0);
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_getProtectedChildByTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_getProtectedChildByTag)

static bool js_cocos2dx_ProtectedNode_removeProtectedChild(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_removeProtectedChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_removeProtectedChild : Error processing arguments");
        cobj->removeProtectedChild(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        bool arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_removeProtectedChild : Error processing arguments");
        cobj->removeProtectedChild(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_removeProtectedChild)

static bool js_cocos2dx_ProtectedNode_removeAllProtectedChildren(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_removeAllProtectedChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllProtectedChildren();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_removeAllProtectedChildren)

static bool js_cocos2dx_ProtectedNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ProtectedNode::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ProtectedNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ProtectedNode_finalize)

static bool js_cocos2dx_ProtectedNode_constructor(se::State& s)
{
    cocos2d::ProtectedNode* cobj = new (std::nothrow) cocos2d::ProtectedNode();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ProtectedNode_constructor, __jsb_cocos2d_ProtectedNode_class, js_cocos2d_ProtectedNode_finalize)



extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_ProtectedNode_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ProtectedNode)", s.nativeThisObject());
        cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ProtectedNode_finalize)

bool js_register_cocos2dx_ProtectedNode(se::Object* obj)
{
    auto cls = se::Class::create("ProtectedNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_ProtectedNode_constructor));

    cls->defineFunction("addProtectedChild", _SE(js_cocos2dx_ProtectedNode_addProtectedChild));
    cls->defineFunction("disableCascadeColor", _SE(js_cocos2dx_ProtectedNode_disableCascadeColor));
    cls->defineFunction("removeProtectedChildByTag", _SE(js_cocos2dx_ProtectedNode_removeProtectedChildByTag));
    cls->defineFunction("reorderProtectedChild", _SE(js_cocos2dx_ProtectedNode_reorderProtectedChild));
    cls->defineFunction("removeAllProtectedChildrenWithCleanup", _SE(js_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup));
    cls->defineFunction("disableCascadeOpacity", _SE(js_cocos2dx_ProtectedNode_disableCascadeOpacity));
    cls->defineFunction("sortAllProtectedChildren", _SE(js_cocos2dx_ProtectedNode_sortAllProtectedChildren));
    cls->defineFunction("getProtectedChildByTag", _SE(js_cocos2dx_ProtectedNode_getProtectedChildByTag));
    cls->defineFunction("removeProtectedChild", _SE(js_cocos2dx_ProtectedNode_removeProtectedChild));
    cls->defineFunction("removeAllProtectedChildren", _SE(js_cocos2dx_ProtectedNode_removeAllProtectedChildren));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ProtectedNode_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ProtectedNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ProtectedNode>(cls);

    __jsb_cocos2d_ProtectedNode_proto = cls->getProto();
    __jsb_cocos2d_ProtectedNode_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Sprite_proto = nullptr;
se::Class* __jsb_cocos2d_Sprite_class = nullptr;

static bool js_cocos2dx_Sprite_setSpriteFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Sprite_setSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::SpriteFrame* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setSpriteFrame(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setSpriteFrame(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setSpriteFrame)

static bool js_cocos2dx_Sprite_setTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Sprite_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setTexture(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setTexture(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setTexture)

static bool js_cocos2dx_Sprite_getTexture(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getTexture)

static bool js_cocos2dx_Sprite_setFlippedY(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setFlippedY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setFlippedY : Error processing arguments");
        cobj->setFlippedY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setFlippedY)

static bool js_cocos2dx_Sprite_setFlippedX(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setFlippedX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setFlippedX : Error processing arguments");
        cobj->setFlippedX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setFlippedX)

static bool js_cocos2dx_Sprite_setRotationSkewX(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setRotationSkewX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setRotationSkewX : Error processing arguments");
        cobj->setRotationSkewX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setRotationSkewX)

static bool js_cocos2dx_Sprite_setRotationSkewY(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setRotationSkewY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setRotationSkewY : Error processing arguments");
        cobj->setRotationSkewY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setRotationSkewY)

static bool js_cocos2dx_Sprite_getResourceType(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getResourceType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getResourceType();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getResourceType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getResourceType)

static bool js_cocos2dx_Sprite_setDisplayFrameWithAnimationName(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setDisplayFrameWithAnimationName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        ssize_t arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setDisplayFrameWithAnimationName : Error processing arguments");
        cobj->setDisplayFrameWithAnimationName(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setDisplayFrameWithAnimationName)

static bool js_cocos2dx_Sprite_getBatchNode(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getBatchNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::SpriteBatchNode* result = cobj->getBatchNode();
        ok &= native_ptr_to_seval<cocos2d::SpriteBatchNode>((cocos2d::SpriteBatchNode*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getBatchNode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getBatchNode)

static bool js_cocos2dx_Sprite_getOffsetPosition(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getOffsetPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getOffsetPosition();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getOffsetPosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getOffsetPosition)

static bool js_cocos2dx_Sprite_getCenterRect(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getCenterRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->getCenterRect();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getCenterRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getCenterRect)

static bool js_cocos2dx_Sprite_removeAllChildrenWithCleanup(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_removeAllChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_removeAllChildrenWithCleanup : Error processing arguments");
        cobj->removeAllChildrenWithCleanup(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_removeAllChildrenWithCleanup)

static bool js_cocos2dx_Sprite_setCenterRectNormalized(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setCenterRectNormalized : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setCenterRectNormalized : Error processing arguments");
        cobj->setCenterRectNormalized(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setCenterRectNormalized)

static bool js_cocos2dx_Sprite_isStretchEnabled(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_isStretchEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isStretchEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isStretchEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_isStretchEnabled)

static bool js_cocos2dx_Sprite_setTextureRect(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Sprite_setTextureRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            cocos2d::Rect arg0;
            ok &= seval_to_Rect(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool arg1;
            ok &= seval_to_boolean(args[1], &arg1);
            cocos2d::Size arg2;
            ok &= seval_to_Size(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->setTextureRect(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Rect arg0;
            ok &= seval_to_Rect(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setTextureRect(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setTextureRect)

static bool js_cocos2dx_Sprite_initWithSpriteFrameName(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_initWithSpriteFrameName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithSpriteFrameName : Error processing arguments");
        bool result = cobj->initWithSpriteFrameName(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithSpriteFrameName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_initWithSpriteFrameName)

static bool js_cocos2dx_Sprite_setStretchEnabled(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setStretchEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setStretchEnabled : Error processing arguments");
        cobj->setStretchEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setStretchEnabled)

static bool js_cocos2dx_Sprite_isFrameDisplayed(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_isFrameDisplayed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isFrameDisplayed : Error processing arguments");
        bool result = cobj->isFrameDisplayed(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isFrameDisplayed : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_isFrameDisplayed)

static bool js_cocos2dx_Sprite_getAtlasIndex(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getAtlasIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getAtlasIndex();
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getAtlasIndex : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getAtlasIndex)

static bool js_cocos2dx_Sprite_setBatchNode(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setBatchNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteBatchNode* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setBatchNode : Error processing arguments");
        cobj->setBatchNode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setBatchNode)

static bool js_cocos2dx_Sprite_getBlendFunc(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getBlendFunc)

static bool js_cocos2dx_Sprite_setCenterRect(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setCenterRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setCenterRect : Error processing arguments");
        cobj->setCenterRect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setCenterRect)

static bool js_cocos2dx_Sprite_setTextureAtlas(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setTextureAtlas : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextureAtlas* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setTextureAtlas : Error processing arguments");
        cobj->setTextureAtlas(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setTextureAtlas)

static bool js_cocos2dx_Sprite_getSpriteFrame(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::SpriteFrame* result = cobj->getSpriteFrame();
        ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getSpriteFrame : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getSpriteFrame)

static bool js_cocos2dx_Sprite_getResourceName(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getResourceName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getResourceName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getResourceName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getResourceName)

static bool js_cocos2dx_Sprite_isDirty(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_isDirty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isDirty();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isDirty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_isDirty)

static bool js_cocos2dx_Sprite_getCenterRectNormalized(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getCenterRectNormalized : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->getCenterRectNormalized();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getCenterRectNormalized : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getCenterRectNormalized)

static bool js_cocos2dx_Sprite_setAtlasIndex(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setAtlasIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        ssize_t arg0 = 0;
        ok &= seval_to_ssize(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setAtlasIndex : Error processing arguments");
        cobj->setAtlasIndex(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setAtlasIndex)

static bool js_cocos2dx_Sprite_initWithTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Sprite_initWithTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTexture(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithTexture : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTexture(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithTexture : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            bool result = cobj->initWithTexture(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithTexture : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_initWithTexture)

static bool js_cocos2dx_Sprite_setDirty(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setDirty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setDirty : Error processing arguments");
        cobj->setDirty(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setDirty)

static bool js_cocos2dx_Sprite_isTextureRectRotated(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_isTextureRectRotated : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isTextureRectRotated();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isTextureRectRotated : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_isTextureRectRotated)

static bool js_cocos2dx_Sprite_getTextureRect(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getTextureRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Rect& result = cobj->getTextureRect();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getTextureRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getTextureRect)

static bool js_cocos2dx_Sprite_initWithFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Sprite_initWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFile(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithFile : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFile(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithFile : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_initWithFile)

static bool js_cocos2dx_Sprite_setBlendFunc(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setBlendFunc)

static bool js_cocos2dx_Sprite_initWithSpriteFrame(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_initWithSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithSpriteFrame : Error processing arguments");
        bool result = cobj->initWithSpriteFrame(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithSpriteFrame : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_initWithSpriteFrame)

static bool js_cocos2dx_Sprite_isFlippedX(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_isFlippedX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isFlippedX();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isFlippedX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_isFlippedX)

static bool js_cocos2dx_Sprite_isFlippedY(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_isFlippedY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isFlippedY();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isFlippedY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_isFlippedY)

static bool js_cocos2dx_Sprite_setVertexRect(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setVertexRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setVertexRect : Error processing arguments");
        cobj->setVertexRect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setVertexRect)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Sprite_finalize)

static bool js_cocos2dx_Sprite_constructor(se::State& s)
{
    cocos2d::Sprite* cobj = new (std::nothrow) cocos2d::Sprite();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Sprite_constructor, __jsb_cocos2d_Sprite_class, js_cocos2d_Sprite_finalize)

static bool js_cocos2dx_Sprite_ctor(se::State& s)
{
    cocos2d::Sprite* cobj = new (std::nothrow) cocos2d::Sprite();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Sprite_ctor, __jsb_cocos2d_Sprite_class, js_cocos2d_Sprite_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_Sprite_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Sprite)", s.nativeThisObject());
        cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Sprite_finalize)

bool js_register_cocos2dx_Sprite(se::Object* obj)
{
    auto cls = se::Class::create("Sprite", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_Sprite_constructor));

    cls->defineFunction("setSpriteFrame", _SE(js_cocos2dx_Sprite_setSpriteFrame));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_Sprite_setTexture));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_Sprite_getTexture));
    cls->defineFunction("setFlippedY", _SE(js_cocos2dx_Sprite_setFlippedY));
    cls->defineFunction("setFlippedX", _SE(js_cocos2dx_Sprite_setFlippedX));
    cls->defineFunction("setRotationSkewX", _SE(js_cocos2dx_Sprite_setRotationSkewX));
    cls->defineFunction("setRotationSkewY", _SE(js_cocos2dx_Sprite_setRotationSkewY));
    cls->defineFunction("getResourceType", _SE(js_cocos2dx_Sprite_getResourceType));
    cls->defineFunction("setDisplayFrameWithAnimationName", _SE(js_cocos2dx_Sprite_setDisplayFrameWithAnimationName));
    cls->defineFunction("getBatchNode", _SE(js_cocos2dx_Sprite_getBatchNode));
    cls->defineFunction("getOffsetPosition", _SE(js_cocos2dx_Sprite_getOffsetPosition));
    cls->defineFunction("getCenterRect", _SE(js_cocos2dx_Sprite_getCenterRect));
    cls->defineFunction("removeAllChildrenWithCleanup", _SE(js_cocos2dx_Sprite_removeAllChildrenWithCleanup));
    cls->defineFunction("setCenterRectNormalized", _SE(js_cocos2dx_Sprite_setCenterRectNormalized));
    cls->defineFunction("isStretchEnabled", _SE(js_cocos2dx_Sprite_isStretchEnabled));
    cls->defineFunction("setTextureRect", _SE(js_cocos2dx_Sprite_setTextureRect));
    cls->defineFunction("initWithSpriteFrameName", _SE(js_cocos2dx_Sprite_initWithSpriteFrameName));
    cls->defineFunction("setStretchEnabled", _SE(js_cocos2dx_Sprite_setStretchEnabled));
    cls->defineFunction("isFrameDisplayed", _SE(js_cocos2dx_Sprite_isFrameDisplayed));
    cls->defineFunction("getAtlasIndex", _SE(js_cocos2dx_Sprite_getAtlasIndex));
    cls->defineFunction("setBatchNode", _SE(js_cocos2dx_Sprite_setBatchNode));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_Sprite_getBlendFunc));
    cls->defineFunction("setCenterRect", _SE(js_cocos2dx_Sprite_setCenterRect));
    cls->defineFunction("setTextureAtlas", _SE(js_cocos2dx_Sprite_setTextureAtlas));
    cls->defineFunction("getSpriteFrame", _SE(js_cocos2dx_Sprite_getSpriteFrame));
    cls->defineFunction("getResourceName", _SE(js_cocos2dx_Sprite_getResourceName));
    cls->defineFunction("isDirty", _SE(js_cocos2dx_Sprite_isDirty));
    cls->defineFunction("getCenterRectNormalized", _SE(js_cocos2dx_Sprite_getCenterRectNormalized));
    cls->defineFunction("setAtlasIndex", _SE(js_cocos2dx_Sprite_setAtlasIndex));
    cls->defineFunction("initWithTexture", _SE(js_cocos2dx_Sprite_initWithTexture));
    cls->defineFunction("setDirty", _SE(js_cocos2dx_Sprite_setDirty));
    cls->defineFunction("isTextureRectRotated", _SE(js_cocos2dx_Sprite_isTextureRectRotated));
    cls->defineFunction("getTextureRect", _SE(js_cocos2dx_Sprite_getTextureRect));
    cls->defineFunction("initWithFile", _SE(js_cocos2dx_Sprite_initWithFile));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_Sprite_setBlendFunc));
    cls->defineFunction("initWithSpriteFrame", _SE(js_cocos2dx_Sprite_initWithSpriteFrame));
    cls->defineFunction("isFlippedX", _SE(js_cocos2dx_Sprite_isFlippedX));
    cls->defineFunction("isFlippedY", _SE(js_cocos2dx_Sprite_isFlippedY));
    cls->defineFunction("setVertexRect", _SE(js_cocos2dx_Sprite_setVertexRect));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Sprite_ctor));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Sprite_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Sprite>(cls);

    __jsb_cocos2d_Sprite_proto = cls->getProto();
    __jsb_cocos2d_Sprite_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Sprite.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_RenderTexture_proto = nullptr;
se::Class* __jsb_cocos2d_RenderTexture_class = nullptr;

static bool js_cocos2dx_RenderTexture_setVirtualViewport(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setVirtualViewport : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vec2 arg0;
        cocos2d::Rect arg1;
        cocos2d::Rect arg2;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Rect(args[1], &arg1);
        ok &= seval_to_Rect(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setVirtualViewport : Error processing arguments");
        cobj->setVirtualViewport(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setVirtualViewport)

static bool js_cocos2dx_RenderTexture_clearStencil(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_clearStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_clearStencil : Error processing arguments");
        cobj->clearStencil(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_clearStencil)

static bool js_cocos2dx_RenderTexture_getClearDepth(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_getClearDepth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getClearDepth();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_getClearDepth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_getClearDepth)

static bool js_cocos2dx_RenderTexture_getClearStencil(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_getClearStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getClearStencil();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_getClearStencil : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_getClearStencil)

static bool js_cocos2dx_RenderTexture_end(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_end : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->end();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_end)

static bool js_cocos2dx_RenderTexture_setClearStencil(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setClearStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setClearStencil : Error processing arguments");
        cobj->setClearStencil(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setClearStencil)

static bool js_cocos2dx_RenderTexture_setSprite(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setSprite : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setSprite : Error processing arguments");
        cobj->setSprite(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setSprite)

static bool js_cocos2dx_RenderTexture_getSprite(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_getSprite : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Sprite* result = cobj->getSprite();
        ok &= native_ptr_to_seval<cocos2d::Sprite>((cocos2d::Sprite*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_getSprite : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_getSprite)

static bool js_cocos2dx_RenderTexture_isAutoDraw(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_isAutoDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isAutoDraw();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_isAutoDraw : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_isAutoDraw)

static bool js_cocos2dx_RenderTexture_setKeepMatrix(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setKeepMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setKeepMatrix : Error processing arguments");
        cobj->setKeepMatrix(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setKeepMatrix)

static bool js_cocos2dx_RenderTexture_setClearFlags(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setClearFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setClearFlags : Error processing arguments");
        cobj->setClearFlags(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setClearFlags)

static bool js_cocos2dx_RenderTexture_begin(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_begin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->begin();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_begin)

static bool js_cocos2dx_RenderTexture_setAutoDraw(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setAutoDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setAutoDraw : Error processing arguments");
        cobj->setAutoDraw(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setAutoDraw)

static bool js_cocos2dx_RenderTexture_setClearColor(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setClearColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setClearColor : Error processing arguments");
        cobj->setClearColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setClearColor)

static bool js_cocos2dx_RenderTexture_beginWithClear(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_RenderTexture_beginWithClear : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3, arg4);
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3);
            return true;
        }
    } while(false);

    do {
        if (argc == 6) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            int arg5 = 0;
            ok &= seval_to_int32(args[5], (int32_t *)&arg5);
            if (!ok) { ok = true; break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3, arg4, arg5);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_beginWithClear)

static bool js_cocos2dx_RenderTexture_clearDepth(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_clearDepth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_clearDepth : Error processing arguments");
        cobj->clearDepth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_clearDepth)

static bool js_cocos2dx_RenderTexture_getClearColor(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_getClearColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4F& result = cobj->getClearColor();
        ok &= Color4F_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_getClearColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_getClearColor)

static bool js_cocos2dx_RenderTexture_clear(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_clear : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_clear : Error processing arguments");
        cobj->clear(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_clear)

static bool js_cocos2dx_RenderTexture_getClearFlags(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_getClearFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getClearFlags();
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_getClearFlags : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_getClearFlags)

static bool js_cocos2dx_RenderTexture_newImage(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_newImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Image* result = cobj->newImage();
        ok &= native_ptr_to_seval<cocos2d::Image>((cocos2d::Image*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_newImage : Error processing arguments");
        return true;
    }
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_newImage : Error processing arguments");
        cocos2d::Image* result = cobj->newImage(arg0);
        ok &= native_ptr_to_seval<cocos2d::Image>((cocos2d::Image*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_newImage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_newImage)

static bool js_cocos2dx_RenderTexture_setClearDepth(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setClearDepth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setClearDepth : Error processing arguments");
        cobj->setClearDepth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setClearDepth)

static bool js_cocos2dx_RenderTexture_initWithWidthAndHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_RenderTexture_initWithWidthAndHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 4) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D::PixelFormat arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithWidthAndHeight(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_initWithWidthAndHeight : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D::PixelFormat arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithWidthAndHeight(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_initWithWidthAndHeight : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_initWithWidthAndHeight)

static bool js_cocos2dx_RenderTexture_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D::PixelFormat arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            cocos2d::RenderTexture* result = cocos2d::RenderTexture::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::RenderTexture>((cocos2d::RenderTexture*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D::PixelFormat arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::RenderTexture* result = cocos2d::RenderTexture::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::RenderTexture>((cocos2d::RenderTexture*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t *)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::RenderTexture* result = cocos2d::RenderTexture::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::RenderTexture>((cocos2d::RenderTexture*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_RenderTexture_finalize)

static bool js_cocos2dx_RenderTexture_constructor(se::State& s)
{
    cocos2d::RenderTexture* cobj = new (std::nothrow) cocos2d::RenderTexture();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_RenderTexture_constructor, __jsb_cocos2d_RenderTexture_class, js_cocos2d_RenderTexture_finalize)

static bool js_cocos2dx_RenderTexture_ctor(se::State& s)
{
    cocos2d::RenderTexture* cobj = new (std::nothrow) cocos2d::RenderTexture();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_RenderTexture_ctor, __jsb_cocos2d_RenderTexture_class, js_cocos2d_RenderTexture_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_RenderTexture_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::RenderTexture)", s.nativeThisObject());
        cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_RenderTexture_finalize)

bool js_register_cocos2dx_RenderTexture(se::Object* obj)
{
    auto cls = se::Class::create("RenderTexture", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_RenderTexture_constructor));

    cls->defineFunction("setVirtualViewport", _SE(js_cocos2dx_RenderTexture_setVirtualViewport));
    cls->defineFunction("clearStencil", _SE(js_cocos2dx_RenderTexture_clearStencil));
    cls->defineFunction("getClearDepth", _SE(js_cocos2dx_RenderTexture_getClearDepth));
    cls->defineFunction("getClearStencil", _SE(js_cocos2dx_RenderTexture_getClearStencil));
    cls->defineFunction("end", _SE(js_cocos2dx_RenderTexture_end));
    cls->defineFunction("setClearStencil", _SE(js_cocos2dx_RenderTexture_setClearStencil));
    cls->defineFunction("setSprite", _SE(js_cocos2dx_RenderTexture_setSprite));
    cls->defineFunction("getSprite", _SE(js_cocos2dx_RenderTexture_getSprite));
    cls->defineFunction("isAutoDraw", _SE(js_cocos2dx_RenderTexture_isAutoDraw));
    cls->defineFunction("setKeepMatrix", _SE(js_cocos2dx_RenderTexture_setKeepMatrix));
    cls->defineFunction("setClearFlags", _SE(js_cocos2dx_RenderTexture_setClearFlags));
    cls->defineFunction("begin", _SE(js_cocos2dx_RenderTexture_begin));
    cls->defineFunction("setAutoDraw", _SE(js_cocos2dx_RenderTexture_setAutoDraw));
    cls->defineFunction("setClearColor", _SE(js_cocos2dx_RenderTexture_setClearColor));
    cls->defineFunction("beginWithClear", _SE(js_cocos2dx_RenderTexture_beginWithClear));
    cls->defineFunction("clearDepth", _SE(js_cocos2dx_RenderTexture_clearDepth));
    cls->defineFunction("getClearColor", _SE(js_cocos2dx_RenderTexture_getClearColor));
    cls->defineFunction("clear", _SE(js_cocos2dx_RenderTexture_clear));
    cls->defineFunction("getClearFlags", _SE(js_cocos2dx_RenderTexture_getClearFlags));
    cls->defineFunction("newImage", _SE(js_cocos2dx_RenderTexture_newImage));
    cls->defineFunction("setClearDepth", _SE(js_cocos2dx_RenderTexture_setClearDepth));
    cls->defineFunction("initWithWidthAndHeight", _SE(js_cocos2dx_RenderTexture_initWithWidthAndHeight));
    cls->defineFunction("ctor", _SE(js_cocos2dx_RenderTexture_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_RenderTexture_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_RenderTexture_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::RenderTexture>(cls);

    __jsb_cocos2d_RenderTexture_proto = cls->getProto();
    __jsb_cocos2d_RenderTexture_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.RenderTexture.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionEaseScene_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionEaseScene_class = nullptr;

static bool js_cocos2dx_TransitionEaseScene_easeActionWithAction(se::State& s)
{
    cocos2d::TransitionEaseScene* cobj = (cocos2d::TransitionEaseScene*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionEaseScene_easeActionWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionEaseScene_easeActionWithAction : Error processing arguments");
        cocos2d::ActionInterval* result = cobj->easeActionWithAction(arg0);
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionEaseScene_easeActionWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionEaseScene_easeActionWithAction)




bool js_register_cocos2dx_TransitionEaseScene(se::Object* obj)
{
    auto cls = se::Class::create("TransitionEaseScene", obj, nullptr, nullptr);

    cls->defineFunction("easeActionWithAction", _SE(js_cocos2dx_TransitionEaseScene_easeActionWithAction));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionEaseScene>(cls);

    __jsb_cocos2d_TransitionEaseScene_proto = cls->getProto();
    __jsb_cocos2d_TransitionEaseScene_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_TransitionScene_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionScene_class = nullptr;

static bool js_cocos2dx_TransitionScene_getInScene(se::State& s)
{
    cocos2d::TransitionScene* cobj = (cocos2d::TransitionScene*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionScene_getInScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Scene* result = cobj->getInScene();
        ok &= native_ptr_to_seval<cocos2d::Scene>((cocos2d::Scene*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionScene_getInScene : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionScene_getInScene)

static bool js_cocos2dx_TransitionScene_finish(se::State& s)
{
    cocos2d::TransitionScene* cobj = (cocos2d::TransitionScene*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionScene_finish : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->finish();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionScene_finish)

static bool js_cocos2dx_TransitionScene_initWithDuration(se::State& s)
{
    cocos2d::TransitionScene* cobj = (cocos2d::TransitionScene*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionScene_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionScene_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionScene_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionScene_initWithDuration)

static bool js_cocos2dx_TransitionScene_getDuration(se::State& s)
{
    cocos2d::TransitionScene* cobj = (cocos2d::TransitionScene*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionScene_getDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getDuration();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionScene_getDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionScene_getDuration)

static bool js_cocos2dx_TransitionScene_hideOutShowIn(se::State& s)
{
    cocos2d::TransitionScene* cobj = (cocos2d::TransitionScene*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionScene_hideOutShowIn : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->hideOutShowIn();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionScene_hideOutShowIn)

static bool js_cocos2dx_TransitionScene_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionScene_create : Error processing arguments");
        auto result = cocos2d::TransitionScene::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionScene_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionScene_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionScene_finalize)

static bool js_cocos2dx_TransitionScene_constructor(se::State& s)
{
    cocos2d::TransitionScene* cobj = new (std::nothrow) cocos2d::TransitionScene();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionScene_constructor, __jsb_cocos2d_TransitionScene_class, js_cocos2d_TransitionScene_finalize)

static bool js_cocos2dx_TransitionScene_ctor(se::State& s)
{
    cocos2d::TransitionScene* cobj = new (std::nothrow) cocos2d::TransitionScene();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionScene_ctor, __jsb_cocos2d_TransitionScene_class, js_cocos2d_TransitionScene_finalize)


    

extern se::Object* __jsb_cocos2d_Scene_proto;

bool js_cocos2d_TransitionScene_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionScene)", s.nativeThisObject());
        cocos2d::TransitionScene* cobj = (cocos2d::TransitionScene*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionScene_finalize)

bool js_register_cocos2dx_TransitionScene(se::Object* obj)
{
    auto cls = se::Class::create("TransitionScene", obj, __jsb_cocos2d_Scene_proto, _SE(js_cocos2dx_TransitionScene_constructor));

    cls->defineFunction("getInScene", _SE(js_cocos2dx_TransitionScene_getInScene));
    cls->defineFunction("finish", _SE(js_cocos2dx_TransitionScene_finish));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_TransitionScene_initWithDuration));
    cls->defineFunction("getDuration", _SE(js_cocos2dx_TransitionScene_getDuration));
    cls->defineFunction("hideOutShowIn", _SE(js_cocos2dx_TransitionScene_hideOutShowIn));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionScene_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionScene_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionScene_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionScene>(cls);

    __jsb_cocos2d_TransitionScene_proto = cls->getProto();
    __jsb_cocos2d_TransitionScene_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionScene.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionSceneOriented_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionSceneOriented_class = nullptr;

static bool js_cocos2dx_TransitionSceneOriented_initWithDuration(se::State& s)
{
    cocos2d::TransitionSceneOriented* cobj = (cocos2d::TransitionSceneOriented*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionSceneOriented_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        cocos2d::TransitionScene::Orientation arg2;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSceneOriented_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSceneOriented_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSceneOriented_initWithDuration)

static bool js_cocos2dx_TransitionSceneOriented_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        cocos2d::TransitionScene::Orientation arg2;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSceneOriented_create : Error processing arguments");
        auto result = cocos2d::TransitionSceneOriented::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionSceneOriented_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSceneOriented_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionSceneOriented_finalize)

static bool js_cocos2dx_TransitionSceneOriented_constructor(se::State& s)
{
    cocos2d::TransitionSceneOriented* cobj = new (std::nothrow) cocos2d::TransitionSceneOriented();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionSceneOriented_constructor, __jsb_cocos2d_TransitionSceneOriented_class, js_cocos2d_TransitionSceneOriented_finalize)

static bool js_cocos2dx_TransitionSceneOriented_ctor(se::State& s)
{
    cocos2d::TransitionSceneOriented* cobj = new (std::nothrow) cocos2d::TransitionSceneOriented();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionSceneOriented_ctor, __jsb_cocos2d_TransitionSceneOriented_class, js_cocos2d_TransitionSceneOriented_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionSceneOriented_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionSceneOriented)", s.nativeThisObject());
        cocos2d::TransitionSceneOriented* cobj = (cocos2d::TransitionSceneOriented*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionSceneOriented_finalize)

bool js_register_cocos2dx_TransitionSceneOriented(se::Object* obj)
{
    auto cls = se::Class::create("TransitionSceneOriented", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionSceneOriented_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_TransitionSceneOriented_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionSceneOriented_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionSceneOriented_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionSceneOriented_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionSceneOriented>(cls);

    __jsb_cocos2d_TransitionSceneOriented_proto = cls->getProto();
    __jsb_cocos2d_TransitionSceneOriented_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionSceneOriented.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionRotoZoom_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionRotoZoom_class = nullptr;

static bool js_cocos2dx_TransitionRotoZoom_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionRotoZoom_create : Error processing arguments");
        auto result = cocos2d::TransitionRotoZoom::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionRotoZoom_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionRotoZoom_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionRotoZoom_finalize)

static bool js_cocos2dx_TransitionRotoZoom_constructor(se::State& s)
{
    cocos2d::TransitionRotoZoom* cobj = new (std::nothrow) cocos2d::TransitionRotoZoom();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionRotoZoom_constructor, __jsb_cocos2d_TransitionRotoZoom_class, js_cocos2d_TransitionRotoZoom_finalize)

static bool js_cocos2dx_TransitionRotoZoom_ctor(se::State& s)
{
    cocos2d::TransitionRotoZoom* cobj = new (std::nothrow) cocos2d::TransitionRotoZoom();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionRotoZoom_ctor, __jsb_cocos2d_TransitionRotoZoom_class, js_cocos2d_TransitionRotoZoom_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionRotoZoom_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionRotoZoom)", s.nativeThisObject());
        cocos2d::TransitionRotoZoom* cobj = (cocos2d::TransitionRotoZoom*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionRotoZoom_finalize)

bool js_register_cocos2dx_TransitionRotoZoom(se::Object* obj)
{
    auto cls = se::Class::create("TransitionRotoZoom", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionRotoZoom_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionRotoZoom_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionRotoZoom_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionRotoZoom_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionRotoZoom>(cls);

    __jsb_cocos2d_TransitionRotoZoom_proto = cls->getProto();
    __jsb_cocos2d_TransitionRotoZoom_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionRotoZoom.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionJumpZoom_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionJumpZoom_class = nullptr;

static bool js_cocos2dx_TransitionJumpZoom_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionJumpZoom_create : Error processing arguments");
        auto result = cocos2d::TransitionJumpZoom::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionJumpZoom_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionJumpZoom_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionJumpZoom_finalize)

static bool js_cocos2dx_TransitionJumpZoom_constructor(se::State& s)
{
    cocos2d::TransitionJumpZoom* cobj = new (std::nothrow) cocos2d::TransitionJumpZoom();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionJumpZoom_constructor, __jsb_cocos2d_TransitionJumpZoom_class, js_cocos2d_TransitionJumpZoom_finalize)

static bool js_cocos2dx_TransitionJumpZoom_ctor(se::State& s)
{
    cocos2d::TransitionJumpZoom* cobj = new (std::nothrow) cocos2d::TransitionJumpZoom();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionJumpZoom_ctor, __jsb_cocos2d_TransitionJumpZoom_class, js_cocos2d_TransitionJumpZoom_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionJumpZoom_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionJumpZoom)", s.nativeThisObject());
        cocos2d::TransitionJumpZoom* cobj = (cocos2d::TransitionJumpZoom*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionJumpZoom_finalize)

bool js_register_cocos2dx_TransitionJumpZoom(se::Object* obj)
{
    auto cls = se::Class::create("TransitionJumpZoom", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionJumpZoom_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionJumpZoom_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionJumpZoom_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionJumpZoom_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionJumpZoom>(cls);

    __jsb_cocos2d_TransitionJumpZoom_proto = cls->getProto();
    __jsb_cocos2d_TransitionJumpZoom_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionJumpZoom.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionMoveInL_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionMoveInL_class = nullptr;

static bool js_cocos2dx_TransitionMoveInL_action(se::State& s)
{
    cocos2d::TransitionMoveInL* cobj = (cocos2d::TransitionMoveInL*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionMoveInL_action : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ActionInterval* result = cobj->action();
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionMoveInL_action : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionMoveInL_action)

static bool js_cocos2dx_TransitionMoveInL_easeActionWithAction(se::State& s)
{
    cocos2d::TransitionMoveInL* cobj = (cocos2d::TransitionMoveInL*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionMoveInL_easeActionWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionMoveInL_easeActionWithAction : Error processing arguments");
        cocos2d::ActionInterval* result = cobj->easeActionWithAction(arg0);
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionMoveInL_easeActionWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionMoveInL_easeActionWithAction)

static bool js_cocos2dx_TransitionMoveInL_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionMoveInL_create : Error processing arguments");
        auto result = cocos2d::TransitionMoveInL::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionMoveInL_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionMoveInL_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionMoveInL_finalize)

static bool js_cocos2dx_TransitionMoveInL_constructor(se::State& s)
{
    cocos2d::TransitionMoveInL* cobj = new (std::nothrow) cocos2d::TransitionMoveInL();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionMoveInL_constructor, __jsb_cocos2d_TransitionMoveInL_class, js_cocos2d_TransitionMoveInL_finalize)

static bool js_cocos2dx_TransitionMoveInL_ctor(se::State& s)
{
    cocos2d::TransitionMoveInL* cobj = new (std::nothrow) cocos2d::TransitionMoveInL();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionMoveInL_ctor, __jsb_cocos2d_TransitionMoveInL_class, js_cocos2d_TransitionMoveInL_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionMoveInL_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionMoveInL)", s.nativeThisObject());
        cocos2d::TransitionMoveInL* cobj = (cocos2d::TransitionMoveInL*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionMoveInL_finalize)

bool js_register_cocos2dx_TransitionMoveInL(se::Object* obj)
{
    auto cls = se::Class::create("TransitionMoveInL", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionMoveInL_constructor));

    cls->defineFunction("action", _SE(js_cocos2dx_TransitionMoveInL_action));
    cls->defineFunction("easeActionWithAction", _SE(js_cocos2dx_TransitionMoveInL_easeActionWithAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionMoveInL_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionMoveInL_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionMoveInL_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionMoveInL>(cls);

    __jsb_cocos2d_TransitionMoveInL_proto = cls->getProto();
    __jsb_cocos2d_TransitionMoveInL_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionMoveInL.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionMoveInR_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionMoveInR_class = nullptr;

static bool js_cocos2dx_TransitionMoveInR_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionMoveInR_create : Error processing arguments");
        auto result = cocos2d::TransitionMoveInR::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionMoveInR_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionMoveInR_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionMoveInR_finalize)

static bool js_cocos2dx_TransitionMoveInR_constructor(se::State& s)
{
    cocos2d::TransitionMoveInR* cobj = new (std::nothrow) cocos2d::TransitionMoveInR();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionMoveInR_constructor, __jsb_cocos2d_TransitionMoveInR_class, js_cocos2d_TransitionMoveInR_finalize)

static bool js_cocos2dx_TransitionMoveInR_ctor(se::State& s)
{
    cocos2d::TransitionMoveInR* cobj = new (std::nothrow) cocos2d::TransitionMoveInR();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionMoveInR_ctor, __jsb_cocos2d_TransitionMoveInR_class, js_cocos2d_TransitionMoveInR_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionMoveInL_proto;

bool js_cocos2d_TransitionMoveInR_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionMoveInR)", s.nativeThisObject());
        cocos2d::TransitionMoveInR* cobj = (cocos2d::TransitionMoveInR*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionMoveInR_finalize)

bool js_register_cocos2dx_TransitionMoveInR(se::Object* obj)
{
    auto cls = se::Class::create("TransitionMoveInR", obj, __jsb_cocos2d_TransitionMoveInL_proto, _SE(js_cocos2dx_TransitionMoveInR_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionMoveInR_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionMoveInR_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionMoveInR_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionMoveInR>(cls);

    __jsb_cocos2d_TransitionMoveInR_proto = cls->getProto();
    __jsb_cocos2d_TransitionMoveInR_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionMoveInR.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionMoveInT_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionMoveInT_class = nullptr;

static bool js_cocos2dx_TransitionMoveInT_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionMoveInT_create : Error processing arguments");
        auto result = cocos2d::TransitionMoveInT::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionMoveInT_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionMoveInT_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionMoveInT_finalize)

static bool js_cocos2dx_TransitionMoveInT_constructor(se::State& s)
{
    cocos2d::TransitionMoveInT* cobj = new (std::nothrow) cocos2d::TransitionMoveInT();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionMoveInT_constructor, __jsb_cocos2d_TransitionMoveInT_class, js_cocos2d_TransitionMoveInT_finalize)

static bool js_cocos2dx_TransitionMoveInT_ctor(se::State& s)
{
    cocos2d::TransitionMoveInT* cobj = new (std::nothrow) cocos2d::TransitionMoveInT();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionMoveInT_ctor, __jsb_cocos2d_TransitionMoveInT_class, js_cocos2d_TransitionMoveInT_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionMoveInL_proto;

bool js_cocos2d_TransitionMoveInT_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionMoveInT)", s.nativeThisObject());
        cocos2d::TransitionMoveInT* cobj = (cocos2d::TransitionMoveInT*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionMoveInT_finalize)

bool js_register_cocos2dx_TransitionMoveInT(se::Object* obj)
{
    auto cls = se::Class::create("TransitionMoveInT", obj, __jsb_cocos2d_TransitionMoveInL_proto, _SE(js_cocos2dx_TransitionMoveInT_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionMoveInT_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionMoveInT_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionMoveInT_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionMoveInT>(cls);

    __jsb_cocos2d_TransitionMoveInT_proto = cls->getProto();
    __jsb_cocos2d_TransitionMoveInT_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionMoveInT.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionMoveInB_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionMoveInB_class = nullptr;

static bool js_cocos2dx_TransitionMoveInB_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionMoveInB_create : Error processing arguments");
        auto result = cocos2d::TransitionMoveInB::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionMoveInB_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionMoveInB_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionMoveInB_finalize)

static bool js_cocos2dx_TransitionMoveInB_constructor(se::State& s)
{
    cocos2d::TransitionMoveInB* cobj = new (std::nothrow) cocos2d::TransitionMoveInB();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionMoveInB_constructor, __jsb_cocos2d_TransitionMoveInB_class, js_cocos2d_TransitionMoveInB_finalize)

static bool js_cocos2dx_TransitionMoveInB_ctor(se::State& s)
{
    cocos2d::TransitionMoveInB* cobj = new (std::nothrow) cocos2d::TransitionMoveInB();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionMoveInB_ctor, __jsb_cocos2d_TransitionMoveInB_class, js_cocos2d_TransitionMoveInB_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionMoveInL_proto;

bool js_cocos2d_TransitionMoveInB_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionMoveInB)", s.nativeThisObject());
        cocos2d::TransitionMoveInB* cobj = (cocos2d::TransitionMoveInB*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionMoveInB_finalize)

bool js_register_cocos2dx_TransitionMoveInB(se::Object* obj)
{
    auto cls = se::Class::create("TransitionMoveInB", obj, __jsb_cocos2d_TransitionMoveInL_proto, _SE(js_cocos2dx_TransitionMoveInB_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionMoveInB_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionMoveInB_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionMoveInB_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionMoveInB>(cls);

    __jsb_cocos2d_TransitionMoveInB_proto = cls->getProto();
    __jsb_cocos2d_TransitionMoveInB_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionMoveInB.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionSlideInL_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionSlideInL_class = nullptr;

static bool js_cocos2dx_TransitionSlideInL_action(se::State& s)
{
    cocos2d::TransitionSlideInL* cobj = (cocos2d::TransitionSlideInL*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionSlideInL_action : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ActionInterval* result = cobj->action();
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSlideInL_action : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSlideInL_action)

static bool js_cocos2dx_TransitionSlideInL_easeActionWithAction(se::State& s)
{
    cocos2d::TransitionSlideInL* cobj = (cocos2d::TransitionSlideInL*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionSlideInL_easeActionWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSlideInL_easeActionWithAction : Error processing arguments");
        cocos2d::ActionInterval* result = cobj->easeActionWithAction(arg0);
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSlideInL_easeActionWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSlideInL_easeActionWithAction)

static bool js_cocos2dx_TransitionSlideInL_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSlideInL_create : Error processing arguments");
        auto result = cocos2d::TransitionSlideInL::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionSlideInL_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSlideInL_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionSlideInL_finalize)

static bool js_cocos2dx_TransitionSlideInL_constructor(se::State& s)
{
    cocos2d::TransitionSlideInL* cobj = new (std::nothrow) cocos2d::TransitionSlideInL();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionSlideInL_constructor, __jsb_cocos2d_TransitionSlideInL_class, js_cocos2d_TransitionSlideInL_finalize)

static bool js_cocos2dx_TransitionSlideInL_ctor(se::State& s)
{
    cocos2d::TransitionSlideInL* cobj = new (std::nothrow) cocos2d::TransitionSlideInL();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionSlideInL_ctor, __jsb_cocos2d_TransitionSlideInL_class, js_cocos2d_TransitionSlideInL_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionSlideInL_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionSlideInL)", s.nativeThisObject());
        cocos2d::TransitionSlideInL* cobj = (cocos2d::TransitionSlideInL*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionSlideInL_finalize)

bool js_register_cocos2dx_TransitionSlideInL(se::Object* obj)
{
    auto cls = se::Class::create("TransitionSlideInL", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionSlideInL_constructor));

    cls->defineFunction("action", _SE(js_cocos2dx_TransitionSlideInL_action));
    cls->defineFunction("easeActionWithAction", _SE(js_cocos2dx_TransitionSlideInL_easeActionWithAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionSlideInL_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionSlideInL_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionSlideInL_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionSlideInL>(cls);

    __jsb_cocos2d_TransitionSlideInL_proto = cls->getProto();
    __jsb_cocos2d_TransitionSlideInL_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionSlideInL.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionSlideInR_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionSlideInR_class = nullptr;

static bool js_cocos2dx_TransitionSlideInR_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSlideInR_create : Error processing arguments");
        auto result = cocos2d::TransitionSlideInR::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionSlideInR_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSlideInR_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionSlideInR_finalize)

static bool js_cocos2dx_TransitionSlideInR_constructor(se::State& s)
{
    cocos2d::TransitionSlideInR* cobj = new (std::nothrow) cocos2d::TransitionSlideInR();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionSlideInR_constructor, __jsb_cocos2d_TransitionSlideInR_class, js_cocos2d_TransitionSlideInR_finalize)

static bool js_cocos2dx_TransitionSlideInR_ctor(se::State& s)
{
    cocos2d::TransitionSlideInR* cobj = new (std::nothrow) cocos2d::TransitionSlideInR();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionSlideInR_ctor, __jsb_cocos2d_TransitionSlideInR_class, js_cocos2d_TransitionSlideInR_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionSlideInL_proto;

bool js_cocos2d_TransitionSlideInR_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionSlideInR)", s.nativeThisObject());
        cocos2d::TransitionSlideInR* cobj = (cocos2d::TransitionSlideInR*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionSlideInR_finalize)

bool js_register_cocos2dx_TransitionSlideInR(se::Object* obj)
{
    auto cls = se::Class::create("TransitionSlideInR", obj, __jsb_cocos2d_TransitionSlideInL_proto, _SE(js_cocos2dx_TransitionSlideInR_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionSlideInR_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionSlideInR_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionSlideInR_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionSlideInR>(cls);

    __jsb_cocos2d_TransitionSlideInR_proto = cls->getProto();
    __jsb_cocos2d_TransitionSlideInR_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionSlideInR.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionSlideInB_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionSlideInB_class = nullptr;

static bool js_cocos2dx_TransitionSlideInB_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSlideInB_create : Error processing arguments");
        auto result = cocos2d::TransitionSlideInB::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionSlideInB_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSlideInB_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionSlideInB_finalize)

static bool js_cocos2dx_TransitionSlideInB_constructor(se::State& s)
{
    cocos2d::TransitionSlideInB* cobj = new (std::nothrow) cocos2d::TransitionSlideInB();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionSlideInB_constructor, __jsb_cocos2d_TransitionSlideInB_class, js_cocos2d_TransitionSlideInB_finalize)

static bool js_cocos2dx_TransitionSlideInB_ctor(se::State& s)
{
    cocos2d::TransitionSlideInB* cobj = new (std::nothrow) cocos2d::TransitionSlideInB();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionSlideInB_ctor, __jsb_cocos2d_TransitionSlideInB_class, js_cocos2d_TransitionSlideInB_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionSlideInL_proto;

bool js_cocos2d_TransitionSlideInB_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionSlideInB)", s.nativeThisObject());
        cocos2d::TransitionSlideInB* cobj = (cocos2d::TransitionSlideInB*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionSlideInB_finalize)

bool js_register_cocos2dx_TransitionSlideInB(se::Object* obj)
{
    auto cls = se::Class::create("TransitionSlideInB", obj, __jsb_cocos2d_TransitionSlideInL_proto, _SE(js_cocos2dx_TransitionSlideInB_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionSlideInB_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionSlideInB_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionSlideInB_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionSlideInB>(cls);

    __jsb_cocos2d_TransitionSlideInB_proto = cls->getProto();
    __jsb_cocos2d_TransitionSlideInB_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionSlideInB.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionSlideInT_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionSlideInT_class = nullptr;

static bool js_cocos2dx_TransitionSlideInT_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSlideInT_create : Error processing arguments");
        auto result = cocos2d::TransitionSlideInT::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionSlideInT_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSlideInT_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionSlideInT_finalize)

static bool js_cocos2dx_TransitionSlideInT_constructor(se::State& s)
{
    cocos2d::TransitionSlideInT* cobj = new (std::nothrow) cocos2d::TransitionSlideInT();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionSlideInT_constructor, __jsb_cocos2d_TransitionSlideInT_class, js_cocos2d_TransitionSlideInT_finalize)

static bool js_cocos2dx_TransitionSlideInT_ctor(se::State& s)
{
    cocos2d::TransitionSlideInT* cobj = new (std::nothrow) cocos2d::TransitionSlideInT();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionSlideInT_ctor, __jsb_cocos2d_TransitionSlideInT_class, js_cocos2d_TransitionSlideInT_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionSlideInL_proto;

bool js_cocos2d_TransitionSlideInT_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionSlideInT)", s.nativeThisObject());
        cocos2d::TransitionSlideInT* cobj = (cocos2d::TransitionSlideInT*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionSlideInT_finalize)

bool js_register_cocos2dx_TransitionSlideInT(se::Object* obj)
{
    auto cls = se::Class::create("TransitionSlideInT", obj, __jsb_cocos2d_TransitionSlideInL_proto, _SE(js_cocos2dx_TransitionSlideInT_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionSlideInT_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionSlideInT_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionSlideInT_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionSlideInT>(cls);

    __jsb_cocos2d_TransitionSlideInT_proto = cls->getProto();
    __jsb_cocos2d_TransitionSlideInT_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionSlideInT.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionShrinkGrow_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionShrinkGrow_class = nullptr;

static bool js_cocos2dx_TransitionShrinkGrow_easeActionWithAction(se::State& s)
{
    cocos2d::TransitionShrinkGrow* cobj = (cocos2d::TransitionShrinkGrow*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionShrinkGrow_easeActionWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionShrinkGrow_easeActionWithAction : Error processing arguments");
        cocos2d::ActionInterval* result = cobj->easeActionWithAction(arg0);
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionShrinkGrow_easeActionWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionShrinkGrow_easeActionWithAction)

static bool js_cocos2dx_TransitionShrinkGrow_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionShrinkGrow_create : Error processing arguments");
        auto result = cocos2d::TransitionShrinkGrow::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionShrinkGrow_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionShrinkGrow_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionShrinkGrow_finalize)

static bool js_cocos2dx_TransitionShrinkGrow_constructor(se::State& s)
{
    cocos2d::TransitionShrinkGrow* cobj = new (std::nothrow) cocos2d::TransitionShrinkGrow();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionShrinkGrow_constructor, __jsb_cocos2d_TransitionShrinkGrow_class, js_cocos2d_TransitionShrinkGrow_finalize)

static bool js_cocos2dx_TransitionShrinkGrow_ctor(se::State& s)
{
    cocos2d::TransitionShrinkGrow* cobj = new (std::nothrow) cocos2d::TransitionShrinkGrow();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionShrinkGrow_ctor, __jsb_cocos2d_TransitionShrinkGrow_class, js_cocos2d_TransitionShrinkGrow_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionShrinkGrow_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionShrinkGrow)", s.nativeThisObject());
        cocos2d::TransitionShrinkGrow* cobj = (cocos2d::TransitionShrinkGrow*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionShrinkGrow_finalize)

bool js_register_cocos2dx_TransitionShrinkGrow(se::Object* obj)
{
    auto cls = se::Class::create("TransitionShrinkGrow", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionShrinkGrow_constructor));

    cls->defineFunction("easeActionWithAction", _SE(js_cocos2dx_TransitionShrinkGrow_easeActionWithAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionShrinkGrow_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionShrinkGrow_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionShrinkGrow_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionShrinkGrow>(cls);

    __jsb_cocos2d_TransitionShrinkGrow_proto = cls->getProto();
    __jsb_cocos2d_TransitionShrinkGrow_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionShrinkGrow.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionFlipX_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionFlipX_class = nullptr;

static bool js_cocos2dx_TransitionFlipX_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionFlipX* result = cocos2d::TransitionFlipX::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::TransitionFlipX>((cocos2d::TransitionFlipX*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFlipX_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionScene::Orientation arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionFlipX* result = cocos2d::TransitionFlipX::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::TransitionFlipX>((cocos2d::TransitionFlipX*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFlipX_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionFlipX_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionFlipX_finalize)

static bool js_cocos2dx_TransitionFlipX_constructor(se::State& s)
{
    cocos2d::TransitionFlipX* cobj = new (std::nothrow) cocos2d::TransitionFlipX();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionFlipX_constructor, __jsb_cocos2d_TransitionFlipX_class, js_cocos2d_TransitionFlipX_finalize)

static bool js_cocos2dx_TransitionFlipX_ctor(se::State& s)
{
    cocos2d::TransitionFlipX* cobj = new (std::nothrow) cocos2d::TransitionFlipX();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionFlipX_ctor, __jsb_cocos2d_TransitionFlipX_class, js_cocos2d_TransitionFlipX_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionSceneOriented_proto;

bool js_cocos2d_TransitionFlipX_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionFlipX)", s.nativeThisObject());
        cocos2d::TransitionFlipX* cobj = (cocos2d::TransitionFlipX*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionFlipX_finalize)

bool js_register_cocos2dx_TransitionFlipX(se::Object* obj)
{
    auto cls = se::Class::create("TransitionFlipX", obj, __jsb_cocos2d_TransitionSceneOriented_proto, _SE(js_cocos2dx_TransitionFlipX_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionFlipX_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionFlipX_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionFlipX_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionFlipX>(cls);

    __jsb_cocos2d_TransitionFlipX_proto = cls->getProto();
    __jsb_cocos2d_TransitionFlipX_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionFlipX.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionFlipY_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionFlipY_class = nullptr;

static bool js_cocos2dx_TransitionFlipY_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionFlipY* result = cocos2d::TransitionFlipY::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::TransitionFlipY>((cocos2d::TransitionFlipY*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFlipY_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionScene::Orientation arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionFlipY* result = cocos2d::TransitionFlipY::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::TransitionFlipY>((cocos2d::TransitionFlipY*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFlipY_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionFlipY_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionFlipY_finalize)

static bool js_cocos2dx_TransitionFlipY_constructor(se::State& s)
{
    cocos2d::TransitionFlipY* cobj = new (std::nothrow) cocos2d::TransitionFlipY();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionFlipY_constructor, __jsb_cocos2d_TransitionFlipY_class, js_cocos2d_TransitionFlipY_finalize)

static bool js_cocos2dx_TransitionFlipY_ctor(se::State& s)
{
    cocos2d::TransitionFlipY* cobj = new (std::nothrow) cocos2d::TransitionFlipY();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionFlipY_ctor, __jsb_cocos2d_TransitionFlipY_class, js_cocos2d_TransitionFlipY_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionSceneOriented_proto;

bool js_cocos2d_TransitionFlipY_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionFlipY)", s.nativeThisObject());
        cocos2d::TransitionFlipY* cobj = (cocos2d::TransitionFlipY*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionFlipY_finalize)

bool js_register_cocos2dx_TransitionFlipY(se::Object* obj)
{
    auto cls = se::Class::create("TransitionFlipY", obj, __jsb_cocos2d_TransitionSceneOriented_proto, _SE(js_cocos2dx_TransitionFlipY_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionFlipY_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionFlipY_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionFlipY_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionFlipY>(cls);

    __jsb_cocos2d_TransitionFlipY_proto = cls->getProto();
    __jsb_cocos2d_TransitionFlipY_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionFlipY.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionFlipAngular_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionFlipAngular_class = nullptr;

static bool js_cocos2dx_TransitionFlipAngular_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionFlipAngular* result = cocos2d::TransitionFlipAngular::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::TransitionFlipAngular>((cocos2d::TransitionFlipAngular*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFlipAngular_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionScene::Orientation arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionFlipAngular* result = cocos2d::TransitionFlipAngular::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::TransitionFlipAngular>((cocos2d::TransitionFlipAngular*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFlipAngular_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionFlipAngular_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionFlipAngular_finalize)

static bool js_cocos2dx_TransitionFlipAngular_constructor(se::State& s)
{
    cocos2d::TransitionFlipAngular* cobj = new (std::nothrow) cocos2d::TransitionFlipAngular();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionFlipAngular_constructor, __jsb_cocos2d_TransitionFlipAngular_class, js_cocos2d_TransitionFlipAngular_finalize)

static bool js_cocos2dx_TransitionFlipAngular_ctor(se::State& s)
{
    cocos2d::TransitionFlipAngular* cobj = new (std::nothrow) cocos2d::TransitionFlipAngular();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionFlipAngular_ctor, __jsb_cocos2d_TransitionFlipAngular_class, js_cocos2d_TransitionFlipAngular_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionSceneOriented_proto;

bool js_cocos2d_TransitionFlipAngular_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionFlipAngular)", s.nativeThisObject());
        cocos2d::TransitionFlipAngular* cobj = (cocos2d::TransitionFlipAngular*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionFlipAngular_finalize)

bool js_register_cocos2dx_TransitionFlipAngular(se::Object* obj)
{
    auto cls = se::Class::create("TransitionFlipAngular", obj, __jsb_cocos2d_TransitionSceneOriented_proto, _SE(js_cocos2dx_TransitionFlipAngular_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionFlipAngular_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionFlipAngular_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionFlipAngular_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionFlipAngular>(cls);

    __jsb_cocos2d_TransitionFlipAngular_proto = cls->getProto();
    __jsb_cocos2d_TransitionFlipAngular_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionFlipAngular.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionZoomFlipX_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionZoomFlipX_class = nullptr;

static bool js_cocos2dx_TransitionZoomFlipX_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionZoomFlipX* result = cocos2d::TransitionZoomFlipX::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::TransitionZoomFlipX>((cocos2d::TransitionZoomFlipX*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionZoomFlipX_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionScene::Orientation arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionZoomFlipX* result = cocos2d::TransitionZoomFlipX::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::TransitionZoomFlipX>((cocos2d::TransitionZoomFlipX*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionZoomFlipX_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionZoomFlipX_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionZoomFlipX_finalize)

static bool js_cocos2dx_TransitionZoomFlipX_constructor(se::State& s)
{
    cocos2d::TransitionZoomFlipX* cobj = new (std::nothrow) cocos2d::TransitionZoomFlipX();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionZoomFlipX_constructor, __jsb_cocos2d_TransitionZoomFlipX_class, js_cocos2d_TransitionZoomFlipX_finalize)

static bool js_cocos2dx_TransitionZoomFlipX_ctor(se::State& s)
{
    cocos2d::TransitionZoomFlipX* cobj = new (std::nothrow) cocos2d::TransitionZoomFlipX();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionZoomFlipX_ctor, __jsb_cocos2d_TransitionZoomFlipX_class, js_cocos2d_TransitionZoomFlipX_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionSceneOriented_proto;

bool js_cocos2d_TransitionZoomFlipX_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionZoomFlipX)", s.nativeThisObject());
        cocos2d::TransitionZoomFlipX* cobj = (cocos2d::TransitionZoomFlipX*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionZoomFlipX_finalize)

bool js_register_cocos2dx_TransitionZoomFlipX(se::Object* obj)
{
    auto cls = se::Class::create("TransitionZoomFlipX", obj, __jsb_cocos2d_TransitionSceneOriented_proto, _SE(js_cocos2dx_TransitionZoomFlipX_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionZoomFlipX_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionZoomFlipX_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionZoomFlipX_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionZoomFlipX>(cls);

    __jsb_cocos2d_TransitionZoomFlipX_proto = cls->getProto();
    __jsb_cocos2d_TransitionZoomFlipX_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionZoomFlipX.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionZoomFlipY_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionZoomFlipY_class = nullptr;

static bool js_cocos2dx_TransitionZoomFlipY_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionZoomFlipY* result = cocos2d::TransitionZoomFlipY::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::TransitionZoomFlipY>((cocos2d::TransitionZoomFlipY*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionZoomFlipY_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionScene::Orientation arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionZoomFlipY* result = cocos2d::TransitionZoomFlipY::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::TransitionZoomFlipY>((cocos2d::TransitionZoomFlipY*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionZoomFlipY_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionZoomFlipY_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionZoomFlipY_finalize)

static bool js_cocos2dx_TransitionZoomFlipY_constructor(se::State& s)
{
    cocos2d::TransitionZoomFlipY* cobj = new (std::nothrow) cocos2d::TransitionZoomFlipY();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionZoomFlipY_constructor, __jsb_cocos2d_TransitionZoomFlipY_class, js_cocos2d_TransitionZoomFlipY_finalize)

static bool js_cocos2dx_TransitionZoomFlipY_ctor(se::State& s)
{
    cocos2d::TransitionZoomFlipY* cobj = new (std::nothrow) cocos2d::TransitionZoomFlipY();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionZoomFlipY_ctor, __jsb_cocos2d_TransitionZoomFlipY_class, js_cocos2d_TransitionZoomFlipY_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionSceneOriented_proto;

bool js_cocos2d_TransitionZoomFlipY_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionZoomFlipY)", s.nativeThisObject());
        cocos2d::TransitionZoomFlipY* cobj = (cocos2d::TransitionZoomFlipY*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionZoomFlipY_finalize)

bool js_register_cocos2dx_TransitionZoomFlipY(se::Object* obj)
{
    auto cls = se::Class::create("TransitionZoomFlipY", obj, __jsb_cocos2d_TransitionSceneOriented_proto, _SE(js_cocos2dx_TransitionZoomFlipY_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionZoomFlipY_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionZoomFlipY_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionZoomFlipY_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionZoomFlipY>(cls);

    __jsb_cocos2d_TransitionZoomFlipY_proto = cls->getProto();
    __jsb_cocos2d_TransitionZoomFlipY_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionZoomFlipY.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionZoomFlipAngular_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionZoomFlipAngular_class = nullptr;

static bool js_cocos2dx_TransitionZoomFlipAngular_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionZoomFlipAngular* result = cocos2d::TransitionZoomFlipAngular::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::TransitionZoomFlipAngular>((cocos2d::TransitionZoomFlipAngular*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionZoomFlipAngular_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionScene::Orientation arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionZoomFlipAngular* result = cocos2d::TransitionZoomFlipAngular::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::TransitionZoomFlipAngular>((cocos2d::TransitionZoomFlipAngular*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionZoomFlipAngular_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionZoomFlipAngular_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionZoomFlipAngular_finalize)

static bool js_cocos2dx_TransitionZoomFlipAngular_constructor(se::State& s)
{
    cocos2d::TransitionZoomFlipAngular* cobj = new (std::nothrow) cocos2d::TransitionZoomFlipAngular();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionZoomFlipAngular_constructor, __jsb_cocos2d_TransitionZoomFlipAngular_class, js_cocos2d_TransitionZoomFlipAngular_finalize)

static bool js_cocos2dx_TransitionZoomFlipAngular_ctor(se::State& s)
{
    cocos2d::TransitionZoomFlipAngular* cobj = new (std::nothrow) cocos2d::TransitionZoomFlipAngular();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionZoomFlipAngular_ctor, __jsb_cocos2d_TransitionZoomFlipAngular_class, js_cocos2d_TransitionZoomFlipAngular_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionSceneOriented_proto;

bool js_cocos2d_TransitionZoomFlipAngular_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionZoomFlipAngular)", s.nativeThisObject());
        cocos2d::TransitionZoomFlipAngular* cobj = (cocos2d::TransitionZoomFlipAngular*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionZoomFlipAngular_finalize)

bool js_register_cocos2dx_TransitionZoomFlipAngular(se::Object* obj)
{
    auto cls = se::Class::create("TransitionZoomFlipAngular", obj, __jsb_cocos2d_TransitionSceneOriented_proto, _SE(js_cocos2dx_TransitionZoomFlipAngular_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionZoomFlipAngular_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionZoomFlipAngular_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionZoomFlipAngular_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionZoomFlipAngular>(cls);

    __jsb_cocos2d_TransitionZoomFlipAngular_proto = cls->getProto();
    __jsb_cocos2d_TransitionZoomFlipAngular_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionZoomFlipAngular.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionFade_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionFade_class = nullptr;

static bool js_cocos2dx_TransitionFade_initWithDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TransitionFade* cobj = (cocos2d::TransitionFade*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TransitionFade_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFade_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg2;
            ok &= seval_to_Color3B(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFade_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionFade_initWithDuration)

static bool js_cocos2dx_TransitionFade_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionFade* result = cocos2d::TransitionFade::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::TransitionFade>((cocos2d::TransitionFade*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFade_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Scene* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg2;
            ok &= seval_to_Color3B(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TransitionFade* result = cocos2d::TransitionFade::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::TransitionFade>((cocos2d::TransitionFade*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFade_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionFade_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionFade_finalize)

static bool js_cocos2dx_TransitionFade_constructor(se::State& s)
{
    cocos2d::TransitionFade* cobj = new (std::nothrow) cocos2d::TransitionFade();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionFade_constructor, __jsb_cocos2d_TransitionFade_class, js_cocos2d_TransitionFade_finalize)

static bool js_cocos2dx_TransitionFade_ctor(se::State& s)
{
    cocos2d::TransitionFade* cobj = new (std::nothrow) cocos2d::TransitionFade();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionFade_ctor, __jsb_cocos2d_TransitionFade_class, js_cocos2d_TransitionFade_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionFade_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionFade)", s.nativeThisObject());
        cocos2d::TransitionFade* cobj = (cocos2d::TransitionFade*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionFade_finalize)

bool js_register_cocos2dx_TransitionFade(se::Object* obj)
{
    auto cls = se::Class::create("TransitionFade", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionFade_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_TransitionFade_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionFade_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionFade_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionFade_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionFade>(cls);

    __jsb_cocos2d_TransitionFade_proto = cls->getProto();
    __jsb_cocos2d_TransitionFade_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionFade.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionCrossFade_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionCrossFade_class = nullptr;

static bool js_cocos2dx_TransitionCrossFade_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionCrossFade_create : Error processing arguments");
        auto result = cocos2d::TransitionCrossFade::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionCrossFade_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionCrossFade_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionCrossFade_finalize)

static bool js_cocos2dx_TransitionCrossFade_constructor(se::State& s)
{
    cocos2d::TransitionCrossFade* cobj = new (std::nothrow) cocos2d::TransitionCrossFade();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionCrossFade_constructor, __jsb_cocos2d_TransitionCrossFade_class, js_cocos2d_TransitionCrossFade_finalize)

static bool js_cocos2dx_TransitionCrossFade_ctor(se::State& s)
{
    cocos2d::TransitionCrossFade* cobj = new (std::nothrow) cocos2d::TransitionCrossFade();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionCrossFade_ctor, __jsb_cocos2d_TransitionCrossFade_class, js_cocos2d_TransitionCrossFade_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionCrossFade_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionCrossFade)", s.nativeThisObject());
        cocos2d::TransitionCrossFade* cobj = (cocos2d::TransitionCrossFade*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionCrossFade_finalize)

bool js_register_cocos2dx_TransitionCrossFade(se::Object* obj)
{
    auto cls = se::Class::create("TransitionCrossFade", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionCrossFade_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionCrossFade_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionCrossFade_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionCrossFade_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionCrossFade>(cls);

    __jsb_cocos2d_TransitionCrossFade_proto = cls->getProto();
    __jsb_cocos2d_TransitionCrossFade_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionCrossFade.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionTurnOffTiles_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionTurnOffTiles_class = nullptr;

static bool js_cocos2dx_TransitionTurnOffTiles_easeActionWithAction(se::State& s)
{
    cocos2d::TransitionTurnOffTiles* cobj = (cocos2d::TransitionTurnOffTiles*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionTurnOffTiles_easeActionWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionTurnOffTiles_easeActionWithAction : Error processing arguments");
        cocos2d::ActionInterval* result = cobj->easeActionWithAction(arg0);
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionTurnOffTiles_easeActionWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionTurnOffTiles_easeActionWithAction)

static bool js_cocos2dx_TransitionTurnOffTiles_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionTurnOffTiles_create : Error processing arguments");
        auto result = cocos2d::TransitionTurnOffTiles::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionTurnOffTiles_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionTurnOffTiles_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionTurnOffTiles_finalize)

static bool js_cocos2dx_TransitionTurnOffTiles_constructor(se::State& s)
{
    cocos2d::TransitionTurnOffTiles* cobj = new (std::nothrow) cocos2d::TransitionTurnOffTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionTurnOffTiles_constructor, __jsb_cocos2d_TransitionTurnOffTiles_class, js_cocos2d_TransitionTurnOffTiles_finalize)

static bool js_cocos2dx_TransitionTurnOffTiles_ctor(se::State& s)
{
    cocos2d::TransitionTurnOffTiles* cobj = new (std::nothrow) cocos2d::TransitionTurnOffTiles();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionTurnOffTiles_ctor, __jsb_cocos2d_TransitionTurnOffTiles_class, js_cocos2d_TransitionTurnOffTiles_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionTurnOffTiles_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionTurnOffTiles)", s.nativeThisObject());
        cocos2d::TransitionTurnOffTiles* cobj = (cocos2d::TransitionTurnOffTiles*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionTurnOffTiles_finalize)

bool js_register_cocos2dx_TransitionTurnOffTiles(se::Object* obj)
{
    auto cls = se::Class::create("TransitionTurnOffTiles", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionTurnOffTiles_constructor));

    cls->defineFunction("easeActionWithAction", _SE(js_cocos2dx_TransitionTurnOffTiles_easeActionWithAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionTurnOffTiles_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionTurnOffTiles_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionTurnOffTiles_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionTurnOffTiles>(cls);

    __jsb_cocos2d_TransitionTurnOffTiles_proto = cls->getProto();
    __jsb_cocos2d_TransitionTurnOffTiles_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionTurnOffTiles.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionSplitCols_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionSplitCols_class = nullptr;

static bool js_cocos2dx_TransitionSplitCols_action(se::State& s)
{
    cocos2d::TransitionSplitCols* cobj = (cocos2d::TransitionSplitCols*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionSplitCols_action : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ActionInterval* result = cobj->action();
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSplitCols_action : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSplitCols_action)

static bool js_cocos2dx_TransitionSplitCols_easeActionWithAction(se::State& s)
{
    cocos2d::TransitionSplitCols* cobj = (cocos2d::TransitionSplitCols*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionSplitCols_easeActionWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSplitCols_easeActionWithAction : Error processing arguments");
        cocos2d::ActionInterval* result = cobj->easeActionWithAction(arg0);
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSplitCols_easeActionWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSplitCols_easeActionWithAction)

static bool js_cocos2dx_TransitionSplitCols_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSplitCols_create : Error processing arguments");
        auto result = cocos2d::TransitionSplitCols::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionSplitCols_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSplitCols_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionSplitCols_finalize)

static bool js_cocos2dx_TransitionSplitCols_constructor(se::State& s)
{
    cocos2d::TransitionSplitCols* cobj = new (std::nothrow) cocos2d::TransitionSplitCols();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionSplitCols_constructor, __jsb_cocos2d_TransitionSplitCols_class, js_cocos2d_TransitionSplitCols_finalize)

static bool js_cocos2dx_TransitionSplitCols_ctor(se::State& s)
{
    cocos2d::TransitionSplitCols* cobj = new (std::nothrow) cocos2d::TransitionSplitCols();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionSplitCols_ctor, __jsb_cocos2d_TransitionSplitCols_class, js_cocos2d_TransitionSplitCols_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionSplitCols_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionSplitCols)", s.nativeThisObject());
        cocos2d::TransitionSplitCols* cobj = (cocos2d::TransitionSplitCols*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionSplitCols_finalize)

bool js_register_cocos2dx_TransitionSplitCols(se::Object* obj)
{
    auto cls = se::Class::create("TransitionSplitCols", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionSplitCols_constructor));

    cls->defineFunction("action", _SE(js_cocos2dx_TransitionSplitCols_action));
    cls->defineFunction("easeActionWithAction", _SE(js_cocos2dx_TransitionSplitCols_easeActionWithAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionSplitCols_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionSplitCols_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionSplitCols_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionSplitCols>(cls);

    __jsb_cocos2d_TransitionSplitCols_proto = cls->getProto();
    __jsb_cocos2d_TransitionSplitCols_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionSplitCols.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionSplitRows_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionSplitRows_class = nullptr;

static bool js_cocos2dx_TransitionSplitRows_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionSplitRows_create : Error processing arguments");
        auto result = cocos2d::TransitionSplitRows::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionSplitRows_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionSplitRows_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionSplitRows_finalize)

static bool js_cocos2dx_TransitionSplitRows_constructor(se::State& s)
{
    cocos2d::TransitionSplitRows* cobj = new (std::nothrow) cocos2d::TransitionSplitRows();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionSplitRows_constructor, __jsb_cocos2d_TransitionSplitRows_class, js_cocos2d_TransitionSplitRows_finalize)

static bool js_cocos2dx_TransitionSplitRows_ctor(se::State& s)
{
    cocos2d::TransitionSplitRows* cobj = new (std::nothrow) cocos2d::TransitionSplitRows();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionSplitRows_ctor, __jsb_cocos2d_TransitionSplitRows_class, js_cocos2d_TransitionSplitRows_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionSplitCols_proto;

bool js_cocos2d_TransitionSplitRows_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionSplitRows)", s.nativeThisObject());
        cocos2d::TransitionSplitRows* cobj = (cocos2d::TransitionSplitRows*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionSplitRows_finalize)

bool js_register_cocos2dx_TransitionSplitRows(se::Object* obj)
{
    auto cls = se::Class::create("TransitionSplitRows", obj, __jsb_cocos2d_TransitionSplitCols_proto, _SE(js_cocos2dx_TransitionSplitRows_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionSplitRows_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionSplitRows_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionSplitRows_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionSplitRows>(cls);

    __jsb_cocos2d_TransitionSplitRows_proto = cls->getProto();
    __jsb_cocos2d_TransitionSplitRows_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionSplitRows.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionFadeTR_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionFadeTR_class = nullptr;

static bool js_cocos2dx_TransitionFadeTR_easeActionWithAction(se::State& s)
{
    cocos2d::TransitionFadeTR* cobj = (cocos2d::TransitionFadeTR*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionFadeTR_easeActionWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFadeTR_easeActionWithAction : Error processing arguments");
        cocos2d::ActionInterval* result = cobj->easeActionWithAction(arg0);
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFadeTR_easeActionWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionFadeTR_easeActionWithAction)

static bool js_cocos2dx_TransitionFadeTR_actionWithSize(se::State& s)
{
    cocos2d::TransitionFadeTR* cobj = (cocos2d::TransitionFadeTR*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionFadeTR_actionWithSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFadeTR_actionWithSize : Error processing arguments");
        cocos2d::ActionInterval* result = cobj->actionWithSize(arg0);
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFadeTR_actionWithSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionFadeTR_actionWithSize)

static bool js_cocos2dx_TransitionFadeTR_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFadeTR_create : Error processing arguments");
        auto result = cocos2d::TransitionFadeTR::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionFadeTR_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionFadeTR_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionFadeTR_finalize)

static bool js_cocos2dx_TransitionFadeTR_constructor(se::State& s)
{
    cocos2d::TransitionFadeTR* cobj = new (std::nothrow) cocos2d::TransitionFadeTR();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionFadeTR_constructor, __jsb_cocos2d_TransitionFadeTR_class, js_cocos2d_TransitionFadeTR_finalize)

static bool js_cocos2dx_TransitionFadeTR_ctor(se::State& s)
{
    cocos2d::TransitionFadeTR* cobj = new (std::nothrow) cocos2d::TransitionFadeTR();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionFadeTR_ctor, __jsb_cocos2d_TransitionFadeTR_class, js_cocos2d_TransitionFadeTR_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionFadeTR_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionFadeTR)", s.nativeThisObject());
        cocos2d::TransitionFadeTR* cobj = (cocos2d::TransitionFadeTR*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionFadeTR_finalize)

bool js_register_cocos2dx_TransitionFadeTR(se::Object* obj)
{
    auto cls = se::Class::create("TransitionFadeTR", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionFadeTR_constructor));

    cls->defineFunction("easeActionWithAction", _SE(js_cocos2dx_TransitionFadeTR_easeActionWithAction));
    cls->defineFunction("actionWithSize", _SE(js_cocos2dx_TransitionFadeTR_actionWithSize));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionFadeTR_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionFadeTR_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionFadeTR_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionFadeTR>(cls);

    __jsb_cocos2d_TransitionFadeTR_proto = cls->getProto();
    __jsb_cocos2d_TransitionFadeTR_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionFadeTR.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionFadeBL_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionFadeBL_class = nullptr;

static bool js_cocos2dx_TransitionFadeBL_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFadeBL_create : Error processing arguments");
        auto result = cocos2d::TransitionFadeBL::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionFadeBL_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionFadeBL_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionFadeBL_finalize)

static bool js_cocos2dx_TransitionFadeBL_constructor(se::State& s)
{
    cocos2d::TransitionFadeBL* cobj = new (std::nothrow) cocos2d::TransitionFadeBL();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionFadeBL_constructor, __jsb_cocos2d_TransitionFadeBL_class, js_cocos2d_TransitionFadeBL_finalize)

static bool js_cocos2dx_TransitionFadeBL_ctor(se::State& s)
{
    cocos2d::TransitionFadeBL* cobj = new (std::nothrow) cocos2d::TransitionFadeBL();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionFadeBL_ctor, __jsb_cocos2d_TransitionFadeBL_class, js_cocos2d_TransitionFadeBL_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionFadeTR_proto;

bool js_cocos2d_TransitionFadeBL_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionFadeBL)", s.nativeThisObject());
        cocos2d::TransitionFadeBL* cobj = (cocos2d::TransitionFadeBL*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionFadeBL_finalize)

bool js_register_cocos2dx_TransitionFadeBL(se::Object* obj)
{
    auto cls = se::Class::create("TransitionFadeBL", obj, __jsb_cocos2d_TransitionFadeTR_proto, _SE(js_cocos2dx_TransitionFadeBL_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionFadeBL_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionFadeBL_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionFadeBL_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionFadeBL>(cls);

    __jsb_cocos2d_TransitionFadeBL_proto = cls->getProto();
    __jsb_cocos2d_TransitionFadeBL_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionFadeBL.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionFadeUp_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionFadeUp_class = nullptr;

static bool js_cocos2dx_TransitionFadeUp_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFadeUp_create : Error processing arguments");
        auto result = cocos2d::TransitionFadeUp::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionFadeUp_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionFadeUp_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionFadeUp_finalize)

static bool js_cocos2dx_TransitionFadeUp_constructor(se::State& s)
{
    cocos2d::TransitionFadeUp* cobj = new (std::nothrow) cocos2d::TransitionFadeUp();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionFadeUp_constructor, __jsb_cocos2d_TransitionFadeUp_class, js_cocos2d_TransitionFadeUp_finalize)

static bool js_cocos2dx_TransitionFadeUp_ctor(se::State& s)
{
    cocos2d::TransitionFadeUp* cobj = new (std::nothrow) cocos2d::TransitionFadeUp();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionFadeUp_ctor, __jsb_cocos2d_TransitionFadeUp_class, js_cocos2d_TransitionFadeUp_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionFadeTR_proto;

bool js_cocos2d_TransitionFadeUp_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionFadeUp)", s.nativeThisObject());
        cocos2d::TransitionFadeUp* cobj = (cocos2d::TransitionFadeUp*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionFadeUp_finalize)

bool js_register_cocos2dx_TransitionFadeUp(se::Object* obj)
{
    auto cls = se::Class::create("TransitionFadeUp", obj, __jsb_cocos2d_TransitionFadeTR_proto, _SE(js_cocos2dx_TransitionFadeUp_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionFadeUp_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionFadeUp_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionFadeUp_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionFadeUp>(cls);

    __jsb_cocos2d_TransitionFadeUp_proto = cls->getProto();
    __jsb_cocos2d_TransitionFadeUp_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionFadeUp.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionFadeDown_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionFadeDown_class = nullptr;

static bool js_cocos2dx_TransitionFadeDown_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionFadeDown_create : Error processing arguments");
        auto result = cocos2d::TransitionFadeDown::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionFadeDown_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionFadeDown_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionFadeDown_finalize)

static bool js_cocos2dx_TransitionFadeDown_constructor(se::State& s)
{
    cocos2d::TransitionFadeDown* cobj = new (std::nothrow) cocos2d::TransitionFadeDown();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionFadeDown_constructor, __jsb_cocos2d_TransitionFadeDown_class, js_cocos2d_TransitionFadeDown_finalize)

static bool js_cocos2dx_TransitionFadeDown_ctor(se::State& s)
{
    cocos2d::TransitionFadeDown* cobj = new (std::nothrow) cocos2d::TransitionFadeDown();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionFadeDown_ctor, __jsb_cocos2d_TransitionFadeDown_class, js_cocos2d_TransitionFadeDown_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionFadeTR_proto;

bool js_cocos2d_TransitionFadeDown_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionFadeDown)", s.nativeThisObject());
        cocos2d::TransitionFadeDown* cobj = (cocos2d::TransitionFadeDown*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionFadeDown_finalize)

bool js_register_cocos2dx_TransitionFadeDown(se::Object* obj)
{
    auto cls = se::Class::create("TransitionFadeDown", obj, __jsb_cocos2d_TransitionFadeTR_proto, _SE(js_cocos2dx_TransitionFadeDown_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionFadeDown_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionFadeDown_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionFadeDown_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionFadeDown>(cls);

    __jsb_cocos2d_TransitionFadeDown_proto = cls->getProto();
    __jsb_cocos2d_TransitionFadeDown_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionFadeDown.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionPageTurn_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionPageTurn_class = nullptr;

static bool js_cocos2dx_TransitionPageTurn_actionWithSize(se::State& s)
{
    cocos2d::TransitionPageTurn* cobj = (cocos2d::TransitionPageTurn*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionPageTurn_actionWithSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionPageTurn_actionWithSize : Error processing arguments");
        cocos2d::ActionInterval* result = cobj->actionWithSize(arg0);
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionPageTurn_actionWithSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionPageTurn_actionWithSize)

static bool js_cocos2dx_TransitionPageTurn_initWithDuration(se::State& s)
{
    cocos2d::TransitionPageTurn* cobj = (cocos2d::TransitionPageTurn*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TransitionPageTurn_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        bool arg2;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_boolean(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionPageTurn_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionPageTurn_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionPageTurn_initWithDuration)

static bool js_cocos2dx_TransitionPageTurn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        bool arg2;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_boolean(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionPageTurn_create : Error processing arguments");
        auto result = cocos2d::TransitionPageTurn::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionPageTurn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionPageTurn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionPageTurn_finalize)

static bool js_cocos2dx_TransitionPageTurn_constructor(se::State& s)
{
    cocos2d::TransitionPageTurn* cobj = new (std::nothrow) cocos2d::TransitionPageTurn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionPageTurn_constructor, __jsb_cocos2d_TransitionPageTurn_class, js_cocos2d_TransitionPageTurn_finalize)

static bool js_cocos2dx_TransitionPageTurn_ctor(se::State& s)
{
    cocos2d::TransitionPageTurn* cobj = new (std::nothrow) cocos2d::TransitionPageTurn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionPageTurn_ctor, __jsb_cocos2d_TransitionPageTurn_class, js_cocos2d_TransitionPageTurn_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionPageTurn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionPageTurn)", s.nativeThisObject());
        cocos2d::TransitionPageTurn* cobj = (cocos2d::TransitionPageTurn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionPageTurn_finalize)

bool js_register_cocos2dx_TransitionPageTurn(se::Object* obj)
{
    auto cls = se::Class::create("TransitionPageTurn", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionPageTurn_constructor));

    cls->defineFunction("actionWithSize", _SE(js_cocos2dx_TransitionPageTurn_actionWithSize));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_TransitionPageTurn_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionPageTurn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionPageTurn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionPageTurn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionPageTurn>(cls);

    __jsb_cocos2d_TransitionPageTurn_proto = cls->getProto();
    __jsb_cocos2d_TransitionPageTurn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionPageTurn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionProgress_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionProgress_class = nullptr;

static bool js_cocos2dx_TransitionProgress_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionProgress_create : Error processing arguments");
        auto result = cocos2d::TransitionProgress::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionProgress_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionProgress_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionProgress_finalize)

static bool js_cocos2dx_TransitionProgress_constructor(se::State& s)
{
    cocos2d::TransitionProgress* cobj = new (std::nothrow) cocos2d::TransitionProgress();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionProgress_constructor, __jsb_cocos2d_TransitionProgress_class, js_cocos2d_TransitionProgress_finalize)

static bool js_cocos2dx_TransitionProgress_ctor(se::State& s)
{
    cocos2d::TransitionProgress* cobj = new (std::nothrow) cocos2d::TransitionProgress();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionProgress_ctor, __jsb_cocos2d_TransitionProgress_class, js_cocos2d_TransitionProgress_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionScene_proto;

bool js_cocos2d_TransitionProgress_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionProgress)", s.nativeThisObject());
        cocos2d::TransitionProgress* cobj = (cocos2d::TransitionProgress*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionProgress_finalize)

bool js_register_cocos2dx_TransitionProgress(se::Object* obj)
{
    auto cls = se::Class::create("TransitionProgress", obj, __jsb_cocos2d_TransitionScene_proto, _SE(js_cocos2dx_TransitionProgress_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionProgress_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionProgress_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionProgress_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionProgress>(cls);

    __jsb_cocos2d_TransitionProgress_proto = cls->getProto();
    __jsb_cocos2d_TransitionProgress_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionProgress.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionProgressRadialCCW_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionProgressRadialCCW_class = nullptr;

static bool js_cocos2dx_TransitionProgressRadialCCW_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionProgressRadialCCW_create : Error processing arguments");
        auto result = cocos2d::TransitionProgressRadialCCW::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionProgressRadialCCW_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionProgressRadialCCW_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionProgressRadialCCW_finalize)

static bool js_cocos2dx_TransitionProgressRadialCCW_constructor(se::State& s)
{
    cocos2d::TransitionProgressRadialCCW* cobj = new (std::nothrow) cocos2d::TransitionProgressRadialCCW();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionProgressRadialCCW_constructor, __jsb_cocos2d_TransitionProgressRadialCCW_class, js_cocos2d_TransitionProgressRadialCCW_finalize)

static bool js_cocos2dx_TransitionProgressRadialCCW_ctor(se::State& s)
{
    cocos2d::TransitionProgressRadialCCW* cobj = new (std::nothrow) cocos2d::TransitionProgressRadialCCW();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionProgressRadialCCW_ctor, __jsb_cocos2d_TransitionProgressRadialCCW_class, js_cocos2d_TransitionProgressRadialCCW_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionProgress_proto;

bool js_cocos2d_TransitionProgressRadialCCW_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionProgressRadialCCW)", s.nativeThisObject());
        cocos2d::TransitionProgressRadialCCW* cobj = (cocos2d::TransitionProgressRadialCCW*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionProgressRadialCCW_finalize)

bool js_register_cocos2dx_TransitionProgressRadialCCW(se::Object* obj)
{
    auto cls = se::Class::create("TransitionProgressRadialCCW", obj, __jsb_cocos2d_TransitionProgress_proto, _SE(js_cocos2dx_TransitionProgressRadialCCW_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionProgressRadialCCW_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionProgressRadialCCW_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionProgressRadialCCW_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionProgressRadialCCW>(cls);

    __jsb_cocos2d_TransitionProgressRadialCCW_proto = cls->getProto();
    __jsb_cocos2d_TransitionProgressRadialCCW_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionProgressRadialCCW.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionProgressRadialCW_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionProgressRadialCW_class = nullptr;

static bool js_cocos2dx_TransitionProgressRadialCW_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionProgressRadialCW_create : Error processing arguments");
        auto result = cocos2d::TransitionProgressRadialCW::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionProgressRadialCW_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionProgressRadialCW_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionProgressRadialCW_finalize)

static bool js_cocos2dx_TransitionProgressRadialCW_constructor(se::State& s)
{
    cocos2d::TransitionProgressRadialCW* cobj = new (std::nothrow) cocos2d::TransitionProgressRadialCW();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionProgressRadialCW_constructor, __jsb_cocos2d_TransitionProgressRadialCW_class, js_cocos2d_TransitionProgressRadialCW_finalize)

static bool js_cocos2dx_TransitionProgressRadialCW_ctor(se::State& s)
{
    cocos2d::TransitionProgressRadialCW* cobj = new (std::nothrow) cocos2d::TransitionProgressRadialCW();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionProgressRadialCW_ctor, __jsb_cocos2d_TransitionProgressRadialCW_class, js_cocos2d_TransitionProgressRadialCW_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionProgress_proto;

bool js_cocos2d_TransitionProgressRadialCW_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionProgressRadialCW)", s.nativeThisObject());
        cocos2d::TransitionProgressRadialCW* cobj = (cocos2d::TransitionProgressRadialCW*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionProgressRadialCW_finalize)

bool js_register_cocos2dx_TransitionProgressRadialCW(se::Object* obj)
{
    auto cls = se::Class::create("TransitionProgressRadialCW", obj, __jsb_cocos2d_TransitionProgress_proto, _SE(js_cocos2dx_TransitionProgressRadialCW_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionProgressRadialCW_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionProgressRadialCW_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionProgressRadialCW_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionProgressRadialCW>(cls);

    __jsb_cocos2d_TransitionProgressRadialCW_proto = cls->getProto();
    __jsb_cocos2d_TransitionProgressRadialCW_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionProgressRadialCW.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionProgressHorizontal_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionProgressHorizontal_class = nullptr;

static bool js_cocos2dx_TransitionProgressHorizontal_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionProgressHorizontal_create : Error processing arguments");
        auto result = cocos2d::TransitionProgressHorizontal::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionProgressHorizontal_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionProgressHorizontal_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionProgressHorizontal_finalize)

static bool js_cocos2dx_TransitionProgressHorizontal_constructor(se::State& s)
{
    cocos2d::TransitionProgressHorizontal* cobj = new (std::nothrow) cocos2d::TransitionProgressHorizontal();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionProgressHorizontal_constructor, __jsb_cocos2d_TransitionProgressHorizontal_class, js_cocos2d_TransitionProgressHorizontal_finalize)

static bool js_cocos2dx_TransitionProgressHorizontal_ctor(se::State& s)
{
    cocos2d::TransitionProgressHorizontal* cobj = new (std::nothrow) cocos2d::TransitionProgressHorizontal();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionProgressHorizontal_ctor, __jsb_cocos2d_TransitionProgressHorizontal_class, js_cocos2d_TransitionProgressHorizontal_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionProgress_proto;

bool js_cocos2d_TransitionProgressHorizontal_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionProgressHorizontal)", s.nativeThisObject());
        cocos2d::TransitionProgressHorizontal* cobj = (cocos2d::TransitionProgressHorizontal*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionProgressHorizontal_finalize)

bool js_register_cocos2dx_TransitionProgressHorizontal(se::Object* obj)
{
    auto cls = se::Class::create("TransitionProgressHorizontal", obj, __jsb_cocos2d_TransitionProgress_proto, _SE(js_cocos2dx_TransitionProgressHorizontal_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionProgressHorizontal_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionProgressHorizontal_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionProgressHorizontal_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionProgressHorizontal>(cls);

    __jsb_cocos2d_TransitionProgressHorizontal_proto = cls->getProto();
    __jsb_cocos2d_TransitionProgressHorizontal_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionProgressHorizontal.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionProgressVertical_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionProgressVertical_class = nullptr;

static bool js_cocos2dx_TransitionProgressVertical_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionProgressVertical_create : Error processing arguments");
        auto result = cocos2d::TransitionProgressVertical::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionProgressVertical_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionProgressVertical_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionProgressVertical_finalize)

static bool js_cocos2dx_TransitionProgressVertical_constructor(se::State& s)
{
    cocos2d::TransitionProgressVertical* cobj = new (std::nothrow) cocos2d::TransitionProgressVertical();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionProgressVertical_constructor, __jsb_cocos2d_TransitionProgressVertical_class, js_cocos2d_TransitionProgressVertical_finalize)

static bool js_cocos2dx_TransitionProgressVertical_ctor(se::State& s)
{
    cocos2d::TransitionProgressVertical* cobj = new (std::nothrow) cocos2d::TransitionProgressVertical();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionProgressVertical_ctor, __jsb_cocos2d_TransitionProgressVertical_class, js_cocos2d_TransitionProgressVertical_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionProgress_proto;

bool js_cocos2d_TransitionProgressVertical_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionProgressVertical)", s.nativeThisObject());
        cocos2d::TransitionProgressVertical* cobj = (cocos2d::TransitionProgressVertical*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionProgressVertical_finalize)

bool js_register_cocos2dx_TransitionProgressVertical(se::Object* obj)
{
    auto cls = se::Class::create("TransitionProgressVertical", obj, __jsb_cocos2d_TransitionProgress_proto, _SE(js_cocos2dx_TransitionProgressVertical_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionProgressVertical_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionProgressVertical_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionProgressVertical_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionProgressVertical>(cls);

    __jsb_cocos2d_TransitionProgressVertical_proto = cls->getProto();
    __jsb_cocos2d_TransitionProgressVertical_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionProgressVertical.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionProgressInOut_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionProgressInOut_class = nullptr;

static bool js_cocos2dx_TransitionProgressInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionProgressInOut_create : Error processing arguments");
        auto result = cocos2d::TransitionProgressInOut::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionProgressInOut_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionProgressInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionProgressInOut_finalize)

static bool js_cocos2dx_TransitionProgressInOut_constructor(se::State& s)
{
    cocos2d::TransitionProgressInOut* cobj = new (std::nothrow) cocos2d::TransitionProgressInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionProgressInOut_constructor, __jsb_cocos2d_TransitionProgressInOut_class, js_cocos2d_TransitionProgressInOut_finalize)

static bool js_cocos2dx_TransitionProgressInOut_ctor(se::State& s)
{
    cocos2d::TransitionProgressInOut* cobj = new (std::nothrow) cocos2d::TransitionProgressInOut();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionProgressInOut_ctor, __jsb_cocos2d_TransitionProgressInOut_class, js_cocos2d_TransitionProgressInOut_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionProgress_proto;

bool js_cocos2d_TransitionProgressInOut_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionProgressInOut)", s.nativeThisObject());
        cocos2d::TransitionProgressInOut* cobj = (cocos2d::TransitionProgressInOut*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionProgressInOut_finalize)

bool js_register_cocos2dx_TransitionProgressInOut(se::Object* obj)
{
    auto cls = se::Class::create("TransitionProgressInOut", obj, __jsb_cocos2d_TransitionProgress_proto, _SE(js_cocos2dx_TransitionProgressInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionProgressInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionProgressInOut_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionProgressInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionProgressInOut>(cls);

    __jsb_cocos2d_TransitionProgressInOut_proto = cls->getProto();
    __jsb_cocos2d_TransitionProgressInOut_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionProgressInOut.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TransitionProgressOutIn_proto = nullptr;
se::Class* __jsb_cocos2d_TransitionProgressOutIn_class = nullptr;

static bool js_cocos2dx_TransitionProgressOutIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Scene* arg1 = nullptr;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TransitionProgressOutIn_create : Error processing arguments");
        auto result = cocos2d::TransitionProgressOutIn::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TransitionProgressOutIn_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TransitionProgressOutIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TransitionProgressOutIn_finalize)

static bool js_cocos2dx_TransitionProgressOutIn_constructor(se::State& s)
{
    cocos2d::TransitionProgressOutIn* cobj = new (std::nothrow) cocos2d::TransitionProgressOutIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TransitionProgressOutIn_constructor, __jsb_cocos2d_TransitionProgressOutIn_class, js_cocos2d_TransitionProgressOutIn_finalize)

static bool js_cocos2dx_TransitionProgressOutIn_ctor(se::State& s)
{
    cocos2d::TransitionProgressOutIn* cobj = new (std::nothrow) cocos2d::TransitionProgressOutIn();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TransitionProgressOutIn_ctor, __jsb_cocos2d_TransitionProgressOutIn_class, js_cocos2d_TransitionProgressOutIn_finalize)


    

extern se::Object* __jsb_cocos2d_TransitionProgress_proto;

bool js_cocos2d_TransitionProgressOutIn_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TransitionProgressOutIn)", s.nativeThisObject());
        cocos2d::TransitionProgressOutIn* cobj = (cocos2d::TransitionProgressOutIn*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TransitionProgressOutIn_finalize)

bool js_register_cocos2dx_TransitionProgressOutIn(se::Object* obj)
{
    auto cls = se::Class::create("TransitionProgressOutIn", obj, __jsb_cocos2d_TransitionProgress_proto, _SE(js_cocos2dx_TransitionProgressOutIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TransitionProgressOutIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TransitionProgressOutIn_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TransitionProgressOutIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TransitionProgressOutIn>(cls);

    __jsb_cocos2d_TransitionProgressOutIn_proto = cls->getProto();
    __jsb_cocos2d_TransitionProgressOutIn_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TransitionProgressOutIn.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Camera_proto = nullptr;
se::Class* __jsb_cocos2d_Camera_class = nullptr;

static bool js_cocos2dx_Camera_restore(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_restore : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->restore();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_restore)

static bool js_cocos2dx_Camera_getDepth(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_getDepth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int8_t result = cobj->getDepth();
        ok &= int8_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getDepth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getDepth)

static bool js_cocos2dx_Camera_getViewProjectionMatrix(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_getViewProjectionMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Mat4& result = cobj->getViewProjectionMatrix();
        ok &= Mat4_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getViewProjectionMatrix : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getViewProjectionMatrix)

static bool js_cocos2dx_Camera_applyViewport(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_applyViewport : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->applyViewport();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_applyViewport)

static bool js_cocos2dx_Camera_setBackgroundBrush(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_setBackgroundBrush : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::CameraBackgroundBrush* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_setBackgroundBrush : Error processing arguments");
        cobj->setBackgroundBrush(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_setBackgroundBrush)

static bool js_cocos2dx_Camera_lookAt(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_lookAt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec3 arg0;
        ok &= seval_to_Vec3(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_lookAt : Error processing arguments");
        cobj->lookAt(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Vec3 arg0;
        cocos2d::Vec3 arg1;
        ok &= seval_to_Vec3(args[0], &arg0);
        ok &= seval_to_Vec3(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_lookAt : Error processing arguments");
        cobj->lookAt(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_lookAt)

static bool js_cocos2dx_Camera_apply(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_apply : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->apply();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_apply)

static bool js_cocos2dx_Camera_getBackgroundBrush(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_getBackgroundBrush : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::CameraBackgroundBrush* result = cobj->getBackgroundBrush();
        ok &= native_ptr_to_seval<cocos2d::CameraBackgroundBrush>((cocos2d::CameraBackgroundBrush*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getBackgroundBrush : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getBackgroundBrush)

static bool js_cocos2dx_Camera_getProjectionMatrix(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_getProjectionMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Mat4& result = cobj->getProjectionMatrix();
        ok &= Mat4_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getProjectionMatrix : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getProjectionMatrix)

static bool js_cocos2dx_Camera_isBrushValid(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_isBrushValid : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isBrushValid();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_isBrushValid : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_isBrushValid)

static bool js_cocos2dx_Camera_getDepthInView(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_getDepthInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Mat4 arg0;
        ok &= seval_to_Mat4(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getDepthInView : Error processing arguments");
        float result = cobj->getDepthInView(arg0);
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getDepthInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getDepthInView)

static bool js_cocos2dx_Camera_restoreViewport(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_restoreViewport : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->restoreViewport();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_restoreViewport)

static bool js_cocos2dx_Camera_clearBackground(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_clearBackground : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->clearBackground();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_clearBackground)

static bool js_cocos2dx_Camera_setAdditionalProjection(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_setAdditionalProjection : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Mat4 arg0;
        ok &= seval_to_Mat4(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_setAdditionalProjection : Error processing arguments");
        cobj->setAdditionalProjection(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_setAdditionalProjection)

static bool js_cocos2dx_Camera_setViewport(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_setViewport : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::experimental::Viewport arg0;
        ok &= seval_to_Viewport(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_setViewport : Error processing arguments");
        cobj->setViewport(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_setViewport)

static bool js_cocos2dx_Camera_initDefault(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_initDefault : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->initDefault();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_initDefault : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_initDefault)

static bool js_cocos2dx_Camera_getCameraFlag(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_getCameraFlag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getCameraFlag();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getCameraFlag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getCameraFlag)

static bool js_cocos2dx_Camera_getType(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_getType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getType();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getType)

static bool js_cocos2dx_Camera_initOrthographic(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_initOrthographic : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_initOrthographic : Error processing arguments");
        bool result = cobj->initOrthographic(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_initOrthographic : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_initOrthographic)

static bool js_cocos2dx_Camera_getRenderOrder(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_getRenderOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getRenderOrder();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getRenderOrder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getRenderOrder)

static bool js_cocos2dx_Camera_setDepth(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_setDepth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int8_t arg0;
        ok &= seval_to_int8(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_setDepth : Error processing arguments");
        cobj->setDepth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_setDepth)

static bool js_cocos2dx_Camera_setScene(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_setScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Scene* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_setScene : Error processing arguments");
        cobj->setScene(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_setScene)

static bool js_cocos2dx_Camera_projectGL(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_projectGL : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec3 arg0;
        ok &= seval_to_Vec3(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_projectGL : Error processing arguments");
        cocos2d::Vec2 result = cobj->projectGL(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_projectGL : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_projectGL)

static bool js_cocos2dx_Camera_restoreFrameBufferObject(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_restoreFrameBufferObject : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->restoreFrameBufferObject();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_restoreFrameBufferObject)

static bool js_cocos2dx_Camera_getViewMatrix(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_getViewMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Mat4& result = cobj->getViewMatrix();
        ok &= Mat4_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getViewMatrix : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getViewMatrix)

static bool js_cocos2dx_Camera_getNearPlane(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_getNearPlane : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getNearPlane();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getNearPlane : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getNearPlane)

static bool js_cocos2dx_Camera_project(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_project : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec3 arg0;
        ok &= seval_to_Vec3(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_project : Error processing arguments");
        cocos2d::Vec2 result = cobj->project(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_project : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_project)

static bool js_cocos2dx_Camera_setCameraFlag(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_setCameraFlag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::CameraFlag arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_setCameraFlag : Error processing arguments");
        cobj->setCameraFlag(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_setCameraFlag)

static bool js_cocos2dx_Camera_getFarPlane(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_getFarPlane : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getFarPlane();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getFarPlane : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getFarPlane)

static bool js_cocos2dx_Camera_applyFrameBufferObject(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_applyFrameBufferObject : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->applyFrameBufferObject();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_applyFrameBufferObject)

static bool js_cocos2dx_Camera_setFrameBufferObject(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_setFrameBufferObject : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::experimental::FrameBuffer* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_setFrameBufferObject : Error processing arguments");
        cobj->setFrameBufferObject(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_setFrameBufferObject)

static bool js_cocos2dx_Camera_isViewProjectionUpdated(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_isViewProjectionUpdated : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isViewProjectionUpdated();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_isViewProjectionUpdated : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_isViewProjectionUpdated)

static bool js_cocos2dx_Camera_initPerspective(se::State& s)
{
    cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Camera_initPerspective : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_initPerspective : Error processing arguments");
        bool result = cobj->initPerspective(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_initPerspective : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_initPerspective)

static bool js_cocos2dx_Camera_createOrthographic(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_createOrthographic : Error processing arguments");
        auto result = cocos2d::Camera::createOrthographic(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Camera_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_createOrthographic)

static bool js_cocos2dx_Camera_getVisitingCamera(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Camera* result = cocos2d::Camera::getVisitingCamera();
        ok &= native_ptr_to_seval<cocos2d::Camera>((cocos2d::Camera*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getVisitingCamera : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getVisitingCamera)

static bool js_cocos2dx_Camera_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Camera::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Camera_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_create)

static bool js_cocos2dx_Camera_createPerspective(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_createPerspective : Error processing arguments");
        auto result = cocos2d::Camera::createPerspective(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Camera_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_createPerspective)

static bool js_cocos2dx_Camera_getDefaultViewport(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::experimental::Viewport& result = cocos2d::Camera::getDefaultViewport();
        ok &= Viewport_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getDefaultViewport : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getDefaultViewport)

static bool js_cocos2dx_Camera_setDefaultViewport(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::experimental::Viewport arg0;
        ok &= seval_to_Viewport(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_setDefaultViewport : Error processing arguments");
        cocos2d::Camera::setDefaultViewport(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_setDefaultViewport)

static bool js_cocos2dx_Camera_getDefaultCamera(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Camera* result = cocos2d::Camera::getDefaultCamera();
        ok &= native_ptr_to_seval<cocos2d::Camera>((cocos2d::Camera*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Camera_getDefaultCamera : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Camera_getDefaultCamera)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Camera_finalize)

static bool js_cocos2dx_Camera_constructor(se::State& s)
{
    cocos2d::Camera* cobj = new (std::nothrow) cocos2d::Camera();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Camera_constructor, __jsb_cocos2d_Camera_class, js_cocos2d_Camera_finalize)



extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_Camera_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Camera)", s.nativeThisObject());
        cocos2d::Camera* cobj = (cocos2d::Camera*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Camera_finalize)

bool js_register_cocos2dx_Camera(se::Object* obj)
{
    auto cls = se::Class::create("Camera", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_Camera_constructor));

    cls->defineFunction("restore", _SE(js_cocos2dx_Camera_restore));
    cls->defineFunction("getDepth", _SE(js_cocos2dx_Camera_getDepth));
    cls->defineFunction("getViewProjectionMatrix", _SE(js_cocos2dx_Camera_getViewProjectionMatrix));
    cls->defineFunction("applyViewport", _SE(js_cocos2dx_Camera_applyViewport));
    cls->defineFunction("setBackgroundBrush", _SE(js_cocos2dx_Camera_setBackgroundBrush));
    cls->defineFunction("lookAt", _SE(js_cocos2dx_Camera_lookAt));
    cls->defineFunction("apply", _SE(js_cocos2dx_Camera_apply));
    cls->defineFunction("getBackgroundBrush", _SE(js_cocos2dx_Camera_getBackgroundBrush));
    cls->defineFunction("getProjectionMatrix", _SE(js_cocos2dx_Camera_getProjectionMatrix));
    cls->defineFunction("isBrushValid", _SE(js_cocos2dx_Camera_isBrushValid));
    cls->defineFunction("getDepthInView", _SE(js_cocos2dx_Camera_getDepthInView));
    cls->defineFunction("restoreViewport", _SE(js_cocos2dx_Camera_restoreViewport));
    cls->defineFunction("clearBackground", _SE(js_cocos2dx_Camera_clearBackground));
    cls->defineFunction("setAdditionalProjection", _SE(js_cocos2dx_Camera_setAdditionalProjection));
    cls->defineFunction("setViewport", _SE(js_cocos2dx_Camera_setViewport));
    cls->defineFunction("initDefault", _SE(js_cocos2dx_Camera_initDefault));
    cls->defineFunction("getCameraFlag", _SE(js_cocos2dx_Camera_getCameraFlag));
    cls->defineFunction("getType", _SE(js_cocos2dx_Camera_getType));
    cls->defineFunction("initOrthographic", _SE(js_cocos2dx_Camera_initOrthographic));
    cls->defineFunction("getRenderOrder", _SE(js_cocos2dx_Camera_getRenderOrder));
    cls->defineFunction("setDepth", _SE(js_cocos2dx_Camera_setDepth));
    cls->defineFunction("setScene", _SE(js_cocos2dx_Camera_setScene));
    cls->defineFunction("projectGL", _SE(js_cocos2dx_Camera_projectGL));
    cls->defineFunction("restoreFrameBufferObject", _SE(js_cocos2dx_Camera_restoreFrameBufferObject));
    cls->defineFunction("getViewMatrix", _SE(js_cocos2dx_Camera_getViewMatrix));
    cls->defineFunction("getNearPlane", _SE(js_cocos2dx_Camera_getNearPlane));
    cls->defineFunction("project", _SE(js_cocos2dx_Camera_project));
    cls->defineFunction("setCameraFlag", _SE(js_cocos2dx_Camera_setCameraFlag));
    cls->defineFunction("getFarPlane", _SE(js_cocos2dx_Camera_getFarPlane));
    cls->defineFunction("applyFrameBufferObject", _SE(js_cocos2dx_Camera_applyFrameBufferObject));
    cls->defineFunction("setFrameBufferObject", _SE(js_cocos2dx_Camera_setFrameBufferObject));
    cls->defineFunction("isViewProjectionUpdated", _SE(js_cocos2dx_Camera_isViewProjectionUpdated));
    cls->defineFunction("initPerspective", _SE(js_cocos2dx_Camera_initPerspective));
    cls->defineStaticFunction("createOrthographic", _SE(js_cocos2dx_Camera_createOrthographic));
    cls->defineStaticFunction("getVisitingCamera", _SE(js_cocos2dx_Camera_getVisitingCamera));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Camera_create));
    cls->defineStaticFunction("createPerspective", _SE(js_cocos2dx_Camera_createPerspective));
    cls->defineStaticFunction("getDefaultViewport", _SE(js_cocos2dx_Camera_getDefaultViewport));
    cls->defineStaticFunction("setDefaultViewport", _SE(js_cocos2dx_Camera_setDefaultViewport));
    cls->defineStaticFunction("getDefaultCamera", _SE(js_cocos2dx_Camera_getDefaultCamera));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Camera_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Camera>(cls);

    __jsb_cocos2d_Camera_proto = cls->getProto();
    __jsb_cocos2d_Camera_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_CameraBackgroundBrush_proto = nullptr;
se::Class* __jsb_cocos2d_CameraBackgroundBrush_class = nullptr;

static bool js_cocos2dx_CameraBackgroundBrush_getBrushType(se::State& s)
{
    cocos2d::CameraBackgroundBrush* cobj = (cocos2d::CameraBackgroundBrush*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CameraBackgroundBrush_getBrushType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getBrushType();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundBrush_getBrushType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundBrush_getBrushType)

static bool js_cocos2dx_CameraBackgroundBrush_drawBackground(se::State& s)
{
    cocos2d::CameraBackgroundBrush* cobj = (cocos2d::CameraBackgroundBrush*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CameraBackgroundBrush_drawBackground : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Camera* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundBrush_drawBackground : Error processing arguments");
        cobj->drawBackground(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundBrush_drawBackground)

static bool js_cocos2dx_CameraBackgroundBrush_init(se::State& s)
{
    cocos2d::CameraBackgroundBrush* cobj = (cocos2d::CameraBackgroundBrush*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CameraBackgroundBrush_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundBrush_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundBrush_init)

static bool js_cocos2dx_CameraBackgroundBrush_isValid(se::State& s)
{
    cocos2d::CameraBackgroundBrush* cobj = (cocos2d::CameraBackgroundBrush*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CameraBackgroundBrush_isValid : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isValid();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundBrush_isValid : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundBrush_isValid)

static bool js_cocos2dx_CameraBackgroundBrush_createSkyboxBrush(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 6) {
        std::string arg0;
        std::string arg1;
        std::string arg2;
        std::string arg3;
        std::string arg4;
        std::string arg5;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_std_string(args[2], &arg2);
        ok &= seval_to_std_string(args[3], &arg3);
        ok &= seval_to_std_string(args[4], &arg4);
        ok &= seval_to_std_string(args[5], &arg5);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundBrush_createSkyboxBrush : Error processing arguments");
        auto result = cocos2d::CameraBackgroundBrush::createSkyboxBrush(arg0, arg1, arg2, arg3, arg4, arg5);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_CameraBackgroundBrush_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundBrush_createSkyboxBrush)

static bool js_cocos2dx_CameraBackgroundBrush_createColorBrush(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Color4F arg0;
        float arg1 = 0;
        ok &= seval_to_Color4F(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundBrush_createColorBrush : Error processing arguments");
        auto result = cocos2d::CameraBackgroundBrush::createColorBrush(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_CameraBackgroundBrush_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundBrush_createColorBrush)

static bool js_cocos2dx_CameraBackgroundBrush_createNoneBrush(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::CameraBackgroundBrush::createNoneBrush();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_CameraBackgroundBrush_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundBrush_createNoneBrush)

static bool js_cocos2dx_CameraBackgroundBrush_createDepthBrush(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::CameraBackgroundBrush::createDepthBrush();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_CameraBackgroundBrush_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundBrush_createDepthBrush : Error processing arguments");
        auto result = cocos2d::CameraBackgroundBrush::createDepthBrush(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_CameraBackgroundBrush_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundBrush_createDepthBrush)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CameraBackgroundBrush_finalize)

static bool js_cocos2dx_CameraBackgroundBrush_constructor(se::State& s)
{
    cocos2d::CameraBackgroundBrush* cobj = new (std::nothrow) cocos2d::CameraBackgroundBrush();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CameraBackgroundBrush_constructor, __jsb_cocos2d_CameraBackgroundBrush_class, js_cocos2d_CameraBackgroundBrush_finalize)




bool js_cocos2d_CameraBackgroundBrush_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::CameraBackgroundBrush)", s.nativeThisObject());
        cocos2d::CameraBackgroundBrush* cobj = (cocos2d::CameraBackgroundBrush*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CameraBackgroundBrush_finalize)

bool js_register_cocos2dx_CameraBackgroundBrush(se::Object* obj)
{
    auto cls = se::Class::create("CameraBackgroundBrush", obj, nullptr, _SE(js_cocos2dx_CameraBackgroundBrush_constructor));

    cls->defineFunction("getBrushType", _SE(js_cocos2dx_CameraBackgroundBrush_getBrushType));
    cls->defineFunction("drawBackground", _SE(js_cocos2dx_CameraBackgroundBrush_drawBackground));
    cls->defineFunction("init", _SE(js_cocos2dx_CameraBackgroundBrush_init));
    cls->defineFunction("isValid", _SE(js_cocos2dx_CameraBackgroundBrush_isValid));
    cls->defineStaticFunction("createSkyboxBrush", _SE(js_cocos2dx_CameraBackgroundBrush_createSkyboxBrush));
    cls->defineStaticFunction("createColorBrush", _SE(js_cocos2dx_CameraBackgroundBrush_createColorBrush));
    cls->defineStaticFunction("createNoneBrush", _SE(js_cocos2dx_CameraBackgroundBrush_createNoneBrush));
    cls->defineStaticFunction("createDepthBrush", _SE(js_cocos2dx_CameraBackgroundBrush_createDepthBrush));
    cls->defineFinalizedFunction(_SE(js_cocos2d_CameraBackgroundBrush_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CameraBackgroundBrush>(cls);

    __jsb_cocos2d_CameraBackgroundBrush_proto = cls->getProto();
    __jsb_cocos2d_CameraBackgroundBrush_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_CameraBackgroundDepthBrush_proto = nullptr;
se::Class* __jsb_cocos2d_CameraBackgroundDepthBrush_class = nullptr;

static bool js_cocos2dx_CameraBackgroundDepthBrush_setDepth(se::State& s)
{
    cocos2d::CameraBackgroundDepthBrush* cobj = (cocos2d::CameraBackgroundDepthBrush*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CameraBackgroundDepthBrush_setDepth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundDepthBrush_setDepth : Error processing arguments");
        cobj->setDepth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundDepthBrush_setDepth)

static bool js_cocos2dx_CameraBackgroundDepthBrush_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundDepthBrush_create : Error processing arguments");
        auto result = cocos2d::CameraBackgroundDepthBrush::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_CameraBackgroundDepthBrush_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundDepthBrush_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CameraBackgroundDepthBrush_finalize)

static bool js_cocos2dx_CameraBackgroundDepthBrush_constructor(se::State& s)
{
    cocos2d::CameraBackgroundDepthBrush* cobj = new (std::nothrow) cocos2d::CameraBackgroundDepthBrush();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CameraBackgroundDepthBrush_constructor, __jsb_cocos2d_CameraBackgroundDepthBrush_class, js_cocos2d_CameraBackgroundDepthBrush_finalize)



extern se::Object* __jsb_cocos2d_CameraBackgroundBrush_proto;

bool js_cocos2d_CameraBackgroundDepthBrush_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::CameraBackgroundDepthBrush)", s.nativeThisObject());
        cocos2d::CameraBackgroundDepthBrush* cobj = (cocos2d::CameraBackgroundDepthBrush*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CameraBackgroundDepthBrush_finalize)

bool js_register_cocos2dx_CameraBackgroundDepthBrush(se::Object* obj)
{
    auto cls = se::Class::create("CameraBackgroundDepthBrush", obj, __jsb_cocos2d_CameraBackgroundBrush_proto, _SE(js_cocos2dx_CameraBackgroundDepthBrush_constructor));

    cls->defineFunction("setDepth", _SE(js_cocos2dx_CameraBackgroundDepthBrush_setDepth));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_CameraBackgroundDepthBrush_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_CameraBackgroundDepthBrush_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CameraBackgroundDepthBrush>(cls);

    __jsb_cocos2d_CameraBackgroundDepthBrush_proto = cls->getProto();
    __jsb_cocos2d_CameraBackgroundDepthBrush_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_CameraBackgroundColorBrush_proto = nullptr;
se::Class* __jsb_cocos2d_CameraBackgroundColorBrush_class = nullptr;

static bool js_cocos2dx_CameraBackgroundColorBrush_setColor(se::State& s)
{
    cocos2d::CameraBackgroundColorBrush* cobj = (cocos2d::CameraBackgroundColorBrush*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CameraBackgroundColorBrush_setColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundColorBrush_setColor : Error processing arguments");
        cobj->setColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundColorBrush_setColor)

static bool js_cocos2dx_CameraBackgroundColorBrush_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Color4F arg0;
        float arg1 = 0;
        ok &= seval_to_Color4F(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundColorBrush_create : Error processing arguments");
        auto result = cocos2d::CameraBackgroundColorBrush::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_CameraBackgroundColorBrush_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundColorBrush_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CameraBackgroundColorBrush_finalize)

static bool js_cocos2dx_CameraBackgroundColorBrush_constructor(se::State& s)
{
    cocos2d::CameraBackgroundColorBrush* cobj = new (std::nothrow) cocos2d::CameraBackgroundColorBrush();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CameraBackgroundColorBrush_constructor, __jsb_cocos2d_CameraBackgroundColorBrush_class, js_cocos2d_CameraBackgroundColorBrush_finalize)



extern se::Object* __jsb_cocos2d_CameraBackgroundDepthBrush_proto;

bool js_cocos2d_CameraBackgroundColorBrush_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::CameraBackgroundColorBrush)", s.nativeThisObject());
        cocos2d::CameraBackgroundColorBrush* cobj = (cocos2d::CameraBackgroundColorBrush*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CameraBackgroundColorBrush_finalize)

bool js_register_cocos2dx_CameraBackgroundColorBrush(se::Object* obj)
{
    auto cls = se::Class::create("CameraBackgroundColorBrush", obj, __jsb_cocos2d_CameraBackgroundDepthBrush_proto, _SE(js_cocos2dx_CameraBackgroundColorBrush_constructor));

    cls->defineFunction("setColor", _SE(js_cocos2dx_CameraBackgroundColorBrush_setColor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_CameraBackgroundColorBrush_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_CameraBackgroundColorBrush_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CameraBackgroundColorBrush>(cls);

    __jsb_cocos2d_CameraBackgroundColorBrush_proto = cls->getProto();
    __jsb_cocos2d_CameraBackgroundColorBrush_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_CameraBackgroundSkyBoxBrush_proto = nullptr;
se::Class* __jsb_cocos2d_CameraBackgroundSkyBoxBrush_class = nullptr;

static bool js_cocos2dx_CameraBackgroundSkyBoxBrush_setTextureValid(se::State& s)
{
    cocos2d::CameraBackgroundSkyBoxBrush* cobj = (cocos2d::CameraBackgroundSkyBoxBrush*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CameraBackgroundSkyBoxBrush_setTextureValid : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundSkyBoxBrush_setTextureValid : Error processing arguments");
        cobj->setTextureValid(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundSkyBoxBrush_setTextureValid)

static bool js_cocos2dx_CameraBackgroundSkyBoxBrush_setTexture(se::State& s)
{
    cocos2d::CameraBackgroundSkyBoxBrush* cobj = (cocos2d::CameraBackgroundSkyBoxBrush*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CameraBackgroundSkyBoxBrush_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextureCube* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundSkyBoxBrush_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundSkyBoxBrush_setTexture)

static bool js_cocos2dx_CameraBackgroundSkyBoxBrush_setActived(se::State& s)
{
    cocos2d::CameraBackgroundSkyBoxBrush* cobj = (cocos2d::CameraBackgroundSkyBoxBrush*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CameraBackgroundSkyBoxBrush_setActived : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundSkyBoxBrush_setActived : Error processing arguments");
        cobj->setActived(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundSkyBoxBrush_setActived)

static bool js_cocos2dx_CameraBackgroundSkyBoxBrush_isActived(se::State& s)
{
    cocos2d::CameraBackgroundSkyBoxBrush* cobj = (cocos2d::CameraBackgroundSkyBoxBrush*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_CameraBackgroundSkyBoxBrush_isActived : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isActived();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundSkyBoxBrush_isActived : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundSkyBoxBrush_isActived)

static bool js_cocos2dx_CameraBackgroundSkyBoxBrush_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::CameraBackgroundSkyBoxBrush* result = cocos2d::CameraBackgroundSkyBoxBrush::create();
            ok &= native_ptr_to_seval<cocos2d::CameraBackgroundSkyBoxBrush>((cocos2d::CameraBackgroundSkyBoxBrush*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundSkyBoxBrush_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 6) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            std::string arg3;
            ok &= seval_to_std_string(args[3], &arg3);
            if (!ok) { ok = true; break; }
            std::string arg4;
            ok &= seval_to_std_string(args[4], &arg4);
            if (!ok) { ok = true; break; }
            std::string arg5;
            ok &= seval_to_std_string(args[5], &arg5);
            if (!ok) { ok = true; break; }
            cocos2d::CameraBackgroundSkyBoxBrush* result = cocos2d::CameraBackgroundSkyBoxBrush::create(arg0, arg1, arg2, arg3, arg4, arg5);
            ok &= native_ptr_to_seval<cocos2d::CameraBackgroundSkyBoxBrush>((cocos2d::CameraBackgroundSkyBoxBrush*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_CameraBackgroundSkyBoxBrush_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CameraBackgroundSkyBoxBrush_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CameraBackgroundSkyBoxBrush_finalize)

static bool js_cocos2dx_CameraBackgroundSkyBoxBrush_constructor(se::State& s)
{
    cocos2d::CameraBackgroundSkyBoxBrush* cobj = new (std::nothrow) cocos2d::CameraBackgroundSkyBoxBrush();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CameraBackgroundSkyBoxBrush_constructor, __jsb_cocos2d_CameraBackgroundSkyBoxBrush_class, js_cocos2d_CameraBackgroundSkyBoxBrush_finalize)



extern se::Object* __jsb_cocos2d_CameraBackgroundBrush_proto;

bool js_cocos2d_CameraBackgroundSkyBoxBrush_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::CameraBackgroundSkyBoxBrush)", s.nativeThisObject());
        cocos2d::CameraBackgroundSkyBoxBrush* cobj = (cocos2d::CameraBackgroundSkyBoxBrush*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CameraBackgroundSkyBoxBrush_finalize)

bool js_register_cocos2dx_CameraBackgroundSkyBoxBrush(se::Object* obj)
{
    auto cls = se::Class::create("CameraBackgroundSkyBoxBrush", obj, __jsb_cocos2d_CameraBackgroundBrush_proto, _SE(js_cocos2dx_CameraBackgroundSkyBoxBrush_constructor));

    cls->defineFunction("setTextureValid", _SE(js_cocos2dx_CameraBackgroundSkyBoxBrush_setTextureValid));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_CameraBackgroundSkyBoxBrush_setTexture));
    cls->defineFunction("setActived", _SE(js_cocos2dx_CameraBackgroundSkyBoxBrush_setActived));
    cls->defineFunction("isActived", _SE(js_cocos2dx_CameraBackgroundSkyBoxBrush_isActived));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_CameraBackgroundSkyBoxBrush_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_CameraBackgroundSkyBoxBrush_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CameraBackgroundSkyBoxBrush>(cls);

    __jsb_cocos2d_CameraBackgroundSkyBoxBrush_proto = cls->getProto();
    __jsb_cocos2d_CameraBackgroundSkyBoxBrush_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_GridBase_proto = nullptr;
se::Class* __jsb_cocos2d_GridBase_class = nullptr;

static bool js_cocos2dx_GridBase_setGridSize(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_setGridSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_setGridSize : Error processing arguments");
        cobj->setGridSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_setGridSize)

static bool js_cocos2dx_GridBase_setGridRect(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_setGridRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_setGridRect : Error processing arguments");
        cobj->setGridRect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_setGridRect)

static bool js_cocos2dx_GridBase_afterBlit(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_afterBlit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->afterBlit();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_afterBlit)

static bool js_cocos2dx_GridBase_getGridRect(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_getGridRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Rect& result = cobj->getGridRect();
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_getGridRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_getGridRect)

static bool js_cocos2dx_GridBase_afterDraw(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_afterDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_afterDraw : Error processing arguments");
        cobj->afterDraw(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_afterDraw)

static bool js_cocos2dx_GridBase_beforeDraw(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_beforeDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->beforeDraw();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_beforeDraw)

static bool js_cocos2dx_GridBase_calculateVertexPoints(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_calculateVertexPoints : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->calculateVertexPoints();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_calculateVertexPoints)

static bool js_cocos2dx_GridBase_isTextureFlipped(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_isTextureFlipped : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isTextureFlipped();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_isTextureFlipped : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_isTextureFlipped)

static bool js_cocos2dx_GridBase_getGridSize(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_getGridSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getGridSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_getGridSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_getGridSize)

static bool js_cocos2dx_GridBase_getStep(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_getStep : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getStep();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_getStep : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_getStep)

static bool js_cocos2dx_GridBase_set2DProjection(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_set2DProjection : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->set2DProjection();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_set2DProjection)

static bool js_cocos2dx_GridBase_setStep(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_setStep : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_setStep : Error processing arguments");
        cobj->setStep(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_setStep)

static bool js_cocos2dx_GridBase_setTextureFlipped(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_setTextureFlipped : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_setTextureFlipped : Error processing arguments");
        cobj->setTextureFlipped(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_setTextureFlipped)

static bool js_cocos2dx_GridBase_blit(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_blit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->blit();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_blit)

static bool js_cocos2dx_GridBase_setActive(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_setActive : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_setActive : Error processing arguments");
        cobj->setActive(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_setActive)

static bool js_cocos2dx_GridBase_getReuseGrid(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_getReuseGrid : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getReuseGrid();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_getReuseGrid : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_getReuseGrid)

static bool js_cocos2dx_GridBase_initWithSize(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GridBase_initWithSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithSize(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_initWithSize : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithSize(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_initWithSize : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            bool result = cobj->initWithSize(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_initWithSize : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            cocos2d::Rect arg3;
            ok &= seval_to_Rect(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithSize(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_initWithSize : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_initWithSize)

static bool js_cocos2dx_GridBase_beforeBlit(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_beforeBlit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->beforeBlit();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_beforeBlit)

static bool js_cocos2dx_GridBase_setReuseGrid(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_setReuseGrid : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_setReuseGrid : Error processing arguments");
        cobj->setReuseGrid(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_setReuseGrid)

static bool js_cocos2dx_GridBase_isActive(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_isActive : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isActive();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_isActive : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_isActive)

static bool js_cocos2dx_GridBase_reuse(se::State& s)
{
    cocos2d::GridBase* cobj = (cocos2d::GridBase*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GridBase_reuse : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->reuse();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_reuse)

static bool js_cocos2dx_GridBase_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::GridBase* result = cocos2d::GridBase::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::GridBase>((cocos2d::GridBase*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::GridBase* result = cocos2d::GridBase::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::GridBase>((cocos2d::GridBase*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GridBase_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GridBase_create)




bool js_register_cocos2dx_GridBase(se::Object* obj)
{
    auto cls = se::Class::create("GridBase", obj, nullptr, nullptr);

    cls->defineFunction("setGridSize", _SE(js_cocos2dx_GridBase_setGridSize));
    cls->defineFunction("setGridRect", _SE(js_cocos2dx_GridBase_setGridRect));
    cls->defineFunction("afterBlit", _SE(js_cocos2dx_GridBase_afterBlit));
    cls->defineFunction("getGridRect", _SE(js_cocos2dx_GridBase_getGridRect));
    cls->defineFunction("afterDraw", _SE(js_cocos2dx_GridBase_afterDraw));
    cls->defineFunction("beforeDraw", _SE(js_cocos2dx_GridBase_beforeDraw));
    cls->defineFunction("calculateVertexPoints", _SE(js_cocos2dx_GridBase_calculateVertexPoints));
    cls->defineFunction("isTextureFlipped", _SE(js_cocos2dx_GridBase_isTextureFlipped));
    cls->defineFunction("getGridSize", _SE(js_cocos2dx_GridBase_getGridSize));
    cls->defineFunction("getStep", _SE(js_cocos2dx_GridBase_getStep));
    cls->defineFunction("set2DProjection", _SE(js_cocos2dx_GridBase_set2DProjection));
    cls->defineFunction("setStep", _SE(js_cocos2dx_GridBase_setStep));
    cls->defineFunction("setTextureFlipped", _SE(js_cocos2dx_GridBase_setTextureFlipped));
    cls->defineFunction("blit", _SE(js_cocos2dx_GridBase_blit));
    cls->defineFunction("setActive", _SE(js_cocos2dx_GridBase_setActive));
    cls->defineFunction("getReuseGrid", _SE(js_cocos2dx_GridBase_getReuseGrid));
    cls->defineFunction("initWithSize", _SE(js_cocos2dx_GridBase_initWithSize));
    cls->defineFunction("beforeBlit", _SE(js_cocos2dx_GridBase_beforeBlit));
    cls->defineFunction("setReuseGrid", _SE(js_cocos2dx_GridBase_setReuseGrid));
    cls->defineFunction("isActive", _SE(js_cocos2dx_GridBase_isActive));
    cls->defineFunction("reuse", _SE(js_cocos2dx_GridBase_reuse));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_GridBase_create));
    cls->install();
    JSBClassType::registerClass<cocos2d::GridBase>(cls);

    __jsb_cocos2d_GridBase_proto = cls->getProto();
    __jsb_cocos2d_GridBase_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.GridBase.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_Grid3D_proto = nullptr;
se::Class* __jsb_cocos2d_Grid3D_class = nullptr;

static bool js_cocos2dx_Grid3D_getNeedDepthTestForBlit(se::State& s)
{
    cocos2d::Grid3D* cobj = (cocos2d::Grid3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Grid3D_getNeedDepthTestForBlit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->getNeedDepthTestForBlit();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Grid3D_getNeedDepthTestForBlit : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Grid3D_getNeedDepthTestForBlit)

static bool js_cocos2dx_Grid3D_setNeedDepthTestForBlit(se::State& s)
{
    cocos2d::Grid3D* cobj = (cocos2d::Grid3D*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Grid3D_setNeedDepthTestForBlit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Grid3D_setNeedDepthTestForBlit : Error processing arguments");
        cobj->setNeedDepthTestForBlit(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Grid3D_setNeedDepthTestForBlit)

static bool js_cocos2dx_Grid3D_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Grid3D* result = cocos2d::Grid3D::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::Grid3D>((cocos2d::Grid3D*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Grid3D_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 1) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Grid3D* result = cocos2d::Grid3D::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::Grid3D>((cocos2d::Grid3D*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Grid3D_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Grid3D* result = cocos2d::Grid3D::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::Grid3D>((cocos2d::Grid3D*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Grid3D_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg3;
            ok &= seval_to_Rect(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Grid3D* result = cocos2d::Grid3D::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::Grid3D>((cocos2d::Grid3D*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_Grid3D_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Grid3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Grid3D_finalize)

static bool js_cocos2dx_Grid3D_constructor(se::State& s)
{
    cocos2d::Grid3D* cobj = new (std::nothrow) cocos2d::Grid3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Grid3D_constructor, __jsb_cocos2d_Grid3D_class, js_cocos2d_Grid3D_finalize)

static bool js_cocos2dx_Grid3D_ctor(se::State& s)
{
    cocos2d::Grid3D* cobj = new (std::nothrow) cocos2d::Grid3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Grid3D_ctor, __jsb_cocos2d_Grid3D_class, js_cocos2d_Grid3D_finalize)


    

extern se::Object* __jsb_cocos2d_GridBase_proto;

bool js_cocos2d_Grid3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::Grid3D)", s.nativeThisObject());
        cocos2d::Grid3D* cobj = (cocos2d::Grid3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Grid3D_finalize)

bool js_register_cocos2dx_Grid3D(se::Object* obj)
{
    auto cls = se::Class::create("Grid3D", obj, __jsb_cocos2d_GridBase_proto, _SE(js_cocos2dx_Grid3D_constructor));

    cls->defineFunction("getNeedDepthTestForBlit", _SE(js_cocos2dx_Grid3D_getNeedDepthTestForBlit));
    cls->defineFunction("setNeedDepthTestForBlit", _SE(js_cocos2dx_Grid3D_setNeedDepthTestForBlit));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Grid3D_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Grid3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_Grid3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Grid3D>(cls);

    __jsb_cocos2d_Grid3D_proto = cls->getProto();
    __jsb_cocos2d_Grid3D_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.Grid3D.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TiledGrid3D_proto = nullptr;
se::Class* __jsb_cocos2d_TiledGrid3D_class = nullptr;

static bool js_cocos2dx_TiledGrid3D_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TiledGrid3D* result = cocos2d::TiledGrid3D::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::TiledGrid3D>((cocos2d::TiledGrid3D*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TiledGrid3D_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 1) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::TiledGrid3D* result = cocos2d::TiledGrid3D::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::TiledGrid3D>((cocos2d::TiledGrid3D*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TiledGrid3D_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TiledGrid3D* result = cocos2d::TiledGrid3D::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::TiledGrid3D>((cocos2d::TiledGrid3D*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TiledGrid3D_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            cocos2d::Size arg0;
            ok &= seval_to_Size(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg3;
            ok &= seval_to_Rect(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TiledGrid3D* result = cocos2d::TiledGrid3D::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::TiledGrid3D>((cocos2d::TiledGrid3D*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TiledGrid3D_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TiledGrid3D_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TiledGrid3D_finalize)

static bool js_cocos2dx_TiledGrid3D_constructor(se::State& s)
{
    cocos2d::TiledGrid3D* cobj = new (std::nothrow) cocos2d::TiledGrid3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TiledGrid3D_constructor, __jsb_cocos2d_TiledGrid3D_class, js_cocos2d_TiledGrid3D_finalize)

static bool js_cocos2dx_TiledGrid3D_ctor(se::State& s)
{
    cocos2d::TiledGrid3D* cobj = new (std::nothrow) cocos2d::TiledGrid3D();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TiledGrid3D_ctor, __jsb_cocos2d_TiledGrid3D_class, js_cocos2d_TiledGrid3D_finalize)


    

extern se::Object* __jsb_cocos2d_GridBase_proto;

bool js_cocos2d_TiledGrid3D_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TiledGrid3D)", s.nativeThisObject());
        cocos2d::TiledGrid3D* cobj = (cocos2d::TiledGrid3D*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TiledGrid3D_finalize)

bool js_register_cocos2dx_TiledGrid3D(se::Object* obj)
{
    auto cls = se::Class::create("TiledGrid3D", obj, __jsb_cocos2d_GridBase_proto, _SE(js_cocos2dx_TiledGrid3D_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_TiledGrid3D_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TiledGrid3D_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TiledGrid3D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TiledGrid3D>(cls);

    __jsb_cocos2d_TiledGrid3D_proto = cls->getProto();
    __jsb_cocos2d_TiledGrid3D_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TiledGrid3D.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_BaseLight_proto = nullptr;
se::Class* __jsb_cocos2d_BaseLight_class = nullptr;

static bool js_cocos2dx_BaseLight_setEnabled(se::State& s)
{
    cocos2d::BaseLight* cobj = (cocos2d::BaseLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_BaseLight_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_BaseLight_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_BaseLight_setEnabled)

static bool js_cocos2dx_BaseLight_getIntensity(se::State& s)
{
    cocos2d::BaseLight* cobj = (cocos2d::BaseLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_BaseLight_getIntensity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getIntensity();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_BaseLight_getIntensity : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_BaseLight_getIntensity)

static bool js_cocos2dx_BaseLight_isEnabled(se::State& s)
{
    cocos2d::BaseLight* cobj = (cocos2d::BaseLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_BaseLight_isEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_BaseLight_isEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_BaseLight_isEnabled)

static bool js_cocos2dx_BaseLight_getLightType(se::State& s)
{
    cocos2d::BaseLight* cobj = (cocos2d::BaseLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_BaseLight_getLightType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getLightType();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_BaseLight_getLightType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_BaseLight_getLightType)

static bool js_cocos2dx_BaseLight_setLightFlag(se::State& s)
{
    cocos2d::BaseLight* cobj = (cocos2d::BaseLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_BaseLight_setLightFlag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::LightFlag arg0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_BaseLight_setLightFlag : Error processing arguments");
        cobj->setLightFlag(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_BaseLight_setLightFlag)

static bool js_cocos2dx_BaseLight_setIntensity(se::State& s)
{
    cocos2d::BaseLight* cobj = (cocos2d::BaseLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_BaseLight_setIntensity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_BaseLight_setIntensity : Error processing arguments");
        cobj->setIntensity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_BaseLight_setIntensity)

static bool js_cocos2dx_BaseLight_getLightFlag(se::State& s)
{
    cocos2d::BaseLight* cobj = (cocos2d::BaseLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_BaseLight_getLightFlag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getLightFlag();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_BaseLight_getLightFlag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_BaseLight_getLightFlag)


extern se::Object* __jsb_cocos2d_Node_proto;


bool js_register_cocos2dx_BaseLight(se::Object* obj)
{
    auto cls = se::Class::create("BaseLight", obj, __jsb_cocos2d_Node_proto, nullptr);

    cls->defineFunction("setEnabled", _SE(js_cocos2dx_BaseLight_setEnabled));
    cls->defineFunction("getIntensity", _SE(js_cocos2dx_BaseLight_getIntensity));
    cls->defineFunction("isEnabled", _SE(js_cocos2dx_BaseLight_isEnabled));
    cls->defineFunction("getLightType", _SE(js_cocos2dx_BaseLight_getLightType));
    cls->defineFunction("setLightFlag", _SE(js_cocos2dx_BaseLight_setLightFlag));
    cls->defineFunction("setIntensity", _SE(js_cocos2dx_BaseLight_setIntensity));
    cls->defineFunction("getLightFlag", _SE(js_cocos2dx_BaseLight_getLightFlag));
    cls->install();
    JSBClassType::registerClass<cocos2d::BaseLight>(cls);

    __jsb_cocos2d_BaseLight_proto = cls->getProto();
    __jsb_cocos2d_BaseLight_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_DirectionLight_proto = nullptr;
se::Class* __jsb_cocos2d_DirectionLight_class = nullptr;

static bool js_cocos2dx_DirectionLight_getDirection(se::State& s)
{
    cocos2d::DirectionLight* cobj = (cocos2d::DirectionLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DirectionLight_getDirection : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec3 result = cobj->getDirection();
        ok &= Vec3_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DirectionLight_getDirection : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DirectionLight_getDirection)

static bool js_cocos2dx_DirectionLight_getDirectionInWorld(se::State& s)
{
    cocos2d::DirectionLight* cobj = (cocos2d::DirectionLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DirectionLight_getDirectionInWorld : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec3 result = cobj->getDirectionInWorld();
        ok &= Vec3_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DirectionLight_getDirectionInWorld : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DirectionLight_getDirectionInWorld)

static bool js_cocos2dx_DirectionLight_setDirection(se::State& s)
{
    cocos2d::DirectionLight* cobj = (cocos2d::DirectionLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_DirectionLight_setDirection : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec3 arg0;
        ok &= seval_to_Vec3(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DirectionLight_setDirection : Error processing arguments");
        cobj->setDirection(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DirectionLight_setDirection)

static bool js_cocos2dx_DirectionLight_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Vec3 arg0;
        cocos2d::Color3B arg1;
        ok &= seval_to_Vec3(args[0], &arg0);
        ok &= seval_to_Color3B(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_DirectionLight_create : Error processing arguments");
        auto result = cocos2d::DirectionLight::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_DirectionLight_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DirectionLight_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_DirectionLight_finalize)

static bool js_cocos2dx_DirectionLight_constructor(se::State& s)
{
    cocos2d::DirectionLight* cobj = new (std::nothrow) cocos2d::DirectionLight();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_DirectionLight_constructor, __jsb_cocos2d_DirectionLight_class, js_cocos2d_DirectionLight_finalize)



extern se::Object* __jsb_cocos2d_BaseLight_proto;

bool js_cocos2d_DirectionLight_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::DirectionLight)", s.nativeThisObject());
        cocos2d::DirectionLight* cobj = (cocos2d::DirectionLight*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_DirectionLight_finalize)

bool js_register_cocos2dx_DirectionLight(se::Object* obj)
{
    auto cls = se::Class::create("DirectionLight", obj, __jsb_cocos2d_BaseLight_proto, _SE(js_cocos2dx_DirectionLight_constructor));

    cls->defineFunction("getDirection", _SE(js_cocos2dx_DirectionLight_getDirection));
    cls->defineFunction("getDirectionInWorld", _SE(js_cocos2dx_DirectionLight_getDirectionInWorld));
    cls->defineFunction("setDirection", _SE(js_cocos2dx_DirectionLight_setDirection));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_DirectionLight_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_DirectionLight_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::DirectionLight>(cls);

    __jsb_cocos2d_DirectionLight_proto = cls->getProto();
    __jsb_cocos2d_DirectionLight_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_PointLight_proto = nullptr;
se::Class* __jsb_cocos2d_PointLight_class = nullptr;

static bool js_cocos2dx_PointLight_getRange(se::State& s)
{
    cocos2d::PointLight* cobj = (cocos2d::PointLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_PointLight_getRange : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRange();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_PointLight_getRange : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_PointLight_getRange)

static bool js_cocos2dx_PointLight_setRange(se::State& s)
{
    cocos2d::PointLight* cobj = (cocos2d::PointLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_PointLight_setRange : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_PointLight_setRange : Error processing arguments");
        cobj->setRange(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_PointLight_setRange)

static bool js_cocos2dx_PointLight_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vec3 arg0;
        cocos2d::Color3B arg1;
        float arg2 = 0;
        ok &= seval_to_Vec3(args[0], &arg0);
        ok &= seval_to_Color3B(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_PointLight_create : Error processing arguments");
        auto result = cocos2d::PointLight::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_PointLight_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_PointLight_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_PointLight_finalize)

static bool js_cocos2dx_PointLight_constructor(se::State& s)
{
    cocos2d::PointLight* cobj = new (std::nothrow) cocos2d::PointLight();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_PointLight_constructor, __jsb_cocos2d_PointLight_class, js_cocos2d_PointLight_finalize)



extern se::Object* __jsb_cocos2d_BaseLight_proto;

bool js_cocos2d_PointLight_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::PointLight)", s.nativeThisObject());
        cocos2d::PointLight* cobj = (cocos2d::PointLight*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_PointLight_finalize)

bool js_register_cocos2dx_PointLight(se::Object* obj)
{
    auto cls = se::Class::create("PointLight", obj, __jsb_cocos2d_BaseLight_proto, _SE(js_cocos2dx_PointLight_constructor));

    cls->defineFunction("getRange", _SE(js_cocos2dx_PointLight_getRange));
    cls->defineFunction("setRange", _SE(js_cocos2dx_PointLight_setRange));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_PointLight_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_PointLight_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::PointLight>(cls);

    __jsb_cocos2d_PointLight_proto = cls->getProto();
    __jsb_cocos2d_PointLight_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_SpotLight_proto = nullptr;
se::Class* __jsb_cocos2d_SpotLight_class = nullptr;

static bool js_cocos2dx_SpotLight_getRange(se::State& s)
{
    cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpotLight_getRange : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRange();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_getRange : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_getRange)

static bool js_cocos2dx_SpotLight_setDirection(se::State& s)
{
    cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpotLight_setDirection : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec3 arg0;
        ok &= seval_to_Vec3(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_setDirection : Error processing arguments");
        cobj->setDirection(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_setDirection)

static bool js_cocos2dx_SpotLight_getCosInnerAngle(se::State& s)
{
    cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpotLight_getCosInnerAngle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getCosInnerAngle();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_getCosInnerAngle : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_getCosInnerAngle)

static bool js_cocos2dx_SpotLight_getOuterAngle(se::State& s)
{
    cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpotLight_getOuterAngle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getOuterAngle();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_getOuterAngle : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_getOuterAngle)

static bool js_cocos2dx_SpotLight_getInnerAngle(se::State& s)
{
    cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpotLight_getInnerAngle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getInnerAngle();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_getInnerAngle : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_getInnerAngle)

static bool js_cocos2dx_SpotLight_getDirection(se::State& s)
{
    cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpotLight_getDirection : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec3 result = cobj->getDirection();
        ok &= Vec3_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_getDirection : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_getDirection)

static bool js_cocos2dx_SpotLight_getCosOuterAngle(se::State& s)
{
    cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpotLight_getCosOuterAngle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getCosOuterAngle();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_getCosOuterAngle : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_getCosOuterAngle)

static bool js_cocos2dx_SpotLight_setOuterAngle(se::State& s)
{
    cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpotLight_setOuterAngle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_setOuterAngle : Error processing arguments");
        cobj->setOuterAngle(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_setOuterAngle)

static bool js_cocos2dx_SpotLight_setInnerAngle(se::State& s)
{
    cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpotLight_setInnerAngle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_setInnerAngle : Error processing arguments");
        cobj->setInnerAngle(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_setInnerAngle)

static bool js_cocos2dx_SpotLight_getDirectionInWorld(se::State& s)
{
    cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpotLight_getDirectionInWorld : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec3 result = cobj->getDirectionInWorld();
        ok &= Vec3_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_getDirectionInWorld : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_getDirectionInWorld)

static bool js_cocos2dx_SpotLight_setRange(se::State& s)
{
    cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpotLight_setRange : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_setRange : Error processing arguments");
        cobj->setRange(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_setRange)

static bool js_cocos2dx_SpotLight_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 6) {
        cocos2d::Vec3 arg0;
        cocos2d::Vec3 arg1;
        cocos2d::Color3B arg2;
        float arg3 = 0;
        float arg4 = 0;
        float arg5 = 0;
        ok &= seval_to_Vec3(args[0], &arg0);
        ok &= seval_to_Vec3(args[1], &arg1);
        ok &= seval_to_Color3B(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        ok &= seval_to_float(args[4], &arg4);
        ok &= seval_to_float(args[5], &arg5);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpotLight_create : Error processing arguments");
        auto result = cocos2d::SpotLight::create(arg0, arg1, arg2, arg3, arg4, arg5);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SpotLight_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpotLight_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_SpotLight_finalize)

static bool js_cocos2dx_SpotLight_constructor(se::State& s)
{
    cocos2d::SpotLight* cobj = new (std::nothrow) cocos2d::SpotLight();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_SpotLight_constructor, __jsb_cocos2d_SpotLight_class, js_cocos2d_SpotLight_finalize)



extern se::Object* __jsb_cocos2d_BaseLight_proto;

bool js_cocos2d_SpotLight_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::SpotLight)", s.nativeThisObject());
        cocos2d::SpotLight* cobj = (cocos2d::SpotLight*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_SpotLight_finalize)

bool js_register_cocos2dx_SpotLight(se::Object* obj)
{
    auto cls = se::Class::create("SpotLight", obj, __jsb_cocos2d_BaseLight_proto, _SE(js_cocos2dx_SpotLight_constructor));

    cls->defineFunction("getRange", _SE(js_cocos2dx_SpotLight_getRange));
    cls->defineFunction("setDirection", _SE(js_cocos2dx_SpotLight_setDirection));
    cls->defineFunction("getCosInnerAngle", _SE(js_cocos2dx_SpotLight_getCosInnerAngle));
    cls->defineFunction("getOuterAngle", _SE(js_cocos2dx_SpotLight_getOuterAngle));
    cls->defineFunction("getInnerAngle", _SE(js_cocos2dx_SpotLight_getInnerAngle));
    cls->defineFunction("getDirection", _SE(js_cocos2dx_SpotLight_getDirection));
    cls->defineFunction("getCosOuterAngle", _SE(js_cocos2dx_SpotLight_getCosOuterAngle));
    cls->defineFunction("setOuterAngle", _SE(js_cocos2dx_SpotLight_setOuterAngle));
    cls->defineFunction("setInnerAngle", _SE(js_cocos2dx_SpotLight_setInnerAngle));
    cls->defineFunction("getDirectionInWorld", _SE(js_cocos2dx_SpotLight_getDirectionInWorld));
    cls->defineFunction("setRange", _SE(js_cocos2dx_SpotLight_setRange));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_SpotLight_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_SpotLight_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::SpotLight>(cls);

    __jsb_cocos2d_SpotLight_proto = cls->getProto();
    __jsb_cocos2d_SpotLight_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_AmbientLight_proto = nullptr;
se::Class* __jsb_cocos2d_AmbientLight_class = nullptr;

static bool js_cocos2dx_AmbientLight_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AmbientLight_create : Error processing arguments");
        auto result = cocos2d::AmbientLight::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_AmbientLight_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AmbientLight_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_AmbientLight_finalize)

static bool js_cocos2dx_AmbientLight_constructor(se::State& s)
{
    cocos2d::AmbientLight* cobj = new (std::nothrow) cocos2d::AmbientLight();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_AmbientLight_constructor, __jsb_cocos2d_AmbientLight_class, js_cocos2d_AmbientLight_finalize)



extern se::Object* __jsb_cocos2d_BaseLight_proto;

bool js_cocos2d_AmbientLight_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::AmbientLight)", s.nativeThisObject());
        cocos2d::AmbientLight* cobj = (cocos2d::AmbientLight*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_AmbientLight_finalize)

bool js_register_cocos2dx_AmbientLight(se::Object* obj)
{
    auto cls = se::Class::create("AmbientLight", obj, __jsb_cocos2d_BaseLight_proto, _SE(js_cocos2dx_AmbientLight_constructor));

    cls->defineStaticFunction("create", _SE(js_cocos2dx_AmbientLight_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_AmbientLight_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::AmbientLight>(cls);

    __jsb_cocos2d_AmbientLight_proto = cls->getProto();
    __jsb_cocos2d_AmbientLight_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_GLProgram_proto = nullptr;
se::Class* __jsb_cocos2d_GLProgram_class = nullptr;

static bool js_cocos2dx_GLProgram_getFragmentShaderLog(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getFragmentShaderLog : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getFragmentShaderLog();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getFragmentShaderLog : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getFragmentShaderLog)

static bool js_cocos2dx_GLProgram_bindAttribLocation(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_bindAttribLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        unsigned int arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_uint32(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_bindAttribLocation : Error processing arguments");
        cobj->bindAttribLocation(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_bindAttribLocation)

static bool js_cocos2dx_GLProgram_getUniformLocationForName(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getUniformLocationForName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniformLocationForName : Error processing arguments");
        int result = cobj->getUniformLocationForName(arg0);
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniformLocationForName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getUniformLocationForName)

static bool js_cocos2dx_GLProgram_use(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_use : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->use();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_use)

static bool js_cocos2dx_GLProgram_getVertexShaderLog(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getVertexShaderLog : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getVertexShaderLog();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getVertexShaderLog : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getVertexShaderLog)

static bool js_cocos2dx_GLProgram_getUniform(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getUniform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniform : Error processing arguments");
        cocos2d::Uniform* result = cobj->getUniform(arg0);
        ok &= uniform_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getUniform)

static bool js_cocos2dx_GLProgram_initWithByteArrays(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgram_initWithByteArrays : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            const char* arg1 = nullptr;
            std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithByteArrays(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_initWithByteArrays : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            const char* arg1 = nullptr;
            std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithByteArrays(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_initWithByteArrays : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            const char* arg1 = nullptr;
            std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            std::string arg3;
            ok &= seval_to_std_string(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithByteArrays(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_initWithByteArrays : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_initWithByteArrays)

static bool js_cocos2dx_GLProgram_setUniformLocationWith1f(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_setUniformLocationWith1f : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        int arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_float(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_setUniformLocationWith1f : Error processing arguments");
        cobj->setUniformLocationWith1f(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformLocationWith1f)

static bool js_cocos2dx_GLProgram_initWithFilenames(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgram_initWithFilenames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFilenames(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_initWithFilenames : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFilenames(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_initWithFilenames : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            std::string arg3;
            ok &= seval_to_std_string(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFilenames(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_initWithFilenames : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_initWithFilenames)

static bool js_cocos2dx_GLProgram_setUniformLocationWith3f(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_setUniformLocationWith3f : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        int arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_setUniformLocationWith3f : Error processing arguments");
        cobj->setUniformLocationWith3f(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformLocationWith3f)

static bool js_cocos2dx_GLProgram_setUniformsForBuiltins(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgram_setUniformsForBuiltins : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cobj->setUniformsForBuiltins();
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Mat4 arg0;
            ok &= seval_to_Mat4(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setUniformsForBuiltins(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformsForBuiltins)

static bool js_cocos2dx_GLProgram_setUniformLocationWith3i(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_setUniformLocationWith3i : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        int arg0 = 0;
        int arg1 = 0;
        int arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_setUniformLocationWith3i : Error processing arguments");
        cobj->setUniformLocationWith3i(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformLocationWith3i)

static bool js_cocos2dx_GLProgram_setUniformLocationWith4f(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_setUniformLocationWith4f : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 5) {
        int arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        float arg4 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        ok &= seval_to_float(args[4], &arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_setUniformLocationWith4f : Error processing arguments");
        cobj->setUniformLocationWith4f(arg0, arg1, arg2, arg3, arg4);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformLocationWith4f)

static bool js_cocos2dx_GLProgram_updateUniforms(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_updateUniforms : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateUniforms();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_updateUniforms)

static bool js_cocos2dx_GLProgram_getUniformLocation(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getUniformLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniformLocation : Error processing arguments");
        int result = cobj->getUniformLocation(arg0);
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniformLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getUniformLocation)

static bool js_cocos2dx_GLProgram_link(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_link : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->link();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_link : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_link)

static bool js_cocos2dx_GLProgram_reset(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_reset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->reset();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_reset)

static bool js_cocos2dx_GLProgram_getAttribLocation(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getAttribLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getAttribLocation : Error processing arguments");
        int result = cobj->getAttribLocation(arg0);
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getAttribLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getAttribLocation)

static bool js_cocos2dx_GLProgram_setUniformLocationWith2f(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_setUniformLocationWith2f : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        int arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_setUniformLocationWith2f : Error processing arguments");
        cobj->setUniformLocationWith2f(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformLocationWith2f)

static bool js_cocos2dx_GLProgram_setUniformLocationWith4i(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_setUniformLocationWith4i : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 5) {
        int arg0 = 0;
        int arg1 = 0;
        int arg2 = 0;
        int arg3 = 0;
        int arg4 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        ok &= seval_to_int32(args[4], (int32_t *)&arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_setUniformLocationWith4i : Error processing arguments");
        cobj->setUniformLocationWith4i(arg0, arg1, arg2, arg3, arg4);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformLocationWith4i)

static bool js_cocos2dx_GLProgram_setUniformLocationWith1i(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_setUniformLocationWith1i : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        int arg0 = 0;
        int arg1 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_setUniformLocationWith1i : Error processing arguments");
        cobj->setUniformLocationWith1i(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformLocationWith1i)

static bool js_cocos2dx_GLProgram_setUniformLocationWith2i(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_setUniformLocationWith2i : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        int arg0 = 0;
        int arg1 = 0;
        int arg2 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_setUniformLocationWith2i : Error processing arguments");
        cobj->setUniformLocationWith2i(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformLocationWith2i)

static bool js_cocos2dx_GLProgram_createWithByteArrays(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            const char* arg1 = nullptr;
            std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::GLProgram* result = cocos2d::GLProgram::createWithByteArrays(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_createWithByteArrays : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            const char* arg1 = nullptr;
            std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
            if (!ok) { ok = true; break; }
            cocos2d::GLProgram* result = cocos2d::GLProgram::createWithByteArrays(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_createWithByteArrays : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            const char* arg1 = nullptr;
            std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            std::string arg3;
            ok &= seval_to_std_string(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::GLProgram* result = cocos2d::GLProgram::createWithByteArrays(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_createWithByteArrays : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_createWithByteArrays)

static bool js_cocos2dx_GLProgram_createWithFilenames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::GLProgram* result = cocos2d::GLProgram::createWithFilenames(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_createWithFilenames : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::GLProgram* result = cocos2d::GLProgram::createWithFilenames(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_createWithFilenames : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            std::string arg3;
            ok &= seval_to_std_string(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::GLProgram* result = cocos2d::GLProgram::createWithFilenames(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_createWithFilenames : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_createWithFilenames)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_GLProgram_finalize)

static bool js_cocos2dx_GLProgram_constructor(se::State& s)
{
    cocos2d::GLProgram* cobj = new (std::nothrow) cocos2d::GLProgram();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_GLProgram_constructor, __jsb_cocos2d_GLProgram_class, js_cocos2d_GLProgram_finalize)

static bool js_cocos2dx_GLProgram_ctor(se::State& s)
{
    cocos2d::GLProgram* cobj = new (std::nothrow) cocos2d::GLProgram();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_GLProgram_ctor, __jsb_cocos2d_GLProgram_class, js_cocos2d_GLProgram_finalize)


    


bool js_cocos2d_GLProgram_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::GLProgram)", s.nativeThisObject());
        cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_GLProgram_finalize)

bool js_register_cocos2dx_GLProgram(se::Object* obj)
{
    auto cls = se::Class::create("GLProgram", obj, nullptr, _SE(js_cocos2dx_GLProgram_constructor));

    cls->defineFunction("getFragmentShaderLog", _SE(js_cocos2dx_GLProgram_getFragmentShaderLog));
    cls->defineFunction("addAttribute", _SE(js_cocos2dx_GLProgram_bindAttribLocation));
    cls->defineFunction("getUniformLocationForName", _SE(js_cocos2dx_GLProgram_getUniformLocationForName));
    cls->defineFunction("use", _SE(js_cocos2dx_GLProgram_use));
    cls->defineFunction("getVertexShaderLog", _SE(js_cocos2dx_GLProgram_getVertexShaderLog));
    cls->defineFunction("getUniform", _SE(js_cocos2dx_GLProgram_getUniform));
    cls->defineFunction("initWithString", _SE(js_cocos2dx_GLProgram_initWithByteArrays));
    cls->defineFunction("setUniformLocationWith1f", _SE(js_cocos2dx_GLProgram_setUniformLocationWith1f));
    cls->defineFunction("init", _SE(js_cocos2dx_GLProgram_initWithFilenames));
    cls->defineFunction("setUniformLocationWith3f", _SE(js_cocos2dx_GLProgram_setUniformLocationWith3f));
    cls->defineFunction("setUniformsForBuiltins", _SE(js_cocos2dx_GLProgram_setUniformsForBuiltins));
    cls->defineFunction("setUniformLocationWith3i", _SE(js_cocos2dx_GLProgram_setUniformLocationWith3i));
    cls->defineFunction("setUniformLocationWith4f", _SE(js_cocos2dx_GLProgram_setUniformLocationWith4f));
    cls->defineFunction("updateUniforms", _SE(js_cocos2dx_GLProgram_updateUniforms));
    cls->defineFunction("getUniformLocation", _SE(js_cocos2dx_GLProgram_getUniformLocation));
    cls->defineFunction("link", _SE(js_cocos2dx_GLProgram_link));
    cls->defineFunction("reset", _SE(js_cocos2dx_GLProgram_reset));
    cls->defineFunction("getAttribLocation", _SE(js_cocos2dx_GLProgram_getAttribLocation));
    cls->defineFunction("setUniformLocationWith2f", _SE(js_cocos2dx_GLProgram_setUniformLocationWith2f));
    cls->defineFunction("setUniformLocationWith4i", _SE(js_cocos2dx_GLProgram_setUniformLocationWith4i));
    cls->defineFunction("setUniformLocationI32", _SE(js_cocos2dx_GLProgram_setUniformLocationWith1i));
    cls->defineFunction("setUniformLocationWith2i", _SE(js_cocos2dx_GLProgram_setUniformLocationWith2i));
    cls->defineFunction("ctor", _SE(js_cocos2dx_GLProgram_ctor));
    cls->defineStaticFunction("createWithByteArrays", _SE(js_cocos2dx_GLProgram_createWithByteArrays));
    cls->defineStaticFunction("createWithFilenames", _SE(js_cocos2dx_GLProgram_createWithFilenames));
    cls->defineFinalizedFunction(_SE(js_cocos2d_GLProgram_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::GLProgram>(cls);

    __jsb_cocos2d_GLProgram_proto = cls->getProto();
    __jsb_cocos2d_GLProgram_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.GLProgram.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_GLProgramCache_proto = nullptr;
se::Class* __jsb_cocos2d_GLProgramCache_class = nullptr;

static bool js_cocos2dx_GLProgramCache_loadDefaultGLPrograms(se::State& s)
{
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramCache_loadDefaultGLPrograms : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->loadDefaultGLPrograms();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_loadDefaultGLPrograms)

static bool js_cocos2dx_GLProgramCache_reloadDefaultGLProgramsRelativeToLights(se::State& s)
{
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramCache_reloadDefaultGLProgramsRelativeToLights : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->reloadDefaultGLProgramsRelativeToLights();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_reloadDefaultGLProgramsRelativeToLights)

static bool js_cocos2dx_GLProgramCache_addGLProgram(se::State& s)
{
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramCache_addGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::GLProgram* arg0 = nullptr;
        std::string arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramCache_addGLProgram : Error processing arguments");
        cobj->addGLProgram(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_addGLProgram)

static bool js_cocos2dx_GLProgramCache_reloadDefaultGLPrograms(se::State& s)
{
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramCache_reloadDefaultGLPrograms : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->reloadDefaultGLPrograms();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_reloadDefaultGLPrograms)

static bool js_cocos2dx_GLProgramCache_getGLProgram(se::State& s)
{
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramCache_getGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramCache_getGLProgram : Error processing arguments");
        cocos2d::GLProgram* result = cobj->getGLProgram(arg0);
        ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramCache_getGLProgram : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_getGLProgram)

static bool js_cocos2dx_GLProgramCache_destroyInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::GLProgramCache::destroyInstance();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_destroyInstance)

static bool js_cocos2dx_GLProgramCache_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::GLProgramCache::getInstance();
        se::Object* obj = nullptr;
        if (result->_scriptObject == nullptr)
        {
            obj = se::Object::createObjectWithClass(__jsb_cocos2d_GLProgramCache_class, true);
            obj->setPrivateData(result);
            result->_scriptObject = obj;
        }
        else
        {
            obj = se::Object::getObjectWithPtr(result);
        }
        assert(obj);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_getInstance)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_GLProgramCache_finalize)

static bool js_cocos2dx_GLProgramCache_constructor(se::State& s)
{
    cocos2d::GLProgramCache* cobj = new (std::nothrow) cocos2d::GLProgramCache();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_GLProgramCache_constructor, __jsb_cocos2d_GLProgramCache_class, js_cocos2d_GLProgramCache_finalize)




bool js_cocos2d_GLProgramCache_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::GLProgramCache)", s.nativeThisObject());
        cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_GLProgramCache_finalize)

bool js_register_cocos2dx_GLProgramCache(se::Object* obj)
{
    auto cls = se::Class::create("ShaderCache", obj, nullptr, _SE(js_cocos2dx_GLProgramCache_constructor));

    cls->defineFunction("loadDefaultShaders", _SE(js_cocos2dx_GLProgramCache_loadDefaultGLPrograms));
    cls->defineFunction("reloadDefaultGLProgramsRelativeToLights", _SE(js_cocos2dx_GLProgramCache_reloadDefaultGLProgramsRelativeToLights));
    cls->defineFunction("addProgram", _SE(js_cocos2dx_GLProgramCache_addGLProgram));
    cls->defineFunction("reloadDefaultShaders", _SE(js_cocos2dx_GLProgramCache_reloadDefaultGLPrograms));
    cls->defineFunction("getProgram", _SE(js_cocos2dx_GLProgramCache_getGLProgram));
    cls->defineStaticFunction("destroyInstance", _SE(js_cocos2dx_GLProgramCache_destroyInstance));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_GLProgramCache_getInstance));
    cls->defineFinalizedFunction(_SE(js_cocos2d_GLProgramCache_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::GLProgramCache>(cls);

    __jsb_cocos2d_GLProgramCache_proto = cls->getProto();
    __jsb_cocos2d_GLProgramCache_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_RenderState_proto = nullptr;
se::Class* __jsb_cocos2d_RenderState_class = nullptr;

static bool js_cocos2dx_RenderState_setTexture(se::State& s)
{
    cocos2d::RenderState* cobj = (cocos2d::RenderState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderState_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderState_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderState_setTexture)

static bool js_cocos2dx_RenderState_getTopmost(se::State& s)
{
    cocos2d::RenderState* cobj = (cocos2d::RenderState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderState_getTopmost : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::RenderState* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderState_getTopmost : Error processing arguments");
        cocos2d::RenderState* result = cobj->getTopmost(arg0);
        ok &= native_ptr_to_seval<cocos2d::RenderState>((cocos2d::RenderState*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderState_getTopmost : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderState_getTopmost)

static bool js_cocos2dx_RenderState_getTexture(se::State& s)
{
    cocos2d::RenderState* cobj = (cocos2d::RenderState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderState_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderState_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderState_getTexture)

static bool js_cocos2dx_RenderState_bind(se::State& s)
{
    cocos2d::RenderState* cobj = (cocos2d::RenderState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderState_bind : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Pass* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderState_bind : Error processing arguments");
        cobj->bind(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderState_bind)

static bool js_cocos2dx_RenderState_getName(se::State& s)
{
    cocos2d::RenderState* cobj = (cocos2d::RenderState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderState_getName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderState_getName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderState_getName)

static bool js_cocos2dx_RenderState_setParent(se::State& s)
{
    cocos2d::RenderState* cobj = (cocos2d::RenderState*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_RenderState_setParent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::RenderState* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_RenderState_setParent : Error processing arguments");
        cobj->setParent(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderState_setParent)

static bool js_cocos2dx_RenderState_initialize(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::RenderState::initialize();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderState_initialize)

static bool js_cocos2dx_RenderState_finalize(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::RenderState::finalize();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderState_finalize)




bool js_register_cocos2dx_RenderState(se::Object* obj)
{
    auto cls = se::Class::create("RenderState", obj, nullptr, nullptr);

    cls->defineFunction("setTexture", _SE(js_cocos2dx_RenderState_setTexture));
    cls->defineFunction("getTopmost", _SE(js_cocos2dx_RenderState_getTopmost));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_RenderState_getTexture));
    cls->defineFunction("bind", _SE(js_cocos2dx_RenderState_bind));
    cls->defineFunction("getName", _SE(js_cocos2dx_RenderState_getName));
    cls->defineFunction("setParent", _SE(js_cocos2dx_RenderState_setParent));
    cls->defineStaticFunction("initialize", _SE(js_cocos2dx_RenderState_initialize));
    cls->defineStaticFunction("finalize", _SE(js_cocos2dx_RenderState_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::RenderState>(cls);

    __jsb_cocos2d_RenderState_proto = cls->getProto();
    __jsb_cocos2d_RenderState_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Pass_proto = nullptr;
se::Class* __jsb_cocos2d_Pass_class = nullptr;

static bool js_cocos2dx_Pass_unbind(se::State& s)
{
    cocos2d::Pass* cobj = (cocos2d::Pass*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Pass_unbind : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->unbind();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Pass_unbind)

static bool js_cocos2dx_Pass_bind(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Pass* cobj = (cocos2d::Pass*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_Pass_bind : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Mat4 arg0;
            ok &= seval_to_Mat4(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool arg1;
            ok &= seval_to_boolean(args[1], &arg1);
            cobj->bind(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Mat4 arg0;
            ok &= seval_to_Mat4(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->bind(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Pass_bind)

static bool js_cocos2dx_Pass_clone(se::State& s)
{
    cocos2d::Pass* cobj = (cocos2d::Pass*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Pass_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Pass* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::Pass>((cocos2d::Pass*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Pass_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Pass_clone)

static bool js_cocos2dx_Pass_getGLProgramState(se::State& s)
{
    cocos2d::Pass* cobj = (cocos2d::Pass*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Pass_getGLProgramState : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLProgramState* result = cobj->getGLProgramState();
        ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Pass_getGLProgramState : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Pass_getGLProgramState)

static bool js_cocos2dx_Pass_getHash(se::State& s)
{
    cocos2d::Pass* cobj = (cocos2d::Pass*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Pass_getHash : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getHash();
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Pass_getHash : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Pass_getHash)

static bool js_cocos2dx_Pass_setVertexAttribBinding(se::State& s)
{
    cocos2d::Pass* cobj = (cocos2d::Pass*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Pass_setVertexAttribBinding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::VertexAttribBinding* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Pass_setVertexAttribBinding : Error processing arguments");
        cobj->setVertexAttribBinding(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Pass_setVertexAttribBinding)

static bool js_cocos2dx_Pass_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Technique* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Pass_create : Error processing arguments");
        auto result = cocos2d::Pass::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Pass_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Pass_create)

static bool js_cocos2dx_Pass_createWithGLProgramState(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Technique* arg0 = nullptr;
        cocos2d::GLProgramState* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Pass_createWithGLProgramState : Error processing arguments");
        auto result = cocos2d::Pass::createWithGLProgramState(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Pass_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Pass_createWithGLProgramState)


extern se::Object* __jsb_cocos2d_RenderState_proto;


bool js_register_cocos2dx_Pass(se::Object* obj)
{
    auto cls = se::Class::create("Pass", obj, __jsb_cocos2d_RenderState_proto, nullptr);

    cls->defineFunction("unbind", _SE(js_cocos2dx_Pass_unbind));
    cls->defineFunction("bind", _SE(js_cocos2dx_Pass_bind));
    cls->defineFunction("clone", _SE(js_cocos2dx_Pass_clone));
    cls->defineFunction("getGLProgramState", _SE(js_cocos2dx_Pass_getGLProgramState));
    cls->defineFunction("getHash", _SE(js_cocos2dx_Pass_getHash));
    cls->defineFunction("setVertexAttribBinding", _SE(js_cocos2dx_Pass_setVertexAttribBinding));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Pass_create));
    cls->defineStaticFunction("createWithGLProgramState", _SE(js_cocos2dx_Pass_createWithGLProgramState));
    cls->install();
    JSBClassType::registerClass<cocos2d::Pass>(cls);

    __jsb_cocos2d_Pass_proto = cls->getProto();
    __jsb_cocos2d_Pass_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Technique_proto = nullptr;
se::Class* __jsb_cocos2d_Technique_class = nullptr;

static bool js_cocos2dx_Technique_getPassCount(se::State& s)
{
    cocos2d::Technique* cobj = (cocos2d::Technique*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Technique_getPassCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getPassCount();
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Technique_getPassCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Technique_getPassCount)

static bool js_cocos2dx_Technique_clone(se::State& s)
{
    cocos2d::Technique* cobj = (cocos2d::Technique*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Technique_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Technique* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::Technique>((cocos2d::Technique*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Technique_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Technique_clone)

static bool js_cocos2dx_Technique_addPass(se::State& s)
{
    cocos2d::Technique* cobj = (cocos2d::Technique*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Technique_addPass : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Pass* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Technique_addPass : Error processing arguments");
        cobj->addPass(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Technique_addPass)

static bool js_cocos2dx_Technique_getPasses(se::State& s)
{
    cocos2d::Technique* cobj = (cocos2d::Technique*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Technique_getPasses : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vector<cocos2d::Pass *>& result = cobj->getPasses();
        ok &= Vector_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Technique_getPasses : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Technique_getPasses)

static bool js_cocos2dx_Technique_getName(se::State& s)
{
    cocos2d::Technique* cobj = (cocos2d::Technique*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Technique_getName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Technique_getName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Technique_getName)

static bool js_cocos2dx_Technique_getPassByIndex(se::State& s)
{
    cocos2d::Technique* cobj = (cocos2d::Technique*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Technique_getPassByIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        ssize_t arg0 = 0;
        ok &= seval_to_ssize(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Technique_getPassByIndex : Error processing arguments");
        cocos2d::Pass* result = cobj->getPassByIndex(arg0);
        ok &= native_ptr_to_seval<cocos2d::Pass>((cocos2d::Pass*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Technique_getPassByIndex : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Technique_getPassByIndex)

static bool js_cocos2dx_Technique_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Material* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Technique_create : Error processing arguments");
        auto result = cocos2d::Technique::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Technique_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Technique_create)

static bool js_cocos2dx_Technique_createWithGLProgramState(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Material* arg0 = nullptr;
        cocos2d::GLProgramState* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Technique_createWithGLProgramState : Error processing arguments");
        auto result = cocos2d::Technique::createWithGLProgramState(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Technique_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Technique_createWithGLProgramState)


extern se::Object* __jsb_cocos2d_RenderState_proto;


bool js_register_cocos2dx_Technique(se::Object* obj)
{
    auto cls = se::Class::create("Technique", obj, __jsb_cocos2d_RenderState_proto, nullptr);

    cls->defineFunction("getPassCount", _SE(js_cocos2dx_Technique_getPassCount));
    cls->defineFunction("clone", _SE(js_cocos2dx_Technique_clone));
    cls->defineFunction("addPass", _SE(js_cocos2dx_Technique_addPass));
    cls->defineFunction("getPasses", _SE(js_cocos2dx_Technique_getPasses));
    cls->defineFunction("getName", _SE(js_cocos2dx_Technique_getName));
    cls->defineFunction("getPassByIndex", _SE(js_cocos2dx_Technique_getPassByIndex));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Technique_create));
    cls->defineStaticFunction("createWithGLProgramState", _SE(js_cocos2dx_Technique_createWithGLProgramState));
    cls->install();
    JSBClassType::registerClass<cocos2d::Technique>(cls);

    __jsb_cocos2d_Technique_proto = cls->getProto();
    __jsb_cocos2d_Technique_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Material_proto = nullptr;
se::Class* __jsb_cocos2d_Material_class = nullptr;

static bool js_cocos2dx_Material_clone(se::State& s)
{
    cocos2d::Material* cobj = (cocos2d::Material*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Material_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Material* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::Material>((cocos2d::Material*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_clone)

static bool js_cocos2dx_Material_getTechniqueCount(se::State& s)
{
    cocos2d::Material* cobj = (cocos2d::Material*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Material_getTechniqueCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getTechniqueCount();
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_getTechniqueCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_getTechniqueCount)

static bool js_cocos2dx_Material_setName(se::State& s)
{
    cocos2d::Material* cobj = (cocos2d::Material*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Material_setName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_setName : Error processing arguments");
        cobj->setName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_setName)

static bool js_cocos2dx_Material_getTechniqueByIndex(se::State& s)
{
    cocos2d::Material* cobj = (cocos2d::Material*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Material_getTechniqueByIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        ssize_t arg0 = 0;
        ok &= seval_to_ssize(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_getTechniqueByIndex : Error processing arguments");
        cocos2d::Technique* result = cobj->getTechniqueByIndex(arg0);
        ok &= native_ptr_to_seval<cocos2d::Technique>((cocos2d::Technique*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_getTechniqueByIndex : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_getTechniqueByIndex)

static bool js_cocos2dx_Material_getName(se::State& s)
{
    cocos2d::Material* cobj = (cocos2d::Material*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Material_getName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_getName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_getName)

static bool js_cocos2dx_Material_getTechniques(se::State& s)
{
    cocos2d::Material* cobj = (cocos2d::Material*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Material_getTechniques : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vector<cocos2d::Technique *>& result = cobj->getTechniques();
        ok &= Vector_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_getTechniques : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_getTechniques)

static bool js_cocos2dx_Material_setTechnique(se::State& s)
{
    cocos2d::Material* cobj = (cocos2d::Material*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Material_setTechnique : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_setTechnique : Error processing arguments");
        cobj->setTechnique(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_setTechnique)

static bool js_cocos2dx_Material_getTechniqueByName(se::State& s)
{
    cocos2d::Material* cobj = (cocos2d::Material*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Material_getTechniqueByName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_getTechniqueByName : Error processing arguments");
        cocos2d::Technique* result = cobj->getTechniqueByName(arg0);
        ok &= native_ptr_to_seval<cocos2d::Technique>((cocos2d::Technique*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_getTechniqueByName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_getTechniqueByName)

static bool js_cocos2dx_Material_addTechnique(se::State& s)
{
    cocos2d::Material* cobj = (cocos2d::Material*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Material_addTechnique : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Technique* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_addTechnique : Error processing arguments");
        cobj->addTechnique(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_addTechnique)

static bool js_cocos2dx_Material_getTechnique(se::State& s)
{
    cocos2d::Material* cobj = (cocos2d::Material*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Material_getTechnique : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Technique* result = cobj->getTechnique();
        ok &= native_ptr_to_seval<cocos2d::Technique>((cocos2d::Technique*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_getTechnique : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_getTechnique)

static bool js_cocos2dx_Material_createWithFilename(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_createWithFilename : Error processing arguments");
        auto result = cocos2d::Material::createWithFilename(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Material_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_createWithFilename)

static bool js_cocos2dx_Material_createWithGLStateProgram(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgramState* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_createWithGLStateProgram : Error processing arguments");
        auto result = cocos2d::Material::createWithGLStateProgram(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Material_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_createWithGLStateProgram)

static bool js_cocos2dx_Material_createWithProperties(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Properties* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Material_createWithProperties : Error processing arguments");
        auto result = cocos2d::Material::createWithProperties(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Material_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Material_createWithProperties)


extern se::Object* __jsb_cocos2d_RenderState_proto;


bool js_register_cocos2dx_Material(se::Object* obj)
{
    auto cls = se::Class::create("Material", obj, __jsb_cocos2d_RenderState_proto, nullptr);

    cls->defineFunction("clone", _SE(js_cocos2dx_Material_clone));
    cls->defineFunction("getTechniqueCount", _SE(js_cocos2dx_Material_getTechniqueCount));
    cls->defineFunction("setName", _SE(js_cocos2dx_Material_setName));
    cls->defineFunction("getTechniqueByIndex", _SE(js_cocos2dx_Material_getTechniqueByIndex));
    cls->defineFunction("getName", _SE(js_cocos2dx_Material_getName));
    cls->defineFunction("getTechniques", _SE(js_cocos2dx_Material_getTechniques));
    cls->defineFunction("setTechnique", _SE(js_cocos2dx_Material_setTechnique));
    cls->defineFunction("getTechniqueByName", _SE(js_cocos2dx_Material_getTechniqueByName));
    cls->defineFunction("addTechnique", _SE(js_cocos2dx_Material_addTechnique));
    cls->defineFunction("getTechnique", _SE(js_cocos2dx_Material_getTechnique));
    cls->defineStaticFunction("createWithFilename", _SE(js_cocos2dx_Material_createWithFilename));
    cls->defineStaticFunction("createWithGLStateProgram", _SE(js_cocos2dx_Material_createWithGLStateProgram));
    cls->defineStaticFunction("createWithProperties", _SE(js_cocos2dx_Material_createWithProperties));
    cls->install();
    JSBClassType::registerClass<cocos2d::Material>(cls);

    __jsb_cocos2d_Material_proto = cls->getProto();
    __jsb_cocos2d_Material_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_TextureCache_proto = nullptr;
se::Class* __jsb_cocos2d_TextureCache_class = nullptr;

static bool js_cocos2dx_TextureCache_reloadTexture(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_reloadTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_reloadTexture : Error processing arguments");
        bool result = cobj->reloadTexture(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_reloadTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_reloadTexture)

static bool js_cocos2dx_TextureCache_unbindAllImageAsync(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_unbindAllImageAsync : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->unbindAllImageAsync();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_unbindAllImageAsync)

static bool js_cocos2dx_TextureCache_removeTextureForKey(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_removeTextureForKey : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_removeTextureForKey : Error processing arguments");
        cobj->removeTextureForKey(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_removeTextureForKey)

static bool js_cocos2dx_TextureCache_removeAllTextures(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_removeAllTextures : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllTextures();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_removeAllTextures)

static bool js_cocos2dx_TextureCache_addImageAsync(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TextureCache_addImageAsync : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::function<void (cocos2d::Texture2D *)> arg1;
            do {
			    if (args[1].isObject() && args[1].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[1]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](cocos2d::Texture2D* larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg1 = lambda;
			    }
			    else
			    {
			        arg1 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->addImageAsync(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::function<void (cocos2d::Texture2D *)> arg1;
            do {
			    if (args[1].isObject() && args[1].toObject()->isFunction())
			    {
			        se::Value jsThis(s.thisObject());
			        se::Value jsFunc(args[1]);
			        jsThis.toObject()->attachChild(jsFunc.toObject());
			        auto lambda = [=](cocos2d::Texture2D* larg0) -> void {
			            se::ScriptEngine::getInstance()->clearException();
			            se::AutoHandleScope hs;
			
			            CC_UNUSED bool ok = true;
			            se::ValueArray args;
			            args.resize(1);
			            ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)larg0, &args[0]);
			            se::Value rval;
			            se::Object* thisObj = jsThis.toObject();
			            se::Object* funcObj = jsFunc.toObject();
			            bool succeed = funcObj->call(args, thisObj, &rval);
			            if (!succeed) {
			                se::ScriptEngine::getInstance()->clearException();
			            }
			        };
			        arg1 = lambda;
			    }
			    else
			    {
			        arg1 = nullptr;
			    }
			} while(false)
			;
            if (!ok) { ok = true; break; }
            cobj->addImageAsync(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_addImageAsync)

static bool js_cocos2dx_TextureCache_getDescription(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_getDescription : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getDescription();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getDescription : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_getDescription)

static bool js_cocos2dx_TextureCache_getCachedTextureInfo(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_getCachedTextureInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getCachedTextureInfo();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getCachedTextureInfo : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_getCachedTextureInfo)

static bool js_cocos2dx_TextureCache_addImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TextureCache_addImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Image* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* result = cobj->addImage(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_addImage : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* result = cobj->addImage(arg0);
            ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_addImage : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_addImage)

static bool js_cocos2dx_TextureCache_unbindImageAsync(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_unbindImageAsync : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_unbindImageAsync : Error processing arguments");
        cobj->unbindImageAsync(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_unbindImageAsync)

static bool js_cocos2dx_TextureCache_getTextureForKey(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_getTextureForKey : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getTextureForKey : Error processing arguments");
        cocos2d::Texture2D* result = cobj->getTextureForKey(arg0);
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getTextureForKey : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_getTextureForKey)

static bool js_cocos2dx_TextureCache_getTextureFilePath(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_getTextureFilePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getTextureFilePath : Error processing arguments");
        std::string result = cobj->getTextureFilePath(arg0);
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getTextureFilePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_getTextureFilePath)

static bool js_cocos2dx_TextureCache_renameTextureWithKey(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_renameTextureWithKey : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_renameTextureWithKey : Error processing arguments");
        cobj->renameTextureWithKey(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_renameTextureWithKey)

static bool js_cocos2dx_TextureCache_removeUnusedTextures(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_removeUnusedTextures : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeUnusedTextures();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_removeUnusedTextures)

static bool js_cocos2dx_TextureCache_removeTexture(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_removeTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_removeTexture : Error processing arguments");
        cobj->removeTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_removeTexture)

static bool js_cocos2dx_TextureCache_waitForQuit(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_waitForQuit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->waitForQuit();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_waitForQuit)

static bool js_cocos2dx_TextureCache_setETC1AlphaFileSuffix(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_setETC1AlphaFileSuffix : Error processing arguments");
        cocos2d::TextureCache::setETC1AlphaFileSuffix(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_setETC1AlphaFileSuffix)

static bool js_cocos2dx_TextureCache_getETC1AlphaFileSuffix(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cocos2d::TextureCache::getETC1AlphaFileSuffix();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getETC1AlphaFileSuffix : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_getETC1AlphaFileSuffix)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TextureCache_finalize)

static bool js_cocos2dx_TextureCache_constructor(se::State& s)
{
    cocos2d::TextureCache* cobj = new (std::nothrow) cocos2d::TextureCache();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TextureCache_constructor, __jsb_cocos2d_TextureCache_class, js_cocos2d_TextureCache_finalize)




bool js_cocos2d_TextureCache_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TextureCache)", s.nativeThisObject());
        cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TextureCache_finalize)

bool js_register_cocos2dx_TextureCache(se::Object* obj)
{
    auto cls = se::Class::create("TextureCache", obj, nullptr, _SE(js_cocos2dx_TextureCache_constructor));

    cls->defineFunction("reloadTexture", _SE(js_cocos2dx_TextureCache_reloadTexture));
    cls->defineFunction("unbindAllImageAsync", _SE(js_cocos2dx_TextureCache_unbindAllImageAsync));
    cls->defineFunction("removeTextureForKey", _SE(js_cocos2dx_TextureCache_removeTextureForKey));
    cls->defineFunction("removeAllTextures", _SE(js_cocos2dx_TextureCache_removeAllTextures));
    cls->defineFunction("addImageAsync", _SE(js_cocos2dx_TextureCache_addImageAsync));
    cls->defineFunction("getDescription", _SE(js_cocos2dx_TextureCache_getDescription));
    cls->defineFunction("getCachedTextureInfo", _SE(js_cocos2dx_TextureCache_getCachedTextureInfo));
    cls->defineFunction("addImage", _SE(js_cocos2dx_TextureCache_addImage));
    cls->defineFunction("unbindImageAsync", _SE(js_cocos2dx_TextureCache_unbindImageAsync));
    cls->defineFunction("getTextureForKey", _SE(js_cocos2dx_TextureCache_getTextureForKey));
    cls->defineFunction("getTextureFilePath", _SE(js_cocos2dx_TextureCache_getTextureFilePath));
    cls->defineFunction("renameTextureWithKey", _SE(js_cocos2dx_TextureCache_renameTextureWithKey));
    cls->defineFunction("removeUnusedTextures", _SE(js_cocos2dx_TextureCache_removeUnusedTextures));
    cls->defineFunction("removeTexture", _SE(js_cocos2dx_TextureCache_removeTexture));
    cls->defineFunction("waitForQuit", _SE(js_cocos2dx_TextureCache_waitForQuit));
    cls->defineStaticFunction("setETC1AlphaFileSuffix", _SE(js_cocos2dx_TextureCache_setETC1AlphaFileSuffix));
    cls->defineStaticFunction("getETC1AlphaFileSuffix", _SE(js_cocos2dx_TextureCache_getETC1AlphaFileSuffix));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TextureCache_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TextureCache>(cls);

    __jsb_cocos2d_TextureCache_proto = cls->getProto();
    __jsb_cocos2d_TextureCache_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Device_proto = nullptr;
se::Class* __jsb_cocos2d_Device_class = nullptr;

static bool js_cocos2dx_Device_setAccelerometerEnabled(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Device_setAccelerometerEnabled : Error processing arguments");
        cocos2d::Device::setAccelerometerEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Device_setAccelerometerEnabled)

static bool js_cocos2dx_Device_setAccelerometerInterval(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Device_setAccelerometerInterval : Error processing arguments");
        cocos2d::Device::setAccelerometerInterval(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Device_setAccelerometerInterval)

static bool js_cocos2dx_Device_setKeepScreenOn(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Device_setKeepScreenOn : Error processing arguments");
        cocos2d::Device::setKeepScreenOn(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Device_setKeepScreenOn)

static bool js_cocos2dx_Device_vibrate(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Device_vibrate : Error processing arguments");
        cocos2d::Device::vibrate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Device_vibrate)

static bool js_cocos2dx_Device_getDPI(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cocos2d::Device::getDPI();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Device_getDPI : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Device_getDPI)




bool js_register_cocos2dx_Device(se::Object* obj)
{
    auto cls = se::Class::create("Device", obj, nullptr, nullptr);

    cls->defineStaticFunction("setAccelerometerEnabled", _SE(js_cocos2dx_Device_setAccelerometerEnabled));
    cls->defineStaticFunction("setAccelerometerInterval", _SE(js_cocos2dx_Device_setAccelerometerInterval));
    cls->defineStaticFunction("setKeepScreenOn", _SE(js_cocos2dx_Device_setKeepScreenOn));
    cls->defineStaticFunction("vibrate", _SE(js_cocos2dx_Device_vibrate));
    cls->defineStaticFunction("getDPI", _SE(js_cocos2dx_Device_getDPI));
    cls->install();
    JSBClassType::registerClass<cocos2d::Device>(cls);

    __jsb_cocos2d_Device_proto = cls->getProto();
    __jsb_cocos2d_Device_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_SAXParser_proto = nullptr;
se::Class* __jsb_cocos2d_SAXParser_class = nullptr;

static bool js_cocos2dx_SAXParser_init(se::State& s)
{
    cocos2d::SAXParser* cobj = (cocos2d::SAXParser*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SAXParser_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SAXParser_init : Error processing arguments");
        bool result = cobj->init(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SAXParser_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SAXParser_init)




bool js_register_cocos2dx_SAXParser(se::Object* obj)
{
    auto cls = se::Class::create("PlistParser", obj, nullptr, nullptr);

    cls->defineFunction("init", _SE(js_cocos2dx_SAXParser_init));
    cls->install();
    JSBClassType::registerClass<cocos2d::SAXParser>(cls);

    __jsb_cocos2d_SAXParser_proto = cls->getProto();
    __jsb_cocos2d_SAXParser_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_Application_proto = nullptr;
se::Class* __jsb_cocos2d_Application_class = nullptr;

static bool js_cocos2dx_Application_getTargetPlatform(se::State& s)
{
    cocos2d::Application* cobj = (cocos2d::Application*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Application_getTargetPlatform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getTargetPlatform();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Application_getTargetPlatform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Application_getTargetPlatform)

static bool js_cocos2dx_Application_getCurrentLanguage(se::State& s)
{
    cocos2d::Application* cobj = (cocos2d::Application*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Application_getCurrentLanguage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getCurrentLanguage();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Application_getCurrentLanguage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Application_getCurrentLanguage)

static bool js_cocos2dx_Application_openURL(se::State& s)
{
    cocos2d::Application* cobj = (cocos2d::Application*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Application_openURL : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Application_openURL : Error processing arguments");
        bool result = cobj->openURL(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Application_openURL : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Application_openURL)

static bool js_cocos2dx_Application_getVersion(se::State& s)
{
    cocos2d::Application* cobj = (cocos2d::Application*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_Application_getVersion : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getVersion();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Application_getVersion : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Application_getVersion)

static bool js_cocos2dx_Application_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Application* result = cocos2d::Application::getInstance();
        ok &= native_ptr_to_seval<cocos2d::Application>((cocos2d::Application*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_Application_getInstance : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Application_getInstance)




bool js_register_cocos2dx_Application(se::Object* obj)
{
    auto cls = se::Class::create("Application", obj, nullptr, nullptr);

    cls->defineFunction("getTargetPlatform", _SE(js_cocos2dx_Application_getTargetPlatform));
    cls->defineFunction("getCurrentLanguage", _SE(js_cocos2dx_Application_getCurrentLanguage));
    cls->defineFunction("openURL", _SE(js_cocos2dx_Application_openURL));
    cls->defineFunction("getVersion", _SE(js_cocos2dx_Application_getVersion));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_Application_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::Application>(cls);

    __jsb_cocos2d_Application_proto = cls->getProto();
    __jsb_cocos2d_Application_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_AnimationCache_proto = nullptr;
se::Class* __jsb_cocos2d_AnimationCache_class = nullptr;

static bool js_cocos2dx_AnimationCache_getAnimation(se::State& s)
{
    cocos2d::AnimationCache* cobj = (cocos2d::AnimationCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationCache_getAnimation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationCache_getAnimation : Error processing arguments");
        cocos2d::Animation* result = cobj->getAnimation(arg0);
        ok &= native_ptr_to_seval<cocos2d::Animation>((cocos2d::Animation*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationCache_getAnimation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationCache_getAnimation)

static bool js_cocos2dx_AnimationCache_addAnimation(se::State& s)
{
    cocos2d::AnimationCache* cobj = (cocos2d::AnimationCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationCache_addAnimation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Animation* arg0 = nullptr;
        std::string arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationCache_addAnimation : Error processing arguments");
        cobj->addAnimation(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationCache_addAnimation)

static bool js_cocos2dx_AnimationCache_init(se::State& s)
{
    cocos2d::AnimationCache* cobj = (cocos2d::AnimationCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationCache_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationCache_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationCache_init)

static bool js_cocos2dx_AnimationCache_addAnimationsWithDictionary(se::State& s)
{
    cocos2d::AnimationCache* cobj = (cocos2d::AnimationCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationCache_addAnimationsWithDictionary : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ValueMap arg0;
        std::string arg1;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationCache_addAnimationsWithDictionary : Error processing arguments");
        cobj->addAnimationsWithDictionary(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationCache_addAnimationsWithDictionary)

static bool js_cocos2dx_AnimationCache_removeAnimation(se::State& s)
{
    cocos2d::AnimationCache* cobj = (cocos2d::AnimationCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationCache_removeAnimation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationCache_removeAnimation : Error processing arguments");
        cobj->removeAnimation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationCache_removeAnimation)

static bool js_cocos2dx_AnimationCache_addAnimationsWithFile(se::State& s)
{
    cocos2d::AnimationCache* cobj = (cocos2d::AnimationCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_AnimationCache_addAnimationsWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_AnimationCache_addAnimationsWithFile : Error processing arguments");
        cobj->addAnimationsWithFile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationCache_addAnimationsWithFile)

static bool js_cocos2dx_AnimationCache_destroyInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::AnimationCache::destroyInstance();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationCache_destroyInstance)

static bool js_cocos2dx_AnimationCache_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::AnimationCache::getInstance();
        se::Object* obj = nullptr;
        if (result->_scriptObject == nullptr)
        {
            obj = se::Object::createObjectWithClass(__jsb_cocos2d_AnimationCache_class, true);
            obj->setPrivateData(result);
            result->_scriptObject = obj;
        }
        else
        {
            obj = se::Object::getObjectWithPtr(result);
        }
        assert(obj);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AnimationCache_getInstance)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_AnimationCache_finalize)

static bool js_cocos2dx_AnimationCache_constructor(se::State& s)
{
    cocos2d::AnimationCache* cobj = new (std::nothrow) cocos2d::AnimationCache();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_AnimationCache_constructor, __jsb_cocos2d_AnimationCache_class, js_cocos2d_AnimationCache_finalize)

static bool js_cocos2dx_AnimationCache_ctor(se::State& s)
{
    cocos2d::AnimationCache* cobj = new (std::nothrow) cocos2d::AnimationCache();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_AnimationCache_ctor, __jsb_cocos2d_AnimationCache_class, js_cocos2d_AnimationCache_finalize)


    


bool js_cocos2d_AnimationCache_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::AnimationCache)", s.nativeThisObject());
        cocos2d::AnimationCache* cobj = (cocos2d::AnimationCache*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_AnimationCache_finalize)

bool js_register_cocos2dx_AnimationCache(se::Object* obj)
{
    auto cls = se::Class::create("AnimationCache", obj, nullptr, _SE(js_cocos2dx_AnimationCache_constructor));

    cls->defineFunction("getAnimation", _SE(js_cocos2dx_AnimationCache_getAnimation));
    cls->defineFunction("addAnimation", _SE(js_cocos2dx_AnimationCache_addAnimation));
    cls->defineFunction("init", _SE(js_cocos2dx_AnimationCache_init));
    cls->defineFunction("addAnimationsWithDictionary", _SE(js_cocos2dx_AnimationCache_addAnimationsWithDictionary));
    cls->defineFunction("removeAnimation", _SE(js_cocos2dx_AnimationCache_removeAnimation));
    cls->defineFunction("addAnimations", _SE(js_cocos2dx_AnimationCache_addAnimationsWithFile));
    cls->defineFunction("ctor", _SE(js_cocos2dx_AnimationCache_ctor));
    cls->defineStaticFunction("destroyInstance", _SE(js_cocos2dx_AnimationCache_destroyInstance));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_AnimationCache_getInstance));
    cls->defineFinalizedFunction(_SE(js_cocos2d_AnimationCache_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::AnimationCache>(cls);

    __jsb_cocos2d_AnimationCache_proto = cls->getProto();
    __jsb_cocos2d_AnimationCache_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.AnimationCache.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_SpriteBatchNode_proto = nullptr;
se::Class* __jsb_cocos2d_SpriteBatchNode_class = nullptr;

static bool js_cocos2dx_SpriteBatchNode_appendChild(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_appendChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_appendChild : Error processing arguments");
        cobj->appendChild(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_appendChild)

static bool js_cocos2dx_SpriteBatchNode_reorderBatch(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_reorderBatch : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_reorderBatch : Error processing arguments");
        cobj->reorderBatch(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_reorderBatch)

static bool js_cocos2dx_SpriteBatchNode_getTexture(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_getTexture)

static bool js_cocos2dx_SpriteBatchNode_setTexture(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_setTexture)

static bool js_cocos2dx_SpriteBatchNode_removeChildAtIndex(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_removeChildAtIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        ssize_t arg0 = 0;
        bool arg1;
        ok &= seval_to_ssize(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_removeChildAtIndex : Error processing arguments");
        cobj->removeChildAtIndex(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_removeChildAtIndex)

static bool js_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas : Error processing arguments");
        cobj->removeSpriteFromAtlas(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas)

static bool js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Sprite* arg0 = nullptr;
        int arg1 = 0;
        int arg2 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad : Error processing arguments");
        cocos2d::SpriteBatchNode* result = cobj->addSpriteWithoutQuad(arg0, arg1, arg2);
        ok &= native_ptr_to_seval<cocos2d::SpriteBatchNode>((cocos2d::SpriteBatchNode*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad)

static bool js_cocos2dx_SpriteBatchNode_atlasIndexForChild(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_atlasIndexForChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Sprite* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_atlasIndexForChild : Error processing arguments");
        ssize_t result = cobj->atlasIndexForChild(arg0, arg1);
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_atlasIndexForChild : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_atlasIndexForChild)

static bool js_cocos2dx_SpriteBatchNode_increaseAtlasCapacity(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_increaseAtlasCapacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->increaseAtlasCapacity();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_increaseAtlasCapacity)

static bool js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild : Error processing arguments");
        ssize_t result = cobj->lowestAtlasIndexInChild(arg0);
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild)

static bool js_cocos2dx_SpriteBatchNode_getBlendFunc(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_getBlendFunc)

static bool js_cocos2dx_SpriteBatchNode_initWithTexture(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_initWithTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithTexture : Error processing arguments");
        bool result = cobj->initWithTexture(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithTexture : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        cocos2d::Texture2D* arg0 = nullptr;
        ssize_t arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithTexture : Error processing arguments");
        bool result = cobj->initWithTexture(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_initWithTexture)

static bool js_cocos2dx_SpriteBatchNode_setTextureAtlas(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_setTextureAtlas : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextureAtlas* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_setTextureAtlas : Error processing arguments");
        cobj->setTextureAtlas(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_setTextureAtlas)

static bool js_cocos2dx_SpriteBatchNode_reserveCapacity(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_reserveCapacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        ssize_t arg0 = 0;
        ok &= seval_to_ssize(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_reserveCapacity : Error processing arguments");
        cobj->reserveCapacity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_reserveCapacity)

static bool js_cocos2dx_SpriteBatchNode_insertQuadFromSprite(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_insertQuadFromSprite : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Sprite* arg0 = nullptr;
        ssize_t arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_insertQuadFromSprite : Error processing arguments");
        cobj->insertQuadFromSprite(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_insertQuadFromSprite)

static bool js_cocos2dx_SpriteBatchNode_initWithFile(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_initWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithFile : Error processing arguments");
        bool result = cobj->initWithFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithFile : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        ssize_t arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithFile : Error processing arguments");
        bool result = cobj->initWithFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_initWithFile)

static bool js_cocos2dx_SpriteBatchNode_setBlendFunc(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_setBlendFunc)

static bool js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Sprite* arg0 = nullptr;
        ssize_t arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder : Error processing arguments");
        ssize_t result = cobj->rebuildIndexInOrder(arg0, arg1);
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder)

static bool js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild : Error processing arguments");
        ssize_t result = cobj->highestAtlasIndexInChild(arg0);
        ok &= ssize_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild)

static bool js_cocos2dx_SpriteBatchNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_create : Error processing arguments");
        auto result = cocos2d::SpriteBatchNode::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SpriteBatchNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        ssize_t arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_create : Error processing arguments");
        auto result = cocos2d::SpriteBatchNode::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SpriteBatchNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_create)

static bool js_cocos2dx_SpriteBatchNode_createWithTexture(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_createWithTexture : Error processing arguments");
        auto result = cocos2d::SpriteBatchNode::createWithTexture(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SpriteBatchNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        cocos2d::Texture2D* arg0 = nullptr;
        ssize_t arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_createWithTexture : Error processing arguments");
        auto result = cocos2d::SpriteBatchNode::createWithTexture(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SpriteBatchNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_createWithTexture)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_SpriteBatchNode_finalize)

static bool js_cocos2dx_SpriteBatchNode_constructor(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = new (std::nothrow) cocos2d::SpriteBatchNode();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_SpriteBatchNode_constructor, __jsb_cocos2d_SpriteBatchNode_class, js_cocos2d_SpriteBatchNode_finalize)

static bool js_cocos2dx_SpriteBatchNode_ctor(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = new (std::nothrow) cocos2d::SpriteBatchNode();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_SpriteBatchNode_ctor, __jsb_cocos2d_SpriteBatchNode_class, js_cocos2d_SpriteBatchNode_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_SpriteBatchNode_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::SpriteBatchNode)", s.nativeThisObject());
        cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_SpriteBatchNode_finalize)

bool js_register_cocos2dx_SpriteBatchNode(se::Object* obj)
{
    auto cls = se::Class::create("SpriteBatchNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_SpriteBatchNode_constructor));

    cls->defineFunction("appendChild", _SE(js_cocos2dx_SpriteBatchNode_appendChild));
    cls->defineFunction("reorderBatch", _SE(js_cocos2dx_SpriteBatchNode_reorderBatch));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_SpriteBatchNode_getTexture));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_SpriteBatchNode_setTexture));
    cls->defineFunction("removeChildAtIndex", _SE(js_cocos2dx_SpriteBatchNode_removeChildAtIndex));
    cls->defineFunction("removeSpriteFromAtlas", _SE(js_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas));
    cls->defineFunction("addSpriteWithoutQuad", _SE(js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad));
    cls->defineFunction("atlasIndexForChild", _SE(js_cocos2dx_SpriteBatchNode_atlasIndexForChild));
    cls->defineFunction("increaseAtlasCapacity", _SE(js_cocos2dx_SpriteBatchNode_increaseAtlasCapacity));
    cls->defineFunction("lowestAtlasIndexInChild", _SE(js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_SpriteBatchNode_getBlendFunc));
    cls->defineFunction("initWithTexture", _SE(js_cocos2dx_SpriteBatchNode_initWithTexture));
    cls->defineFunction("setTextureAtlas", _SE(js_cocos2dx_SpriteBatchNode_setTextureAtlas));
    cls->defineFunction("reserveCapacity", _SE(js_cocos2dx_SpriteBatchNode_reserveCapacity));
    cls->defineFunction("insertQuadFromSprite", _SE(js_cocos2dx_SpriteBatchNode_insertQuadFromSprite));
    cls->defineFunction("initWithFile", _SE(js_cocos2dx_SpriteBatchNode_initWithFile));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_SpriteBatchNode_setBlendFunc));
    cls->defineFunction("rebuildIndexInOrder", _SE(js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder));
    cls->defineFunction("highestAtlasIndexInChild", _SE(js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild));
    cls->defineFunction("ctor", _SE(js_cocos2dx_SpriteBatchNode_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_SpriteBatchNode_create));
    cls->defineStaticFunction("createWithTexture", _SE(js_cocos2dx_SpriteBatchNode_createWithTexture));
    cls->defineFinalizedFunction(_SE(js_cocos2d_SpriteBatchNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::SpriteBatchNode>(cls);

    __jsb_cocos2d_SpriteBatchNode_proto = cls->getProto();
    __jsb_cocos2d_SpriteBatchNode_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.SpriteBatchNode.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_SpriteFrameCache_proto = nullptr;
se::Class* __jsb_cocos2d_SpriteFrameCache_class = nullptr;

static bool js_cocos2dx_SpriteFrameCache_reloadTexture(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_reloadTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_reloadTexture : Error processing arguments");
        bool result = cobj->reloadTexture(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_reloadTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_reloadTexture)

static bool js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        cocos2d::Texture2D* arg1 = nullptr;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent : Error processing arguments");
        cobj->addSpriteFramesWithFileContent(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent)

static bool js_cocos2dx_SpriteFrameCache_addSpriteFrame(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_addSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        std::string arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_addSpriteFrame : Error processing arguments");
        cobj->addSpriteFrame(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_addSpriteFrame)

static bool js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->addSpriteFramesWithFile(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->addSpriteFramesWithFile(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->addSpriteFramesWithFile(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile)

static bool js_cocos2dx_SpriteFrameCache_getSpriteFrameByName(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_getSpriteFrameByName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_getSpriteFrameByName : Error processing arguments");
        cocos2d::SpriteFrame* result = cobj->getSpriteFrameByName(arg0);
        ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_getSpriteFrameByName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_getSpriteFrameByName)

static bool js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile : Error processing arguments");
        cobj->removeSpriteFramesFromFile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile)

static bool js_cocos2dx_SpriteFrameCache_init(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_init)

static bool js_cocos2dx_SpriteFrameCache_removeSpriteFrames(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFrames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeSpriteFrames();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeSpriteFrames)

static bool js_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeUnusedSpriteFrames();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames)

static bool js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent : Error processing arguments");
        cobj->removeSpriteFramesFromFileContent(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent)

static bool js_cocos2dx_SpriteFrameCache_removeSpriteFrameByName(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFrameByName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFrameByName : Error processing arguments");
        cobj->removeSpriteFrameByName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeSpriteFrameByName)

static bool js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded : Error processing arguments");
        bool result = cobj->isSpriteFramesWithFileLoaded(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded)

static bool js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture : Error processing arguments");
        cobj->removeSpriteFramesFromTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture)

static bool js_cocos2dx_SpriteFrameCache_destroyInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::SpriteFrameCache::destroyInstance();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_destroyInstance)

static bool js_cocos2dx_SpriteFrameCache_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::SpriteFrameCache::getInstance();
        se::Object* obj = nullptr;
        if (result->_scriptObject == nullptr)
        {
            obj = se::Object::createObjectWithClass(__jsb_cocos2d_SpriteFrameCache_class, true);
            obj->setPrivateData(result);
            result->_scriptObject = obj;
        }
        else
        {
            obj = se::Object::getObjectWithPtr(result);
        }
        assert(obj);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_getInstance)




bool js_register_cocos2dx_SpriteFrameCache(se::Object* obj)
{
    auto cls = se::Class::create("SpriteFrameCache", obj, nullptr, nullptr);

    cls->defineFunction("reloadTexture", _SE(js_cocos2dx_SpriteFrameCache_reloadTexture));
    cls->defineFunction("addSpriteFramesWithFileContent", _SE(js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent));
    cls->defineFunction("addSpriteFrame", _SE(js_cocos2dx_SpriteFrameCache_addSpriteFrame));
    cls->defineFunction("addSpriteFrames", _SE(js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile));
    cls->defineFunction("getSpriteFrame", _SE(js_cocos2dx_SpriteFrameCache_getSpriteFrameByName));
    cls->defineFunction("removeSpriteFramesFromFile", _SE(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile));
    cls->defineFunction("init", _SE(js_cocos2dx_SpriteFrameCache_init));
    cls->defineFunction("removeSpriteFrames", _SE(js_cocos2dx_SpriteFrameCache_removeSpriteFrames));
    cls->defineFunction("removeUnusedSpriteFrames", _SE(js_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames));
    cls->defineFunction("removeSpriteFramesFromFileContent", _SE(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent));
    cls->defineFunction("removeSpriteFrameByName", _SE(js_cocos2dx_SpriteFrameCache_removeSpriteFrameByName));
    cls->defineFunction("isSpriteFramesWithFileLoaded", _SE(js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded));
    cls->defineFunction("removeSpriteFramesFromTexture", _SE(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture));
    cls->defineStaticFunction("destroyInstance", _SE(js_cocos2dx_SpriteFrameCache_destroyInstance));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_SpriteFrameCache_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::SpriteFrameCache>(cls);

    __jsb_cocos2d_SpriteFrameCache_proto = cls->getProto();
    __jsb_cocos2d_SpriteFrameCache_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_TextFieldTTF_proto = nullptr;
se::Class* __jsb_cocos2d_TextFieldTTF_class = nullptr;

static bool js_cocos2dx_TextFieldTTF_getCharCount(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_getCharCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned long result = cobj->getCharCount();
        ok &= ulong_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_getCharCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_getCharCount)

static bool js_cocos2dx_TextFieldTTF_setCursorChar(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setCursorChar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int8_t arg0;
        ok &= seval_to_int8(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setCursorChar : Error processing arguments");
        cobj->setCursorChar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setCursorChar)

static bool js_cocos2dx_TextFieldTTF_setSecureTextEntry(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setSecureTextEntry : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setSecureTextEntry : Error processing arguments");
        cobj->setSecureTextEntry(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setSecureTextEntry)

static bool js_cocos2dx_TextFieldTTF_setCursorEnabled(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setCursorEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setCursorEnabled : Error processing arguments");
        cobj->setCursorEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setCursorEnabled)

static bool js_cocos2dx_TextFieldTTF_getColorSpaceHolder(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_getColorSpaceHolder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4B& result = cobj->getColorSpaceHolder();
        ok &= Color4B_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_getColorSpaceHolder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_getColorSpaceHolder)

static bool js_cocos2dx_TextFieldTTF_initWithPlaceHolder(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TextFieldTTF_initWithPlaceHolder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithPlaceHolder(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_initWithPlaceHolder : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg1;
            ok &= seval_to_Size(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            std::string arg3;
            ok &= seval_to_std_string(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithPlaceHolder(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_initWithPlaceHolder : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_initWithPlaceHolder)

static bool js_cocos2dx_TextFieldTTF_appendString(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_appendString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_appendString : Error processing arguments");
        cobj->appendString(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_appendString)

static bool js_cocos2dx_TextFieldTTF_getPasswordTextStyle(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_getPasswordTextStyle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getPasswordTextStyle();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_getPasswordTextStyle : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_getPasswordTextStyle)

static bool js_cocos2dx_TextFieldTTF_setPasswordTextStyle(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setPasswordTextStyle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setPasswordTextStyle : Error processing arguments");
        cobj->setPasswordTextStyle(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setPasswordTextStyle)

static bool js_cocos2dx_TextFieldTTF_setColorSpaceHolder(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TextFieldTTF_setColorSpaceHolder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setColorSpaceHolder(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Color3B arg0;
            ok &= seval_to_Color3B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setColorSpaceHolder(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setColorSpaceHolder)

static bool js_cocos2dx_TextFieldTTF_detachWithIME(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_detachWithIME : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->detachWithIME();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_detachWithIME : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_detachWithIME)

static bool js_cocos2dx_TextFieldTTF_setPlaceHolder(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setPlaceHolder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setPlaceHolder : Error processing arguments");
        cobj->setPlaceHolder(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setPlaceHolder)

static bool js_cocos2dx_TextFieldTTF_setCursorFromPoint(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setCursorFromPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Vec2 arg0;
        const cocos2d::Camera* arg1 = nullptr;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setCursorFromPoint : Error processing arguments");
        cobj->setCursorFromPoint(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setCursorFromPoint)

static bool js_cocos2dx_TextFieldTTF_isSecureTextEntry(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_isSecureTextEntry : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isSecureTextEntry();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_isSecureTextEntry : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_isSecureTextEntry)

static bool js_cocos2dx_TextFieldTTF_getPlaceHolder(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_getPlaceHolder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getPlaceHolder();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_getPlaceHolder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_getPlaceHolder)

static bool js_cocos2dx_TextFieldTTF_setCursorPosition(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setCursorPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned long arg0 = 0;
        ok &= seval_to_ulong(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setCursorPosition : Error processing arguments");
        cobj->setCursorPosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setCursorPosition)

static bool js_cocos2dx_TextFieldTTF_attachWithIME(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_attachWithIME : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->attachWithIME();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_attachWithIME : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_attachWithIME)

static bool js_cocos2dx_TextFieldTTF_textFieldWithPlaceHolder(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TextFieldTTF* result = cocos2d::TextFieldTTF::textFieldWithPlaceHolder(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::TextFieldTTF>((cocos2d::TextFieldTTF*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_textFieldWithPlaceHolder : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg1;
            ok &= seval_to_Size(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg2;
            ok &= seval_to_int32(args[2], (int32_t *)&arg2);
            if (!ok) { ok = true; break; }
            std::string arg3;
            ok &= seval_to_std_string(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextFieldTTF* result = cocos2d::TextFieldTTF::textFieldWithPlaceHolder(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::TextFieldTTF>((cocos2d::TextFieldTTF*)result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_textFieldWithPlaceHolder : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_textFieldWithPlaceHolder)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TextFieldTTF_finalize)

static bool js_cocos2dx_TextFieldTTF_constructor(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = new (std::nothrow) cocos2d::TextFieldTTF();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TextFieldTTF_constructor, __jsb_cocos2d_TextFieldTTF_class, js_cocos2d_TextFieldTTF_finalize)

static bool js_cocos2dx_TextFieldTTF_ctor(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = new (std::nothrow) cocos2d::TextFieldTTF();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TextFieldTTF_ctor, __jsb_cocos2d_TextFieldTTF_class, js_cocos2d_TextFieldTTF_finalize)


    

extern se::Object* __jsb_cocos2d_Label_proto;

bool js_cocos2d_TextFieldTTF_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TextFieldTTF)", s.nativeThisObject());
        cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TextFieldTTF_finalize)

bool js_register_cocos2dx_TextFieldTTF(se::Object* obj)
{
    auto cls = se::Class::create("TextFieldTTF", obj, __jsb_cocos2d_Label_proto, _SE(js_cocos2dx_TextFieldTTF_constructor));

    cls->defineFunction("getCharCount", _SE(js_cocos2dx_TextFieldTTF_getCharCount));
    cls->defineFunction("setCursorChar", _SE(js_cocos2dx_TextFieldTTF_setCursorChar));
    cls->defineFunction("setSecureTextEntry", _SE(js_cocos2dx_TextFieldTTF_setSecureTextEntry));
    cls->defineFunction("setCursorEnabled", _SE(js_cocos2dx_TextFieldTTF_setCursorEnabled));
    cls->defineFunction("getColorSpaceHolder", _SE(js_cocos2dx_TextFieldTTF_getColorSpaceHolder));
    cls->defineFunction("initWithPlaceHolder", _SE(js_cocos2dx_TextFieldTTF_initWithPlaceHolder));
    cls->defineFunction("appendString", _SE(js_cocos2dx_TextFieldTTF_appendString));
    cls->defineFunction("getPasswordTextStyle", _SE(js_cocos2dx_TextFieldTTF_getPasswordTextStyle));
    cls->defineFunction("setPasswordTextStyle", _SE(js_cocos2dx_TextFieldTTF_setPasswordTextStyle));
    cls->defineFunction("setColorSpaceHolder", _SE(js_cocos2dx_TextFieldTTF_setColorSpaceHolder));
    cls->defineFunction("detachWithIME", _SE(js_cocos2dx_TextFieldTTF_detachWithIME));
    cls->defineFunction("setPlaceHolder", _SE(js_cocos2dx_TextFieldTTF_setPlaceHolder));
    cls->defineFunction("setCursorFromPoint", _SE(js_cocos2dx_TextFieldTTF_setCursorFromPoint));
    cls->defineFunction("isSecureTextEntry", _SE(js_cocos2dx_TextFieldTTF_isSecureTextEntry));
    cls->defineFunction("getPlaceHolder", _SE(js_cocos2dx_TextFieldTTF_getPlaceHolder));
    cls->defineFunction("setCursorPosition", _SE(js_cocos2dx_TextFieldTTF_setCursorPosition));
    cls->defineFunction("attachWithIME", _SE(js_cocos2dx_TextFieldTTF_attachWithIME));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TextFieldTTF_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TextFieldTTF_textFieldWithPlaceHolder));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TextFieldTTF_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TextFieldTTF>(cls);

    __jsb_cocos2d_TextFieldTTF_proto = cls->getProto();
    __jsb_cocos2d_TextFieldTTF_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TextFieldTTF.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_ParallaxNode_proto = nullptr;
se::Class* __jsb_cocos2d_ParallaxNode_class = nullptr;

static bool js_cocos2dx_ParallaxNode_addChild(se::State& s)
{
    cocos2d::ParallaxNode* cobj = (cocos2d::ParallaxNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParallaxNode_addChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        cocos2d::Node* arg0 = nullptr;
        int arg1 = 0;
        cocos2d::Vec2 arg2;
        cocos2d::Vec2 arg3;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t *)&arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_Vec2(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParallaxNode_addChild : Error processing arguments");
        cobj->addChild(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParallaxNode_addChild)

static bool js_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup(se::State& s)
{
    cocos2d::ParallaxNode* cobj = (cocos2d::ParallaxNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup : Error processing arguments");
        cobj->removeAllChildrenWithCleanup(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup)

static bool js_cocos2dx_ParallaxNode_setParallaxArray(se::State& s)
{
    cocos2d::ParallaxNode* cobj = (cocos2d::ParallaxNode*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_ParallaxNode_setParallaxArray : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::_ccArray* arg0 = nullptr;
        #pragma warning NO CONVERSION TO NATIVE FOR _ccArray*
		ok = false;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_ParallaxNode_setParallaxArray : Error processing arguments");
        cobj->setParallaxArray(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParallaxNode_setParallaxArray)

static bool js_cocos2dx_ParallaxNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParallaxNode::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParallaxNode_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParallaxNode_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParallaxNode_finalize)

static bool js_cocos2dx_ParallaxNode_constructor(se::State& s)
{
    cocos2d::ParallaxNode* cobj = new (std::nothrow) cocos2d::ParallaxNode();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParallaxNode_constructor, __jsb_cocos2d_ParallaxNode_class, js_cocos2d_ParallaxNode_finalize)

static bool js_cocos2dx_ParallaxNode_ctor(se::State& s)
{
    cocos2d::ParallaxNode* cobj = new (std::nothrow) cocos2d::ParallaxNode();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ParallaxNode_ctor, __jsb_cocos2d_ParallaxNode_class, js_cocos2d_ParallaxNode_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_ParallaxNode_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::ParallaxNode)", s.nativeThisObject());
        cocos2d::ParallaxNode* cobj = (cocos2d::ParallaxNode*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParallaxNode_finalize)

bool js_register_cocos2dx_ParallaxNode(se::Object* obj)
{
    auto cls = se::Class::create("ParallaxNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_ParallaxNode_constructor));

    cls->defineFunction("addChild", _SE(js_cocos2dx_ParallaxNode_addChild));
    cls->defineFunction("removeAllChildrenWithCleanup", _SE(js_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup));
    cls->defineFunction("setParallaxArray", _SE(js_cocos2dx_ParallaxNode_setParallaxArray));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ParallaxNode_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParallaxNode_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_ParallaxNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParallaxNode>(cls);

    __jsb_cocos2d_ParallaxNode_proto = cls->getProto();
    __jsb_cocos2d_ParallaxNode_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.ParallaxNode.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TMXObjectGroup_proto = nullptr;
se::Class* __jsb_cocos2d_TMXObjectGroup_class = nullptr;

static bool js_cocos2dx_TMXObjectGroup_setPositionOffset(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_setPositionOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_setPositionOffset : Error processing arguments");
        cobj->setPositionOffset(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_setPositionOffset)

static bool js_cocos2dx_TMXObjectGroup_getProperty(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_getProperty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getProperty : Error processing arguments");
        cocos2d::Value result = cobj->getProperty(arg0);
        ok &= ccvalue_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getProperty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getProperty)

static bool js_cocos2dx_TMXObjectGroup_getPositionOffset(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_getPositionOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getPositionOffset();
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getPositionOffset : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getPositionOffset)

static bool js_cocos2dx_TMXObjectGroup_getObject(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_getObject : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getObject : Error processing arguments");
        cocos2d::ValueMap result = cobj->getObject(arg0);
        ok &= ccvaluemap_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getObject : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getObject)

static bool js_cocos2dx_TMXObjectGroup_getObjects(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TMXObjectGroup_getObjects : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::ValueVector& result = cobj->getObjects();
            ok &= ccvaluevector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getObjects : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::ValueVector& result = cobj->getObjects();
            ok &= ccvaluevector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getObjects : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getObjects)

static bool js_cocos2dx_TMXObjectGroup_setGroupName(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_setGroupName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_setGroupName : Error processing arguments");
        cobj->setGroupName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_setGroupName)

static bool js_cocos2dx_TMXObjectGroup_getProperties(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TMXObjectGroup_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getProperties)

static bool js_cocos2dx_TMXObjectGroup_getGroupName(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_getGroupName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getGroupName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getGroupName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getGroupName)

static bool js_cocos2dx_TMXObjectGroup_setProperties(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_setProperties)

static bool js_cocos2dx_TMXObjectGroup_setObjects(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_setObjects : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueVector arg0;
        ok &= seval_to_ccvaluevector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_setObjects : Error processing arguments");
        cobj->setObjects(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_setObjects)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXObjectGroup_finalize)

static bool js_cocos2dx_TMXObjectGroup_constructor(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = new (std::nothrow) cocos2d::TMXObjectGroup();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXObjectGroup_constructor, __jsb_cocos2d_TMXObjectGroup_class, js_cocos2d_TMXObjectGroup_finalize)




bool js_cocos2d_TMXObjectGroup_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TMXObjectGroup)", s.nativeThisObject());
        cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXObjectGroup_finalize)

bool js_register_cocos2dx_TMXObjectGroup(se::Object* obj)
{
    auto cls = se::Class::create("TMXObjectGroup", obj, nullptr, _SE(js_cocos2dx_TMXObjectGroup_constructor));

    cls->defineFunction("setPositionOffset", _SE(js_cocos2dx_TMXObjectGroup_setPositionOffset));
    cls->defineFunction("getProperty", _SE(js_cocos2dx_TMXObjectGroup_getProperty));
    cls->defineFunction("getPositionOffset", _SE(js_cocos2dx_TMXObjectGroup_getPositionOffset));
    cls->defineFunction("getObject", _SE(js_cocos2dx_TMXObjectGroup_getObject));
    cls->defineFunction("getObjects", _SE(js_cocos2dx_TMXObjectGroup_getObjects));
    cls->defineFunction("setGroupName", _SE(js_cocos2dx_TMXObjectGroup_setGroupName));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXObjectGroup_getProperties));
    cls->defineFunction("getGroupName", _SE(js_cocos2dx_TMXObjectGroup_getGroupName));
    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXObjectGroup_setProperties));
    cls->defineFunction("setObjects", _SE(js_cocos2dx_TMXObjectGroup_setObjects));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TMXObjectGroup_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXObjectGroup>(cls);

    __jsb_cocos2d_TMXObjectGroup_proto = cls->getProto();
    __jsb_cocos2d_TMXObjectGroup_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_TMXLayerInfo_proto = nullptr;
se::Class* __jsb_cocos2d_TMXLayerInfo_class = nullptr;

static bool js_cocos2dx_TMXLayerInfo_setProperties(se::State& s)
{
    cocos2d::TMXLayerInfo* cobj = (cocos2d::TMXLayerInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayerInfo_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayerInfo_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayerInfo_setProperties)

static bool js_cocos2dx_TMXLayerInfo_getProperties(se::State& s)
{
    cocos2d::TMXLayerInfo* cobj = (cocos2d::TMXLayerInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayerInfo_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ValueMap& result = cobj->getProperties();
        ok &= ccvaluemap_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayerInfo_getProperties : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayerInfo_getProperties)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXLayerInfo_finalize)

static bool js_cocos2dx_TMXLayerInfo_constructor(se::State& s)
{
    cocos2d::TMXLayerInfo* cobj = new (std::nothrow) cocos2d::TMXLayerInfo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXLayerInfo_constructor, __jsb_cocos2d_TMXLayerInfo_class, js_cocos2d_TMXLayerInfo_finalize)




bool js_cocos2d_TMXLayerInfo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TMXLayerInfo)", s.nativeThisObject());
        cocos2d::TMXLayerInfo* cobj = (cocos2d::TMXLayerInfo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXLayerInfo_finalize)

bool js_register_cocos2dx_TMXLayerInfo(se::Object* obj)
{
    auto cls = se::Class::create("TMXLayerInfo", obj, nullptr, _SE(js_cocos2dx_TMXLayerInfo_constructor));

    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXLayerInfo_setProperties));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXLayerInfo_getProperties));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TMXLayerInfo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXLayerInfo>(cls);

    __jsb_cocos2d_TMXLayerInfo_proto = cls->getProto();
    __jsb_cocos2d_TMXLayerInfo_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_TMXTilesetInfo_proto = nullptr;
se::Class* __jsb_cocos2d_TMXTilesetInfo_class = nullptr;

static bool js_cocos2dx_TMXTilesetInfo_getRectForGID(se::State& s)
{
    cocos2d::TMXTilesetInfo* cobj = (cocos2d::TMXTilesetInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTilesetInfo_getRectForGID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTilesetInfo_getRectForGID : Error processing arguments");
        cocos2d::Rect result = cobj->getRectForGID(arg0);
        ok &= Rect_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTilesetInfo_getRectForGID : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTilesetInfo_getRectForGID)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXTilesetInfo_finalize)

static bool js_cocos2dx_TMXTilesetInfo_constructor(se::State& s)
{
    cocos2d::TMXTilesetInfo* cobj = new (std::nothrow) cocos2d::TMXTilesetInfo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXTilesetInfo_constructor, __jsb_cocos2d_TMXTilesetInfo_class, js_cocos2d_TMXTilesetInfo_finalize)




bool js_cocos2d_TMXTilesetInfo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TMXTilesetInfo)", s.nativeThisObject());
        cocos2d::TMXTilesetInfo* cobj = (cocos2d::TMXTilesetInfo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXTilesetInfo_finalize)

bool js_register_cocos2dx_TMXTilesetInfo(se::Object* obj)
{
    auto cls = se::Class::create("TMXTilesetInfo", obj, nullptr, _SE(js_cocos2dx_TMXTilesetInfo_constructor));

    cls->defineFunction("getRectForGID", _SE(js_cocos2dx_TMXTilesetInfo_getRectForGID));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TMXTilesetInfo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXTilesetInfo>(cls);

    __jsb_cocos2d_TMXTilesetInfo_proto = cls->getProto();
    __jsb_cocos2d_TMXTilesetInfo_class = cls;

    return true;
}

se::Object* __jsb_cocos2d_TMXMapInfo_proto = nullptr;
se::Class* __jsb_cocos2d_TMXMapInfo_class = nullptr;

static bool js_cocos2dx_TMXMapInfo_setCurrentString(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setCurrentString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setCurrentString : Error processing arguments");
        cobj->setCurrentString(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setCurrentString)

static bool js_cocos2dx_TMXMapInfo_getHexSideLength(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getHexSideLength : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getHexSideLength();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getHexSideLength : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getHexSideLength)

static bool js_cocos2dx_TMXMapInfo_setTileSize(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setTileSize : Error processing arguments");
        cobj->setTileSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setTileSize)

static bool js_cocos2dx_TMXMapInfo_initWithTMXFile(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_initWithTMXFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_initWithTMXFile : Error processing arguments");
        bool result = cobj->initWithTMXFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_initWithTMXFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_initWithTMXFile)

static bool js_cocos2dx_TMXMapInfo_getOrientation(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getOrientation();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getOrientation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getOrientation)

static bool js_cocos2dx_TMXMapInfo_setObjectGroups(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setObjectGroups : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::TMXObjectGroup *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setObjectGroups : Error processing arguments");
        cobj->setObjectGroups(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setObjectGroups)

static bool js_cocos2dx_TMXMapInfo_setLayers(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setLayers : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::TMXLayerInfo *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setLayers : Error processing arguments");
        cobj->setLayers(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setLayers)

static bool js_cocos2dx_TMXMapInfo_parseXMLFile(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_parseXMLFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_parseXMLFile : Error processing arguments");
        bool result = cobj->parseXMLFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_parseXMLFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_parseXMLFile)

static bool js_cocos2dx_TMXMapInfo_getParentElement(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getParentElement : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getParentElement();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getParentElement : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getParentElement)

static bool js_cocos2dx_TMXMapInfo_setTMXFileName(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setTMXFileName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setTMXFileName : Error processing arguments");
        cobj->setTMXFileName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setTMXFileName)

static bool js_cocos2dx_TMXMapInfo_parseXMLString(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_parseXMLString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_parseXMLString : Error processing arguments");
        bool result = cobj->parseXMLString(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_parseXMLString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_parseXMLString)

static bool js_cocos2dx_TMXMapInfo_getLayers(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TMXMapInfo_getLayers : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXLayerInfo *>& result = cobj->getLayers();
            ok &= Vector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getLayers : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Vector<cocos2d::TMXLayerInfo *>& result = cobj->getLayers();
            ok &= Vector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getLayers : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getLayers)

static bool js_cocos2dx_TMXMapInfo_getStaggerAxis(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getStaggerAxis : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getStaggerAxis();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getStaggerAxis : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getStaggerAxis)

static bool js_cocos2dx_TMXMapInfo_setHexSideLength(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setHexSideLength : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setHexSideLength : Error processing arguments");
        cobj->setHexSideLength(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setHexSideLength)

static bool js_cocos2dx_TMXMapInfo_getTilesets(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TMXMapInfo_getTilesets : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXTilesetInfo *>& result = cobj->getTilesets();
            ok &= Vector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getTilesets : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Vector<cocos2d::TMXTilesetInfo *>& result = cobj->getTilesets();
            ok &= Vector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getTilesets : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getTilesets)

static bool js_cocos2dx_TMXMapInfo_getParentGID(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getParentGID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getParentGID();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getParentGID : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getParentGID)

static bool js_cocos2dx_TMXMapInfo_setParentElement(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setParentElement : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setParentElement : Error processing arguments");
        cobj->setParentElement(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setParentElement)

static bool js_cocos2dx_TMXMapInfo_initWithXML(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_initWithXML : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_initWithXML : Error processing arguments");
        bool result = cobj->initWithXML(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_initWithXML : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_initWithXML)

static bool js_cocos2dx_TMXMapInfo_setParentGID(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setParentGID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setParentGID : Error processing arguments");
        cobj->setParentGID(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setParentGID)

static bool js_cocos2dx_TMXMapInfo_getLayerAttribs(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getLayerAttribs : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getLayerAttribs();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getLayerAttribs : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getLayerAttribs)

static bool js_cocos2dx_TMXMapInfo_getTileSize(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getTileSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getTileSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getTileSize)

static bool js_cocos2dx_TMXMapInfo_getTileProperties(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getTileProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ValueMapIntKey& result = cobj->getTileProperties();
        ok &= ccvaluemapintkey_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getTileProperties : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getTileProperties)

static bool js_cocos2dx_TMXMapInfo_isStoringCharacters(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_isStoringCharacters : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isStoringCharacters();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_isStoringCharacters : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_isStoringCharacters)

static bool js_cocos2dx_TMXMapInfo_getExternalTilesetFileName(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getExternalTilesetFileName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getExternalTilesetFileName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getExternalTilesetFileName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getExternalTilesetFileName)

static bool js_cocos2dx_TMXMapInfo_getObjectGroups(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TMXMapInfo_getObjectGroups : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXObjectGroup *>& result = cobj->getObjectGroups();
            ok &= Vector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getObjectGroups : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Vector<cocos2d::TMXObjectGroup *>& result = cobj->getObjectGroups();
            ok &= Vector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getObjectGroups : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getObjectGroups)

static bool js_cocos2dx_TMXMapInfo_getTMXFileName(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getTMXFileName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getTMXFileName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getTMXFileName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getTMXFileName)

static bool js_cocos2dx_TMXMapInfo_setStaggerIndex(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setStaggerIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setStaggerIndex : Error processing arguments");
        cobj->setStaggerIndex(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setStaggerIndex)

static bool js_cocos2dx_TMXMapInfo_setProperties(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setProperties)

static bool js_cocos2dx_TMXMapInfo_setOrientation(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setOrientation : Error processing arguments");
        cobj->setOrientation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setOrientation)

static bool js_cocos2dx_TMXMapInfo_setTileProperties(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setTileProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMapIntKey arg0;
        ok &= seval_to_ccvaluemapintkey(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setTileProperties : Error processing arguments");
        cobj->setTileProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setTileProperties)

static bool js_cocos2dx_TMXMapInfo_setMapSize(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setMapSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setMapSize : Error processing arguments");
        cobj->setMapSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setMapSize)

static bool js_cocos2dx_TMXMapInfo_getCurrentString(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getCurrentString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getCurrentString();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getCurrentString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getCurrentString)

static bool js_cocos2dx_TMXMapInfo_setStoringCharacters(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setStoringCharacters : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setStoringCharacters : Error processing arguments");
        cobj->setStoringCharacters(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setStoringCharacters)

static bool js_cocos2dx_TMXMapInfo_setStaggerAxis(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setStaggerAxis : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setStaggerAxis : Error processing arguments");
        cobj->setStaggerAxis(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setStaggerAxis)

static bool js_cocos2dx_TMXMapInfo_getMapSize(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getMapSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getMapSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getMapSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getMapSize)

static bool js_cocos2dx_TMXMapInfo_setTilesets(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setTilesets : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::TMXTilesetInfo *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setTilesets : Error processing arguments");
        cobj->setTilesets(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setTilesets)

static bool js_cocos2dx_TMXMapInfo_getProperties(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TMXMapInfo_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getProperties)

static bool js_cocos2dx_TMXMapInfo_getStaggerIndex(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getStaggerIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getStaggerIndex();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getStaggerIndex : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getStaggerIndex)

static bool js_cocos2dx_TMXMapInfo_setLayerAttribs(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setLayerAttribs : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setLayerAttribs : Error processing arguments");
        cobj->setLayerAttribs(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setLayerAttribs)

static bool js_cocos2dx_TMXMapInfo_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_create : Error processing arguments");
        auto result = cocos2d::TMXMapInfo::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TMXMapInfo_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_create)

static bool js_cocos2dx_TMXMapInfo_createWithXML(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_createWithXML : Error processing arguments");
        auto result = cocos2d::TMXMapInfo::createWithXML(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TMXMapInfo_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_createWithXML)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXMapInfo_finalize)

static bool js_cocos2dx_TMXMapInfo_constructor(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = new (std::nothrow) cocos2d::TMXMapInfo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXMapInfo_constructor, __jsb_cocos2d_TMXMapInfo_class, js_cocos2d_TMXMapInfo_finalize)

static bool js_cocos2dx_TMXMapInfo_ctor(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = new (std::nothrow) cocos2d::TMXMapInfo();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TMXMapInfo_ctor, __jsb_cocos2d_TMXMapInfo_class, js_cocos2d_TMXMapInfo_finalize)


    


bool js_cocos2d_TMXMapInfo_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TMXMapInfo)", s.nativeThisObject());
        cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXMapInfo_finalize)

bool js_register_cocos2dx_TMXMapInfo(se::Object* obj)
{
    auto cls = se::Class::create("TMXMapInfo", obj, nullptr, _SE(js_cocos2dx_TMXMapInfo_constructor));

    cls->defineFunction("setCurrentString", _SE(js_cocos2dx_TMXMapInfo_setCurrentString));
    cls->defineFunction("getHexSideLength", _SE(js_cocos2dx_TMXMapInfo_getHexSideLength));
    cls->defineFunction("setTileSize", _SE(js_cocos2dx_TMXMapInfo_setTileSize));
    cls->defineFunction("initWithTMXFile", _SE(js_cocos2dx_TMXMapInfo_initWithTMXFile));
    cls->defineFunction("getOrientation", _SE(js_cocos2dx_TMXMapInfo_getOrientation));
    cls->defineFunction("setObjectGroups", _SE(js_cocos2dx_TMXMapInfo_setObjectGroups));
    cls->defineFunction("setLayers", _SE(js_cocos2dx_TMXMapInfo_setLayers));
    cls->defineFunction("parseXMLFile", _SE(js_cocos2dx_TMXMapInfo_parseXMLFile));
    cls->defineFunction("getParentElement", _SE(js_cocos2dx_TMXMapInfo_getParentElement));
    cls->defineFunction("setTMXFileName", _SE(js_cocos2dx_TMXMapInfo_setTMXFileName));
    cls->defineFunction("parseXMLString", _SE(js_cocos2dx_TMXMapInfo_parseXMLString));
    cls->defineFunction("getLayers", _SE(js_cocos2dx_TMXMapInfo_getLayers));
    cls->defineFunction("getStaggerAxis", _SE(js_cocos2dx_TMXMapInfo_getStaggerAxis));
    cls->defineFunction("setHexSideLength", _SE(js_cocos2dx_TMXMapInfo_setHexSideLength));
    cls->defineFunction("getTilesets", _SE(js_cocos2dx_TMXMapInfo_getTilesets));
    cls->defineFunction("getParentGID", _SE(js_cocos2dx_TMXMapInfo_getParentGID));
    cls->defineFunction("setParentElement", _SE(js_cocos2dx_TMXMapInfo_setParentElement));
    cls->defineFunction("initWithXML", _SE(js_cocos2dx_TMXMapInfo_initWithXML));
    cls->defineFunction("setParentGID", _SE(js_cocos2dx_TMXMapInfo_setParentGID));
    cls->defineFunction("getLayerAttribs", _SE(js_cocos2dx_TMXMapInfo_getLayerAttribs));
    cls->defineFunction("getTileSize", _SE(js_cocos2dx_TMXMapInfo_getTileSize));
    cls->defineFunction("getTileProperties", _SE(js_cocos2dx_TMXMapInfo_getTileProperties));
    cls->defineFunction("isStoringCharacters", _SE(js_cocos2dx_TMXMapInfo_isStoringCharacters));
    cls->defineFunction("getExternalTilesetFileName", _SE(js_cocos2dx_TMXMapInfo_getExternalTilesetFileName));
    cls->defineFunction("getObjectGroups", _SE(js_cocos2dx_TMXMapInfo_getObjectGroups));
    cls->defineFunction("getTMXFileName", _SE(js_cocos2dx_TMXMapInfo_getTMXFileName));
    cls->defineFunction("setStaggerIndex", _SE(js_cocos2dx_TMXMapInfo_setStaggerIndex));
    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXMapInfo_setProperties));
    cls->defineFunction("setOrientation", _SE(js_cocos2dx_TMXMapInfo_setOrientation));
    cls->defineFunction("setTileProperties", _SE(js_cocos2dx_TMXMapInfo_setTileProperties));
    cls->defineFunction("setMapSize", _SE(js_cocos2dx_TMXMapInfo_setMapSize));
    cls->defineFunction("getCurrentString", _SE(js_cocos2dx_TMXMapInfo_getCurrentString));
    cls->defineFunction("setStoringCharacters", _SE(js_cocos2dx_TMXMapInfo_setStoringCharacters));
    cls->defineFunction("setStaggerAxis", _SE(js_cocos2dx_TMXMapInfo_setStaggerAxis));
    cls->defineFunction("getMapSize", _SE(js_cocos2dx_TMXMapInfo_getMapSize));
    cls->defineFunction("setTilesets", _SE(js_cocos2dx_TMXMapInfo_setTilesets));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXMapInfo_getProperties));
    cls->defineFunction("getStaggerIndex", _SE(js_cocos2dx_TMXMapInfo_getStaggerIndex));
    cls->defineFunction("setLayerAttribs", _SE(js_cocos2dx_TMXMapInfo_setLayerAttribs));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TMXMapInfo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TMXMapInfo_create));
    cls->defineStaticFunction("createWithXML", _SE(js_cocos2dx_TMXMapInfo_createWithXML));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TMXMapInfo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXMapInfo>(cls);

    __jsb_cocos2d_TMXMapInfo_proto = cls->getProto();
    __jsb_cocos2d_TMXMapInfo_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TMXMapInfo.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TMXLayer_proto = nullptr;
se::Class* __jsb_cocos2d_TMXLayer_class = nullptr;

static bool js_cocos2dx_TMXLayer_getTileGIDAt(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getTileGIDAt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileGIDAt : Error processing arguments");
        unsigned int result = cobj->getTileGIDAt(arg0);
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileGIDAt : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        cocos2d::Vec2 arg0;
        cocos2d::TMXTileFlags_* arg1 = nullptr;
        ok &= seval_to_Vec2(args[0], &arg0);
        uint32_t tempData;arg1=(cocos2d::TMXTileFlags_*)&tempData;ok &= seval_to_uint32(args[1], (uint32_t *)&arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileGIDAt : Error processing arguments");
        unsigned int result = cobj->getTileGIDAt(arg0, arg1);
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileGIDAt : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getTileGIDAt)

static bool js_cocos2dx_TMXLayer_getPositionAt(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getPositionAt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getPositionAt : Error processing arguments");
        cocos2d::Vec2 result = cobj->getPositionAt(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getPositionAt : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getPositionAt)

static bool js_cocos2dx_TMXLayer_setLayerOrientation(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setLayerOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setLayerOrientation : Error processing arguments");
        cobj->setLayerOrientation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setLayerOrientation)

static bool js_cocos2dx_TMXLayer_releaseMap(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_releaseMap : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->releaseMap();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_releaseMap)

static bool js_cocos2dx_TMXLayer_setTiles(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setTiles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int* arg0 = 0;
        #pragma warning NO CONVERSION TO NATIVE FOR unsigned int*
		ok = false;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setTiles : Error processing arguments");
        cobj->setTiles(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setTiles)

static bool js_cocos2dx_TMXLayer_getLayerSize(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getLayerSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getLayerSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getLayerSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getLayerSize)

static bool js_cocos2dx_TMXLayer_setMapTileSize(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setMapTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setMapTileSize : Error processing arguments");
        cobj->setMapTileSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setMapTileSize)

static bool js_cocos2dx_TMXLayer_getLayerOrientation(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getLayerOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getLayerOrientation();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getLayerOrientation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getLayerOrientation)

static bool js_cocos2dx_TMXLayer_setProperties(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setProperties)

static bool js_cocos2dx_TMXLayer_setLayerName(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setLayerName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setLayerName : Error processing arguments");
        cobj->setLayerName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setLayerName)

static bool js_cocos2dx_TMXLayer_removeTileAt(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_removeTileAt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_removeTileAt : Error processing arguments");
        cobj->removeTileAt(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_removeTileAt)

static bool js_cocos2dx_TMXLayer_initWithTilesetInfo(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_initWithTilesetInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::TMXTilesetInfo* arg0 = nullptr;
        cocos2d::TMXLayerInfo* arg1 = nullptr;
        cocos2d::TMXMapInfo* arg2 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_native_ptr(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_initWithTilesetInfo : Error processing arguments");
        bool result = cobj->initWithTilesetInfo(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_initWithTilesetInfo : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_initWithTilesetInfo)

static bool js_cocos2dx_TMXLayer_setupTiles(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setupTiles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setupTiles();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setupTiles)

static bool js_cocos2dx_TMXLayer_setTileGID(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TMXLayer_setTileGID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            unsigned int arg0 = 0;
            ok &= seval_to_uint32(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TMXTileFlags_ arg2;
            ok &= seval_to_uint32(args[2], (uint32_t *)&arg2);
            if (!ok) { ok = true; break; }
            cobj->setTileGID(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            unsigned int arg0 = 0;
            ok &= seval_to_uint32(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setTileGID(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setTileGID)

static bool js_cocos2dx_TMXLayer_getMapTileSize(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getMapTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getMapTileSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getMapTileSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getMapTileSize)

static bool js_cocos2dx_TMXLayer_getProperty(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getProperty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getProperty : Error processing arguments");
        cocos2d::Value result = cobj->getProperty(arg0);
        ok &= ccvalue_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getProperty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getProperty)

static bool js_cocos2dx_TMXLayer_setLayerSize(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setLayerSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setLayerSize : Error processing arguments");
        cobj->setLayerSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setLayerSize)

static bool js_cocos2dx_TMXLayer_getLayerName(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getLayerName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getLayerName();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getLayerName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getLayerName)

static bool js_cocos2dx_TMXLayer_setTileSet(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setTileSet : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TMXTilesetInfo* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setTileSet : Error processing arguments");
        cobj->setTileSet(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setTileSet)

static bool js_cocos2dx_TMXLayer_getTileSet(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getTileSet : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::TMXTilesetInfo* result = cobj->getTileSet();
        ok &= native_ptr_to_seval<cocos2d::TMXTilesetInfo>((cocos2d::TMXTilesetInfo*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileSet : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getTileSet)

static bool js_cocos2dx_TMXLayer_getProperties(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TMXLayer_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getProperties)

static bool js_cocos2dx_TMXLayer_getTileAt(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getTileAt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileAt : Error processing arguments");
        cocos2d::Sprite* result = cobj->getTileAt(arg0);
        ok &= native_ptr_to_seval<cocos2d::Sprite>((cocos2d::Sprite*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileAt : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getTileAt)

static bool js_cocos2dx_TMXLayer_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::TMXTilesetInfo* arg0 = nullptr;
        cocos2d::TMXLayerInfo* arg1 = nullptr;
        cocos2d::TMXMapInfo* arg2 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_native_ptr(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_create : Error processing arguments");
        auto result = cocos2d::TMXLayer::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TMXLayer_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXLayer_finalize)

static bool js_cocos2dx_TMXLayer_constructor(se::State& s)
{
    cocos2d::TMXLayer* cobj = new (std::nothrow) cocos2d::TMXLayer();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXLayer_constructor, __jsb_cocos2d_TMXLayer_class, js_cocos2d_TMXLayer_finalize)

static bool js_cocos2dx_TMXLayer_ctor(se::State& s)
{
    cocos2d::TMXLayer* cobj = new (std::nothrow) cocos2d::TMXLayer();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TMXLayer_ctor, __jsb_cocos2d_TMXLayer_class, js_cocos2d_TMXLayer_finalize)


    

extern se::Object* __jsb_cocos2d_SpriteBatchNode_proto;

bool js_cocos2d_TMXLayer_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TMXLayer)", s.nativeThisObject());
        cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXLayer_finalize)

bool js_register_cocos2dx_TMXLayer(se::Object* obj)
{
    auto cls = se::Class::create("TMXLayer", obj, __jsb_cocos2d_SpriteBatchNode_proto, _SE(js_cocos2dx_TMXLayer_constructor));

    cls->defineFunction("getTileGIDAt", _SE(js_cocos2dx_TMXLayer_getTileGIDAt));
    cls->defineFunction("getPositionAt", _SE(js_cocos2dx_TMXLayer_getPositionAt));
    cls->defineFunction("setLayerOrientation", _SE(js_cocos2dx_TMXLayer_setLayerOrientation));
    cls->defineFunction("releaseMap", _SE(js_cocos2dx_TMXLayer_releaseMap));
    cls->defineFunction("setTiles", _SE(js_cocos2dx_TMXLayer_setTiles));
    cls->defineFunction("getLayerSize", _SE(js_cocos2dx_TMXLayer_getLayerSize));
    cls->defineFunction("setMapTileSize", _SE(js_cocos2dx_TMXLayer_setMapTileSize));
    cls->defineFunction("getLayerOrientation", _SE(js_cocos2dx_TMXLayer_getLayerOrientation));
    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXLayer_setProperties));
    cls->defineFunction("setLayerName", _SE(js_cocos2dx_TMXLayer_setLayerName));
    cls->defineFunction("removeTileAt", _SE(js_cocos2dx_TMXLayer_removeTileAt));
    cls->defineFunction("initWithTilesetInfo", _SE(js_cocos2dx_TMXLayer_initWithTilesetInfo));
    cls->defineFunction("setupTiles", _SE(js_cocos2dx_TMXLayer_setupTiles));
    cls->defineFunction("setTileGID", _SE(js_cocos2dx_TMXLayer_setTileGID));
    cls->defineFunction("getMapTileSize", _SE(js_cocos2dx_TMXLayer_getMapTileSize));
    cls->defineFunction("getProperty", _SE(js_cocos2dx_TMXLayer_getProperty));
    cls->defineFunction("setLayerSize", _SE(js_cocos2dx_TMXLayer_setLayerSize));
    cls->defineFunction("getLayerName", _SE(js_cocos2dx_TMXLayer_getLayerName));
    cls->defineFunction("setTileSet", _SE(js_cocos2dx_TMXLayer_setTileSet));
    cls->defineFunction("getTileSet", _SE(js_cocos2dx_TMXLayer_getTileSet));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXLayer_getProperties));
    cls->defineFunction("getTileAt", _SE(js_cocos2dx_TMXLayer_getTileAt));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TMXLayer_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TMXLayer_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TMXLayer_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXLayer>(cls);

    __jsb_cocos2d_TMXLayer_proto = cls->getProto();
    __jsb_cocos2d_TMXLayer_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TMXLayer.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TMXTiledMap_proto = nullptr;
se::Class* __jsb_cocos2d_TMXTiledMap_class = nullptr;

static bool js_cocos2dx_TMXTiledMap_setObjectGroups(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_setObjectGroups : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::TMXObjectGroup *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_setObjectGroups : Error processing arguments");
        cobj->setObjectGroups(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_setObjectGroups)

static bool js_cocos2dx_TMXTiledMap_getProperty(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getProperty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getProperty : Error processing arguments");
        cocos2d::Value result = cobj->getProperty(arg0);
        ok &= ccvalue_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getProperty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getProperty)

static bool js_cocos2dx_TMXTiledMap_getLayerNum(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getLayerNum : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getLayerNum();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getLayerNum : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getLayerNum)

static bool js_cocos2dx_TMXTiledMap_setMapSize(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_setMapSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_setMapSize : Error processing arguments");
        cobj->setMapSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_setMapSize)

static bool js_cocos2dx_TMXTiledMap_getObjectGroup(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getObjectGroup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getObjectGroup : Error processing arguments");
        cocos2d::TMXObjectGroup* result = cobj->getObjectGroup(arg0);
        ok &= native_ptr_to_seval<cocos2d::TMXObjectGroup>((cocos2d::TMXObjectGroup*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getObjectGroup : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getObjectGroup)

static bool js_cocos2dx_TMXTiledMap_getObjectGroups(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TMXTiledMap_getObjectGroups : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXObjectGroup *>& result = cobj->getObjectGroups();
            ok &= Vector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getObjectGroups : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Vector<cocos2d::TMXObjectGroup *>& result = cobj->getObjectGroups();
            ok &= Vector_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getObjectGroups : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getObjectGroups)

static bool js_cocos2dx_TMXTiledMap_getResourceFile(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getResourceFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getResourceFile();
        ok &= std_string_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getResourceFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getResourceFile)

static bool js_cocos2dx_TMXTiledMap_initWithTMXFile(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_initWithTMXFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_initWithTMXFile : Error processing arguments");
        bool result = cobj->initWithTMXFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_initWithTMXFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_initWithTMXFile)

static bool js_cocos2dx_TMXTiledMap_getTileSize(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getTileSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getTileSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getTileSize)

static bool js_cocos2dx_TMXTiledMap_getMapSize(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getMapSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getMapSize();
        ok &= Size_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getMapSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getMapSize)

static bool js_cocos2dx_TMXTiledMap_initWithXML(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_initWithXML : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_initWithXML : Error processing arguments");
        bool result = cobj->initWithXML(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_initWithXML : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_initWithXML)

static bool js_cocos2dx_TMXTiledMap_getProperties(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ValueMap& result = cobj->getProperties();
        ok &= ccvaluemap_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getProperties : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getProperties)

static bool js_cocos2dx_TMXTiledMap_getPropertiesForGID(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2( cobj, false, "js_cocos2dx_TMXTiledMap_getPropertiesForGID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Value** arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->getPropertiesForGID(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getPropertiesForGID : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t *)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Value result = cobj->getPropertiesForGID(arg0);
            ok &= ccvalue_to_seval(result, &s.rval());
            JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getPropertiesForGID : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getPropertiesForGID)

static bool js_cocos2dx_TMXTiledMap_setTileSize(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_setTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_setTileSize : Error processing arguments");
        cobj->setTileSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_setTileSize)

static bool js_cocos2dx_TMXTiledMap_setProperties(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_setProperties)

static bool js_cocos2dx_TMXTiledMap_getLayer(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getLayer : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getLayer : Error processing arguments");
        cocos2d::TMXLayer* result = cobj->getLayer(arg0);
        ok &= native_ptr_to_seval<cocos2d::TMXLayer>((cocos2d::TMXLayer*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getLayer : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getLayer)

static bool js_cocos2dx_TMXTiledMap_getMapOrientation(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getMapOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMapOrientation();
        ok &= int32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getMapOrientation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getMapOrientation)

static bool js_cocos2dx_TMXTiledMap_setMapOrientation(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_setMapOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t *)&arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_setMapOrientation : Error processing arguments");
        cobj->setMapOrientation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_setMapOrientation)

static bool js_cocos2dx_TMXTiledMap_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_create : Error processing arguments");
        auto result = cocos2d::TMXTiledMap::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TMXTiledMap_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_create)

static bool js_cocos2dx_TMXTiledMap_createWithXML(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_createWithXML : Error processing arguments");
        auto result = cocos2d::TMXTiledMap::createWithXML(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TMXTiledMap_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_createWithXML)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXTiledMap_finalize)

static bool js_cocos2dx_TMXTiledMap_constructor(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = new (std::nothrow) cocos2d::TMXTiledMap();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXTiledMap_constructor, __jsb_cocos2d_TMXTiledMap_class, js_cocos2d_TMXTiledMap_finalize)

static bool js_cocos2dx_TMXTiledMap_ctor(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = new (std::nothrow) cocos2d::TMXTiledMap();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TMXTiledMap_ctor, __jsb_cocos2d_TMXTiledMap_class, js_cocos2d_TMXTiledMap_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

bool js_cocos2d_TMXTiledMap_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TMXTiledMap)", s.nativeThisObject());
        cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXTiledMap_finalize)

bool js_register_cocos2dx_TMXTiledMap(se::Object* obj)
{
    auto cls = se::Class::create("TMXTiledMap", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_TMXTiledMap_constructor));

    cls->defineFunction("setObjectGroups", _SE(js_cocos2dx_TMXTiledMap_setObjectGroups));
    cls->defineFunction("getProperty", _SE(js_cocos2dx_TMXTiledMap_getProperty));
    cls->defineFunction("getLayerNum", _SE(js_cocos2dx_TMXTiledMap_getLayerNum));
    cls->defineFunction("setMapSize", _SE(js_cocos2dx_TMXTiledMap_setMapSize));
    cls->defineFunction("getObjectGroup", _SE(js_cocos2dx_TMXTiledMap_getObjectGroup));
    cls->defineFunction("getObjectGroups", _SE(js_cocos2dx_TMXTiledMap_getObjectGroups));
    cls->defineFunction("getResourceFile", _SE(js_cocos2dx_TMXTiledMap_getResourceFile));
    cls->defineFunction("initWithTMXFile", _SE(js_cocos2dx_TMXTiledMap_initWithTMXFile));
    cls->defineFunction("getTileSize", _SE(js_cocos2dx_TMXTiledMap_getTileSize));
    cls->defineFunction("getMapSize", _SE(js_cocos2dx_TMXTiledMap_getMapSize));
    cls->defineFunction("initWithXML", _SE(js_cocos2dx_TMXTiledMap_initWithXML));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXTiledMap_getProperties));
    cls->defineFunction("getPropertiesForGID", _SE(js_cocos2dx_TMXTiledMap_getPropertiesForGID));
    cls->defineFunction("setTileSize", _SE(js_cocos2dx_TMXTiledMap_setTileSize));
    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXTiledMap_setProperties));
    cls->defineFunction("getLayer", _SE(js_cocos2dx_TMXTiledMap_getLayer));
    cls->defineFunction("getMapOrientation", _SE(js_cocos2dx_TMXTiledMap_getMapOrientation));
    cls->defineFunction("setMapOrientation", _SE(js_cocos2dx_TMXTiledMap_setMapOrientation));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TMXTiledMap_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TMXTiledMap_create));
    cls->defineStaticFunction("createWithXML", _SE(js_cocos2dx_TMXTiledMap_createWithXML));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TMXTiledMap_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXTiledMap>(cls);

    __jsb_cocos2d_TMXTiledMap_proto = cls->getProto();
    __jsb_cocos2d_TMXTiledMap_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TMXTiledMap.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_cocos2d_TileMapAtlas_proto = nullptr;
se::Class* __jsb_cocos2d_TileMapAtlas_class = nullptr;

static bool js_cocos2dx_TileMapAtlas_initWithTileFile(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = (cocos2d::TileMapAtlas*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TileMapAtlas_initWithTileFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        int arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_initWithTileFile : Error processing arguments");
        bool result = cobj->initWithTileFile(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_initWithTileFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TileMapAtlas_initWithTileFile)

static bool js_cocos2dx_TileMapAtlas_releaseMap(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = (cocos2d::TileMapAtlas*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TileMapAtlas_releaseMap : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->releaseMap();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TileMapAtlas_releaseMap)

static bool js_cocos2dx_TileMapAtlas_getTileAt(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = (cocos2d::TileMapAtlas*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TileMapAtlas_getTileAt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_getTileAt : Error processing arguments");
        cocos2d::Color3B result = cobj->getTileAt(arg0);
        ok &= Color3B_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_getTileAt : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TileMapAtlas_getTileAt)

static bool js_cocos2dx_TileMapAtlas_setTile(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = (cocos2d::TileMapAtlas*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TileMapAtlas_setTile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Color3B arg0;
        cocos2d::Vec2 arg1;
        ok &= seval_to_Color3B(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_setTile : Error processing arguments");
        cobj->setTile(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TileMapAtlas_setTile)

static bool js_cocos2dx_TileMapAtlas_setTGAInfo(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = (cocos2d::TileMapAtlas*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_TileMapAtlas_setTGAInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::sImageTGA* arg0 = nullptr;
        #pragma warning NO CONVERSION TO NATIVE FOR sImageTGA*
		ok = false;
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_setTGAInfo : Error processing arguments");
        cobj->setTGAInfo(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TileMapAtlas_setTGAInfo)

static bool js_cocos2dx_TileMapAtlas_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        int arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t *)&arg2);
        ok &= seval_to_int32(args[3], (int32_t *)&arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_create : Error processing arguments");
        auto result = cocos2d::TileMapAtlas::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TileMapAtlas_class, false);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TileMapAtlas_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TileMapAtlas_finalize)

static bool js_cocos2dx_TileMapAtlas_constructor(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = new (std::nothrow) cocos2d::TileMapAtlas();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TileMapAtlas_constructor, __jsb_cocos2d_TileMapAtlas_class, js_cocos2d_TileMapAtlas_finalize)

static bool js_cocos2dx_TileMapAtlas_ctor(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = new (std::nothrow) cocos2d::TileMapAtlas();
    s.thisObject()->setPrivateData(cobj);
    s.thisObject()->addRef();
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TileMapAtlas_ctor, __jsb_cocos2d_TileMapAtlas_class, js_cocos2d_TileMapAtlas_finalize)


    

extern se::Object* __jsb_cocos2d_AtlasNode_proto;

bool js_cocos2d_TileMapAtlas_finalize(se::State& s)
{
    if (s.nativeThisObject() != nullptr)
    {
        cocos2d::log("jsbindings: finalizing JS object %p (cocos2d::TileMapAtlas)", s.nativeThisObject());
        cocos2d::TileMapAtlas* cobj = (cocos2d::TileMapAtlas*)s.nativeThisObject();
        if (cobj->getReferenceCount() == 1)
            cobj->autorelease();
        else
            cobj->release();
    }
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TileMapAtlas_finalize)

bool js_register_cocos2dx_TileMapAtlas(se::Object* obj)
{
    auto cls = se::Class::create("TileMapAtlas", obj, __jsb_cocos2d_AtlasNode_proto, _SE(js_cocos2dx_TileMapAtlas_constructor));

    cls->defineFunction("initWithTileFile", _SE(js_cocos2dx_TileMapAtlas_initWithTileFile));
    cls->defineFunction("releaseMap", _SE(js_cocos2dx_TileMapAtlas_releaseMap));
    cls->defineFunction("getTileAt", _SE(js_cocos2dx_TileMapAtlas_getTileAt));
    cls->defineFunction("setTile", _SE(js_cocos2dx_TileMapAtlas_setTile));
    cls->defineFunction("setTGAInfo", _SE(js_cocos2dx_TileMapAtlas_setTGAInfo));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TileMapAtlas_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TileMapAtlas_create));
    cls->defineFinalizedFunction(_SE(js_cocos2d_TileMapAtlas_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TileMapAtlas>(cls);

    __jsb_cocos2d_TileMapAtlas_proto = cls->getProto();
    __jsb_cocos2d_TileMapAtlas_class = cls;

    se::ScriptEngine::getInstance()->executeScriptBuffer("(function () { cc.TileMapAtlas.extend = cc.Class.extend; })()");
    return true;
}

se::Object* __jsb_CocosDenshion_SimpleAudioEngine_proto = nullptr;
se::Class* __jsb_CocosDenshion_SimpleAudioEngine_class = nullptr;

static bool js_cocos2dx_SimpleAudioEngine_preloadBackgroundMusic(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_preloadBackgroundMusic : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_preloadBackgroundMusic : Error processing arguments");
        cobj->preloadBackgroundMusic(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_preloadBackgroundMusic)

static bool js_cocos2dx_SimpleAudioEngine_stopBackgroundMusic(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_stopBackgroundMusic : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cobj->stopBackgroundMusic();
        return true;
    }
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_stopBackgroundMusic : Error processing arguments");
        cobj->stopBackgroundMusic(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_stopBackgroundMusic)

static bool js_cocos2dx_SimpleAudioEngine_stopAllEffects(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_stopAllEffects : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stopAllEffects();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_stopAllEffects)

static bool js_cocos2dx_SimpleAudioEngine_getBackgroundMusicVolume(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_getBackgroundMusicVolume : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getBackgroundMusicVolume();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_getBackgroundMusicVolume : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_getBackgroundMusicVolume)

static bool js_cocos2dx_SimpleAudioEngine_resumeBackgroundMusic(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_resumeBackgroundMusic : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resumeBackgroundMusic();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_resumeBackgroundMusic)

static bool js_cocos2dx_SimpleAudioEngine_setBackgroundMusicVolume(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_setBackgroundMusicVolume : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_setBackgroundMusicVolume : Error processing arguments");
        cobj->setBackgroundMusicVolume(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_setBackgroundMusicVolume)

static bool js_cocos2dx_SimpleAudioEngine_preloadEffect(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_preloadEffect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_preloadEffect : Error processing arguments");
        cobj->preloadEffect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_preloadEffect)

static bool js_cocos2dx_SimpleAudioEngine_isBackgroundMusicPlaying(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_isBackgroundMusicPlaying : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isBackgroundMusicPlaying();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_isBackgroundMusicPlaying : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_isBackgroundMusicPlaying)

static bool js_cocos2dx_SimpleAudioEngine_getEffectsVolume(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_getEffectsVolume : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEffectsVolume();
        ok &= float_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_getEffectsVolume : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_getEffectsVolume)

static bool js_cocos2dx_SimpleAudioEngine_willPlayBackgroundMusic(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_willPlayBackgroundMusic : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->willPlayBackgroundMusic();
        ok &= boolean_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_willPlayBackgroundMusic : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_willPlayBackgroundMusic)

static bool js_cocos2dx_SimpleAudioEngine_pauseEffect(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_pauseEffect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_pauseEffect : Error processing arguments");
        cobj->pauseEffect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_pauseEffect)

static bool js_cocos2dx_SimpleAudioEngine_playEffect(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_playEffect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playEffect : Error processing arguments");
        unsigned int result = cobj->playEffect(arg0);
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playEffect : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        const char* arg0 = nullptr;
        bool arg1;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playEffect : Error processing arguments");
        unsigned int result = cobj->playEffect(arg0, arg1);
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playEffect : Error processing arguments");
        return true;
    }
    if (argc == 3) {
        const char* arg0 = nullptr;
        bool arg1;
        float arg2 = 0;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_boolean(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playEffect : Error processing arguments");
        unsigned int result = cobj->playEffect(arg0, arg1, arg2);
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playEffect : Error processing arguments");
        return true;
    }
    if (argc == 4) {
        const char* arg0 = nullptr;
        bool arg1;
        float arg2 = 0;
        float arg3 = 0;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_boolean(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playEffect : Error processing arguments");
        unsigned int result = cobj->playEffect(arg0, arg1, arg2, arg3);
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playEffect : Error processing arguments");
        return true;
    }
    if (argc == 5) {
        const char* arg0 = nullptr;
        bool arg1;
        float arg2 = 0;
        float arg3 = 0;
        float arg4 = 0;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_boolean(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        ok &= seval_to_float(args[4], &arg4);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playEffect : Error processing arguments");
        unsigned int result = cobj->playEffect(arg0, arg1, arg2, arg3, arg4);
        ok &= uint32_to_seval(result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playEffect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_playEffect)

static bool js_cocos2dx_SimpleAudioEngine_rewindBackgroundMusic(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_rewindBackgroundMusic : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->rewindBackgroundMusic();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_rewindBackgroundMusic)

static bool js_cocos2dx_SimpleAudioEngine_playBackgroundMusic(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_playBackgroundMusic : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playBackgroundMusic : Error processing arguments");
        cobj->playBackgroundMusic(arg0);
        return true;
    }
    if (argc == 2) {
        const char* arg0 = nullptr;
        bool arg1;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_boolean(args[1], &arg1);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_playBackgroundMusic : Error processing arguments");
        cobj->playBackgroundMusic(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_playBackgroundMusic)

static bool js_cocos2dx_SimpleAudioEngine_resumeAllEffects(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_resumeAllEffects : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resumeAllEffects();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_resumeAllEffects)

static bool js_cocos2dx_SimpleAudioEngine_setEffectsVolume(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_setEffectsVolume : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_setEffectsVolume : Error processing arguments");
        cobj->setEffectsVolume(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_setEffectsVolume)

static bool js_cocos2dx_SimpleAudioEngine_stopEffect(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_stopEffect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_stopEffect : Error processing arguments");
        cobj->stopEffect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_stopEffect)

static bool js_cocos2dx_SimpleAudioEngine_pauseBackgroundMusic(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_pauseBackgroundMusic : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->pauseBackgroundMusic();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_pauseBackgroundMusic)

static bool js_cocos2dx_SimpleAudioEngine_pauseAllEffects(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_pauseAllEffects : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->pauseAllEffects();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_pauseAllEffects)

static bool js_cocos2dx_SimpleAudioEngine_unloadEffect(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_unloadEffect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_unloadEffect : Error processing arguments");
        cobj->unloadEffect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_unloadEffect)

static bool js_cocos2dx_SimpleAudioEngine_resumeEffect(se::State& s)
{
    CocosDenshion::SimpleAudioEngine* cobj = (CocosDenshion::SimpleAudioEngine*)s.nativeThisObject();
    JSB_PRECONDITION2(cobj, false, "js_cocos2dx_SimpleAudioEngine_resumeEffect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], &arg0);
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_resumeEffect : Error processing arguments");
        cobj->resumeEffect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_resumeEffect)

static bool js_cocos2dx_SimpleAudioEngine_end(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        CocosDenshion::SimpleAudioEngine::end();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_end)

static bool js_cocos2dx_SimpleAudioEngine_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        CocosDenshion::SimpleAudioEngine* result = CocosDenshion::SimpleAudioEngine::getInstance();
        ok &= native_ptr_to_seval<CocosDenshion::SimpleAudioEngine>((CocosDenshion::SimpleAudioEngine*)result, &s.rval());
        JSB_PRECONDITION2(ok, false, "js_cocos2dx_SimpleAudioEngine_getInstance : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SimpleAudioEngine_getInstance)




bool js_register_cocos2dx_SimpleAudioEngine(se::Object* obj)
{
    auto cls = se::Class::create("AudioEngine", obj, nullptr, nullptr);

    cls->defineFunction("preloadMusic", _SE(js_cocos2dx_SimpleAudioEngine_preloadBackgroundMusic));
    cls->defineFunction("stopMusic", _SE(js_cocos2dx_SimpleAudioEngine_stopBackgroundMusic));
    cls->defineFunction("stopAllEffects", _SE(js_cocos2dx_SimpleAudioEngine_stopAllEffects));
    cls->defineFunction("getMusicVolume", _SE(js_cocos2dx_SimpleAudioEngine_getBackgroundMusicVolume));
    cls->defineFunction("resumeMusic", _SE(js_cocos2dx_SimpleAudioEngine_resumeBackgroundMusic));
    cls->defineFunction("setMusicVolume", _SE(js_cocos2dx_SimpleAudioEngine_setBackgroundMusicVolume));
    cls->defineFunction("preloadEffect", _SE(js_cocos2dx_SimpleAudioEngine_preloadEffect));
    cls->defineFunction("isMusicPlaying", _SE(js_cocos2dx_SimpleAudioEngine_isBackgroundMusicPlaying));
    cls->defineFunction("getEffectsVolume", _SE(js_cocos2dx_SimpleAudioEngine_getEffectsVolume));
    cls->defineFunction("willPlayMusic", _SE(js_cocos2dx_SimpleAudioEngine_willPlayBackgroundMusic));
    cls->defineFunction("pauseEffect", _SE(js_cocos2dx_SimpleAudioEngine_pauseEffect));
    cls->defineFunction("playEffect", _SE(js_cocos2dx_SimpleAudioEngine_playEffect));
    cls->defineFunction("rewindMusic", _SE(js_cocos2dx_SimpleAudioEngine_rewindBackgroundMusic));
    cls->defineFunction("playMusic", _SE(js_cocos2dx_SimpleAudioEngine_playBackgroundMusic));
    cls->defineFunction("resumeAllEffects", _SE(js_cocos2dx_SimpleAudioEngine_resumeAllEffects));
    cls->defineFunction("setEffectsVolume", _SE(js_cocos2dx_SimpleAudioEngine_setEffectsVolume));
    cls->defineFunction("stopEffect", _SE(js_cocos2dx_SimpleAudioEngine_stopEffect));
    cls->defineFunction("pauseMusic", _SE(js_cocos2dx_SimpleAudioEngine_pauseBackgroundMusic));
    cls->defineFunction("pauseAllEffects", _SE(js_cocos2dx_SimpleAudioEngine_pauseAllEffects));
    cls->defineFunction("unloadEffect", _SE(js_cocos2dx_SimpleAudioEngine_unloadEffect));
    cls->defineFunction("resumeEffect", _SE(js_cocos2dx_SimpleAudioEngine_resumeEffect));
    cls->defineStaticFunction("end", _SE(js_cocos2dx_SimpleAudioEngine_end));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_SimpleAudioEngine_getInstance));
    cls->install();
    JSBClassType::registerClass<CocosDenshion::SimpleAudioEngine>(cls);

    __jsb_CocosDenshion_SimpleAudioEngine_proto = cls->getProto();
    __jsb_CocosDenshion_SimpleAudioEngine_class = cls;

    return true;
}

bool register_all_cocos2dx(se::Object* obj)
{
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("cc", &nsVal))
    {
        se::Object* jsobj = se::Object::createPlainObject(false);
        nsVal.setObject(jsobj);
        obj->setProperty("cc", nsVal);
        jsobj->release();
    }
    se::Object* ns = nsVal.toObject();

    js_register_cocos2dx_RenderState(ns);
    js_register_cocos2dx_Material(ns);
    js_register_cocos2dx_Action(ns);
    js_register_cocos2dx_FiniteTimeAction(ns);
    js_register_cocos2dx_ActionInstant(ns);
    js_register_cocos2dx_Hide(ns);
    js_register_cocos2dx_Node(ns);
    js_register_cocos2dx_Scene(ns);
    js_register_cocos2dx_TransitionScene(ns);
    js_register_cocos2dx_TransitionEaseScene(ns);
    js_register_cocos2dx_TransitionMoveInL(ns);
    js_register_cocos2dx_TransitionMoveInB(ns);
    js_register_cocos2dx_Layer(ns);
    js_register_cocos2dx___LayerRGBA(ns);
    js_register_cocos2dx_AtlasNode(ns);
    js_register_cocos2dx_TileMapAtlas(ns);
    js_register_cocos2dx_TransitionMoveInT(ns);
    js_register_cocos2dx_TMXTilesetInfo(ns);
    js_register_cocos2dx_TransitionMoveInR(ns);
    js_register_cocos2dx_ParticleSystem(ns);
    js_register_cocos2dx_ParticleSystemQuad(ns);
    js_register_cocos2dx_ParticleSpiral(ns);
    js_register_cocos2dx_GridBase(ns);
    js_register_cocos2dx_AnimationCache(ns);
    js_register_cocos2dx_ActionInterval(ns);
    js_register_cocos2dx_ActionCamera(ns);
    js_register_cocos2dx_ProgressFromTo(ns);
    js_register_cocos2dx_MoveBy(ns);
    js_register_cocos2dx_MoveTo(ns);
    js_register_cocos2dx_JumpBy(ns);
    js_register_cocos2dx_EventListener(ns);
    js_register_cocos2dx_EventListenerKeyboard(ns);
    js_register_cocos2dx_ActionEase(ns);
    js_register_cocos2dx_EaseBounceIn(ns);
    js_register_cocos2dx_ComponentContainer(ns);
    js_register_cocos2dx_Director(ns);
    js_register_cocos2dx_Scheduler(ns);
    js_register_cocos2dx_EaseElastic(ns);
    js_register_cocos2dx_EaseElasticOut(ns);
    js_register_cocos2dx_EaseQuadraticActionInOut(ns);
    js_register_cocos2dx_EaseBackOut(ns);
    js_register_cocos2dx_Texture2D(ns);
    js_register_cocos2dx_TransitionSceneOriented(ns);
    js_register_cocos2dx_TransitionFlipX(ns);
    js_register_cocos2dx_CameraBackgroundBrush(ns);
    js_register_cocos2dx_CameraBackgroundDepthBrush(ns);
    js_register_cocos2dx_CameraBackgroundColorBrush(ns);
    js_register_cocos2dx_GridAction(ns);
    js_register_cocos2dx_TiledGrid3DAction(ns);
    js_register_cocos2dx_FadeOutTRTiles(ns);
    js_register_cocos2dx_FadeOutUpTiles(ns);
    js_register_cocos2dx_FadeOutDownTiles(ns);
    js_register_cocos2dx_StopGrid(ns);
    js_register_cocos2dx_Technique(ns);
    js_register_cocos2dx_SkewTo(ns);
    js_register_cocos2dx_SkewBy(ns);
    js_register_cocos2dx_EaseQuadraticActionOut(ns);
    js_register_cocos2dx_TransitionProgress(ns);
    js_register_cocos2dx_TransitionProgressVertical(ns);
    js_register_cocos2dx_TMXTiledMap(ns);
    js_register_cocos2dx_Grid3DAction(ns);
    js_register_cocos2dx_BaseLight(ns);
    js_register_cocos2dx_SpotLight(ns);
    js_register_cocos2dx_FadeTo(ns);
    js_register_cocos2dx_FadeIn(ns);
    js_register_cocos2dx_DirectionLight(ns);
    js_register_cocos2dx_ShakyTiles3D(ns);
    js_register_cocos2dx_EventListenerCustom(ns);
    js_register_cocos2dx_FlipX3D(ns);
    js_register_cocos2dx_FlipY3D(ns);
    js_register_cocos2dx_EaseSineInOut(ns);
    js_register_cocos2dx_TransitionFlipAngular(ns);
    js_register_cocos2dx_SimpleAudioEngine(ns);
    js_register_cocos2dx_EaseElasticInOut(ns);
    js_register_cocos2dx_EaseBounce(ns);
    js_register_cocos2dx_Show(ns);
    js_register_cocos2dx_FadeOut(ns);
    js_register_cocos2dx_CallFunc(ns);
    js_register_cocos2dx_Event(ns);
    js_register_cocos2dx_EventMouse(ns);
    js_register_cocos2dx_GLView(ns);
    js_register_cocos2dx_EaseBezierAction(ns);
    js_register_cocos2dx_ParticleFireworks(ns);
    js_register_cocos2dx_MenuItem(ns);
    js_register_cocos2dx_MenuItemSprite(ns);
    js_register_cocos2dx_MenuItemImage(ns);
    js_register_cocos2dx_ParticleFire(ns);
    js_register_cocos2dx_ProgressTo(ns);
    js_register_cocos2dx_ParticleSmoke(ns);
    js_register_cocos2dx_TransitionZoomFlipAngular(ns);
    js_register_cocos2dx_EaseRateAction(ns);
    js_register_cocos2dx_EaseIn(ns);
    js_register_cocos2dx_EaseExponentialInOut(ns);
    js_register_cocos2dx_CardinalSplineTo(ns);
    js_register_cocos2dx_CatmullRomTo(ns);
    js_register_cocos2dx_Waves3D(ns);
    js_register_cocos2dx_EaseExponentialOut(ns);
    js_register_cocos2dx_Label(ns);
    js_register_cocos2dx_Application(ns);
    js_register_cocos2dx_DelayTime(ns);
    js_register_cocos2dx_LabelAtlas(ns);
    js_register_cocos2dx_LabelBMFont(ns);
    js_register_cocos2dx_AsyncTaskPool(ns);
    js_register_cocos2dx_ParticleSnow(ns);
    js_register_cocos2dx_EaseElasticIn(ns);
    js_register_cocos2dx_EaseCircleActionInOut(ns);
    js_register_cocos2dx_TransitionFadeTR(ns);
    js_register_cocos2dx_EaseQuarticActionOut(ns);
    js_register_cocos2dx_EventAcceleration(ns);
    js_register_cocos2dx_EaseCubicActionIn(ns);
    js_register_cocos2dx_TextureCache(ns);
    js_register_cocos2dx_SpriteBatchNode(ns);
    js_register_cocos2dx_TMXLayer(ns);
    js_register_cocos2dx_Configuration(ns);
    js_register_cocos2dx_ActionTween(ns);
    js_register_cocos2dx_TransitionFadeDown(ns);
    js_register_cocos2dx_ParticleSun(ns);
    js_register_cocos2dx_TransitionProgressHorizontal(ns);
    js_register_cocos2dx_TMXObjectGroup(ns);
    js_register_cocos2dx_CameraBackgroundSkyBoxBrush(ns);
    js_register_cocos2dx_FlipX(ns);
    js_register_cocos2dx_FlipY(ns);
    js_register_cocos2dx_TransitionSplitCols(ns);
    js_register_cocos2dx_RepeatForever(ns);
    js_register_cocos2dx_Place(ns);
    js_register_cocos2dx_EventListenerAcceleration(ns);
    js_register_cocos2dx_TiledGrid3D(ns);
    js_register_cocos2dx_EaseBounceOut(ns);
    js_register_cocos2dx_RenderTexture(ns);
    js_register_cocos2dx_TintBy(ns);
    js_register_cocos2dx_TransitionShrinkGrow(ns);
    js_register_cocos2dx_LabelTTF(ns);
    js_register_cocos2dx_ClippingNode(ns);
    js_register_cocos2dx_ActionFloat(ns);
    js_register_cocos2dx_ParticleFlower(ns);
    js_register_cocos2dx_EaseCircleActionIn(ns);
    js_register_cocos2dx_Image(ns);
    js_register_cocos2dx_LayerMultiplex(ns);
    js_register_cocos2dx_Blink(ns);
    js_register_cocos2dx_JumpTo(ns);
    js_register_cocos2dx_ParticleExplosion(ns);
    js_register_cocos2dx_TransitionJumpZoom(ns);
    js_register_cocos2dx_Pass(ns);
    js_register_cocos2dx_Touch(ns);
    js_register_cocos2dx_SAXParser(ns);
    js_register_cocos2dx_CardinalSplineBy(ns);
    js_register_cocos2dx_CatmullRomBy(ns);
    js_register_cocos2dx_NodeGrid(ns);
    js_register_cocos2dx_TMXLayerInfo(ns);
    js_register_cocos2dx_EaseSineIn(ns);
    js_register_cocos2dx_EventListenerMouse(ns);
    js_register_cocos2dx_Camera(ns);
    js_register_cocos2dx_GLProgram(ns);
    js_register_cocos2dx_ParticleGalaxy(ns);
    js_register_cocos2dx_Twirl(ns);
    js_register_cocos2dx_MenuItemLabel(ns);
    js_register_cocos2dx_EaseQuinticActionIn(ns);
    js_register_cocos2dx_LayerColor(ns);
    js_register_cocos2dx_FadeOutBLTiles(ns);
    js_register_cocos2dx_LayerGradient(ns);
    js_register_cocos2dx_EventListenerTouchAllAtOnce(ns);
    js_register_cocos2dx_ToggleVisibility(ns);
    js_register_cocos2dx_Repeat(ns);
    js_register_cocos2dx_TransitionFlipY(ns);
    js_register_cocos2dx_TurnOffTiles(ns);
    js_register_cocos2dx_TintTo(ns);
    js_register_cocos2dx_EaseBackInOut(ns);
    js_register_cocos2dx_TransitionFadeBL(ns);
    js_register_cocos2dx_TargetedAction(ns);
    js_register_cocos2dx_DrawNode(ns);
    js_register_cocos2dx_TransitionTurnOffTiles(ns);
    js_register_cocos2dx_RotateTo(ns);
    js_register_cocos2dx_TransitionSplitRows(ns);
    js_register_cocos2dx_Device(ns);
    js_register_cocos2dx_TransitionProgressRadialCCW(ns);
    js_register_cocos2dx_EventListenerFocus(ns);
    js_register_cocos2dx_TransitionPageTurn(ns);
    js_register_cocos2dx_Properties(ns);
    js_register_cocos2dx_BezierBy(ns);
    js_register_cocos2dx_BezierTo(ns);
    js_register_cocos2dx_ParticleMeteor(ns);
    js_register_cocos2dx_SpriteFrame(ns);
    js_register_cocos2dx_Liquid(ns);
    js_register_cocos2dx_ParticleBatchNode(ns);
    js_register_cocos2dx_TransitionZoomFlipX(ns);
    js_register_cocos2dx_EventFocus(ns);
    js_register_cocos2dx_EaseQuinticActionInOut(ns);
    js_register_cocos2dx_TransitionRotoZoom(ns);
    js_register_cocos2dx_SpriteFrameCache(ns);
    js_register_cocos2dx_PointLight(ns);
    js_register_cocos2dx_TransitionCrossFade(ns);
    js_register_cocos2dx_Ripple3D(ns);
    js_register_cocos2dx_Lens3D(ns);
    js_register_cocos2dx_ScaleTo(ns);
    js_register_cocos2dx_Spawn(ns);
    js_register_cocos2dx_EaseQuarticActionInOut(ns);
    js_register_cocos2dx_GLProgramState(ns);
    js_register_cocos2dx_PageTurn3D(ns);
    js_register_cocos2dx_TransitionSlideInL(ns);
    js_register_cocos2dx_TransitionSlideInT(ns);
    js_register_cocos2dx_Grid3D(ns);
    js_register_cocos2dx_EaseCircleActionOut(ns);
    js_register_cocos2dx_TransitionProgressInOut(ns);
    js_register_cocos2dx_EaseCubicActionInOut(ns);
    js_register_cocos2dx_EaseBackIn(ns);
    js_register_cocos2dx_SplitRows(ns);
    js_register_cocos2dx_Follow(ns);
    js_register_cocos2dx_Animate(ns);
    js_register_cocos2dx_ShuffleTiles(ns);
    js_register_cocos2dx_ReverseTime(ns);
    js_register_cocos2dx_ProgressTimer(ns);
    js_register_cocos2dx_EaseQuarticActionIn(ns);
    js_register_cocos2dx_Menu(ns);
    js_register_cocos2dx_EaseInOut(ns);
    js_register_cocos2dx_TransitionZoomFlipY(ns);
    js_register_cocos2dx_ScaleBy(ns);
    js_register_cocos2dx_EventTouch(ns);
    js_register_cocos2dx_Animation(ns);
    js_register_cocos2dx_TMXMapInfo(ns);
    js_register_cocos2dx_EaseExponentialIn(ns);
    js_register_cocos2dx_ReuseGrid(ns);
    js_register_cocos2dx_EaseQuinticActionOut(ns);
    js_register_cocos2dx_EventDispatcher(ns);
    js_register_cocos2dx_MenuItemAtlasFont(ns);
    js_register_cocos2dx_ActionManager(ns);
    js_register_cocos2dx_OrbitCamera(ns);
    js_register_cocos2dx_ParallaxNode(ns);
    js_register_cocos2dx_TransitionFade(ns);
    js_register_cocos2dx_Component(ns);
    js_register_cocos2dx_EaseCubicActionOut(ns);
    js_register_cocos2dx_EventListenerTouchOneByOne(ns);
    js_register_cocos2dx_TextFieldTTF(ns);
    js_register_cocos2dx_ParticleRain(ns);
    js_register_cocos2dx_Waves(ns);
    js_register_cocos2dx_EaseOut(ns);
    js_register_cocos2dx_MenuItemFont(ns);
    js_register_cocos2dx_TransitionFadeUp(ns);
    js_register_cocos2dx_EaseSineOut(ns);
    js_register_cocos2dx_JumpTiles3D(ns);
    js_register_cocos2dx_MenuItemToggle(ns);
    js_register_cocos2dx_RemoveSelf(ns);
    js_register_cocos2dx_SplitCols(ns);
    js_register_cocos2dx_ProtectedNode(ns);
    js_register_cocos2dx_MotionStreak(ns);
    js_register_cocos2dx_RotateBy(ns);
    js_register_cocos2dx_FileUtils(ns);
    js_register_cocos2dx_Sprite(ns);
    js_register_cocos2dx_CallFuncN(ns);
    js_register_cocos2dx_TransitionProgressOutIn(ns);
    js_register_cocos2dx_AnimationFrame(ns);
    js_register_cocos2dx_Sequence(ns);
    js_register_cocos2dx_Shaky3D(ns);
    js_register_cocos2dx_TransitionProgressRadialCW(ns);
    js_register_cocos2dx_EaseBounceInOut(ns);
    js_register_cocos2dx_TransitionSlideInR(ns);
    js_register_cocos2dx___NodeRGBA(ns);
    js_register_cocos2dx_AmbientLight(ns);
    js_register_cocos2dx_GLProgramCache(ns);
    js_register_cocos2dx_EaseQuadraticActionIn(ns);
    js_register_cocos2dx_WavesTiles3D(ns);
    js_register_cocos2dx_TransitionSlideInB(ns);
    js_register_cocos2dx_Speed(ns);
    js_register_cocos2dx_EventCustom(ns);
    js_register_cocos2dx_ShatteredTiles3D(ns);
    return true;
}

